%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Tex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pvs-gr.txt -- The PVS grammar for ERGO
%% Author          : Sam Owre
%% Created On      : Thu Dec  2 13:45:18 1993
%% Last Modified By: Sam Owre
%% Last Modified On: Wed Nov  4 16:14:48 1998
%% Update Count    : 93
%% Status          : Stable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% --------------------------------------------------------------------
%% PVS
%% Copyright (C) 2006, SRI International.  All Rights Reserved.

%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.

%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.

%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%% --------------------------------------------------------------------

Grammar PVS

Case Sensitive

Comment Character
	Newline  '%'

Operators
% Adding new operators may require modification to the following variables,
% and functions:
%  Var or Fun		File
%  ----------		----
%  *pvs-operators*	globals.lisp
%  *pvs-prec-info*      pp.lisp
%  *infix-operators*    ergo-runtime-fixes.lisp
%  *unary-operators*    ergo-runtime-fixes.lisp
%  
	'('  ')'  '-'  '+'  '*' '/' ':=' '::=' '|->'  ';' ','  '='  '/='
	'<'  '<='  '>'  '>=' '{' '}' '[' ']' '.' '&' '<=>'
	'->' ':' '=>' '[#' '#]' '(#' '#)' '(:' ':)' '{:' ':}' '{{' '}}' '|'
        '^' '/\\' '\\/' '<>' '~' '==' '++' '**' '//' '^^' % '[]'
	'<<' '>>' '::' '#' '@' '@@' '##' '|[' ']|' '!'
        '<<=' '>>=' '`' % '\''
        '..' '||' '|-' '|=' '<|' '|>' ':->' % '<:'
	 '§' '[:' ':]'
        %% Bracketing operators 
	'[|' '|]' '[||]' '(|' '|)' '(||)' '{|' '|}' '{||}'
        %% Unicode bracketing operators (TeX input method map shown)
	'〈' '〉' '〈〉'    % \langle \rangle
        '⟦' '⟧' '⟦⟧' % \llbracket \rrbracket
        '«' '»' '«»'    % \"< \">
        '⟪' '⟫' '⟪⟫' % \ldata \rdata
        '⌈' '⌉' '⌈⌉'    % \lceil \rceil
        '⌊' '⌋' '⌊⌋'    % \lfloor \rfloor
	'⌜' '⌝' '⌜⌝'    % \ulcorner \urcorner
	'⌞' '⌟' '⌞⌟'    % \llcorner \lrcorner

        % '∣' '∥' don't work - start and end must be distinct
        %% Unicode prefix operators
        '□' '◇' '¬' '◯' '√' '∃' '∀'
	%% Unicode infix operators
	'∘' '∨' '∧' '⊕' '⊘' '⊗' '⊖' '⊙' '⊛' '⨁' '⨂' '⨀'
	'⊢' '⊨' '±' '∓' '∔' '×' '÷' '⊞' '⊟' '⊠' '≁' '≠' '∼' '≃' '≅' '≇'
	'≈' '≉' '≍' '≎' '≏' '≐' '≗' '≙' '≡' '⋈' '≤' '≥' '≦' '≧'
	'≨' '≩' '≪' '≫' '≮' '≯' '≰' '≱' '≺' '≻' '◁' '▷'
	'∈' '∉' '∋' '∩' '∪' '⊂' '⊃' '⊄' '⊅' '⊆' '⊇' '⊎' '⊊' '⊋'
	'⊏' '⊐' '⊑' '⊒' '⊓' '⊔' '⋀' '⋁' '⋂' '⋃' '•' '←' '↑' '→' '↓' '↝' '↦'
	'⇐' '⇒' '⇑' '⇓' '⇔' '∇' '⊣' '⊥' '⊩' '◯' '★' '✠'

Lexical Terminals
	id, number, string, keyword %, literal

Precedence Information
  type-expr  'WITH' medial left
             '[' initial
             jux medial left

  units-expr  '*' medial left, '/' medial left
	      '^' medial left

  expr  'HAS_TYPE' aggregate,
	'IN' aggregate % LET
	'|' medial left
	'⊢' medial right, '⊨' medial right, '|-' medial right, '|=' medial right
	'IFF' medial right, '<=>' medial right, '⇔' medial right
	'IMPLIES' medial right, '=>' medial right, '⇒' medial right,
		'WHEN' medial right
	'OR' medial right, '∨' medial right, '\\/' medial right,
		'XOR' medial right, 'ORELSE' medial right
	'AND' medial right, '&' medial right, '∧' medial right,
		'/\\' medial right, '&&' medial right, 'ANDTHEN' medial right
	'NOT' initial, '~' initial, '¬' initial
	'=' medial left, '/=' medial left, '≠' medial left, '==' medial left
        '<' medial left, '<=' medial left,
		'>' medial left, '>=' medial left,
		'<<' medial left, '>>' medial left,
                '<<=' medial left, '>>=' medial left,
		'<|' medial left, '|>' medial left
	'WITH' medial left
	'WHERE' medial left, 'IN' medial left
	'@' medial left, '#' medial left 
	'@@' medial left, '##' medial left, 
		'||' medial left
        '⊞' medial left, '⊟' medial left, '⊠' medial left, '≁' medial left,
            '∼' medial left,
	    '≃' medial left, '≅' medial left, '≇' medial left, '≈' medial left,
            '≉' medial left, '≍' medial left, '≎' medial left, '≏' medial left,
            '≐' medial left, '≗' medial left, '≙' medial left, '≡' medial left,
            '⋈' medial left, '≤' medial left, '≥' medial left, '≦' medial left,
            '≧' medial left, '≨' medial left, '≩' medial left, '≪' medial left,
            '≫' medial left, '≮' medial left, '≯' medial left, '≰' medial left,
            '≱' medial left, '≺' medial left, '≻' medial left, '◁' medial left,
	    '▷' medial left, '∈' medial left, '∉' medial left, '∋' medial left,
            '⊂' medial left, '⊃' medial left,
            '⊄' medial left, '⊅' medial left, '⊆' medial left, '⊇' medial left,
	    '⊏' medial left, '⊐' medial left, '⊑' medial left, '⊒' medial left,
            '⊊' medial left, '⊋' medial left,
            '•' medial left, '←' medial left, '↑' medial left,
	    '→' medial left, '↓' medial left, '↝' medial left, '↦' medial left,
	    '⇐' medial left, '⇑' medial left, '⇓' medial left,
            '∇' medial left, '⊣' medial left, '⊥' medial left,
            '⊩' medial left, '◯' medial left, '★' medial left, '✠' medial left
	'+' medial left, '-' medial left, '++' medial left,
		'~' medial left, '⊕' medial left, '⊖' medial left,
		'⨁' medial left, '±' medial left, '∓' medial left, '∔' medial left,
		'⊎' medial left, '∪' medial left, '⊔' medial left, '⋁' medial left,
		'⋃' medial left
	'*' medial left, '/' medial left, '**' medial left,
		'//' medial left, '⊗' medial left, '⊙' medial left, '⊘' medial left,
		'⊛' medial left, '⨂' medial left, '⨀' medial left,  '×' medial left,
		'÷' medial left, '∩' medial left, '⊓' medial left, '⋀' medial left,
		'⋂' medial left, '√' medial left,
	'-' initial, '+' initial, '◯' initial, '√' initial
	'O' medial left, '∘' medial left
	':' medial left, '::' medial left, 'HAS_TYPE' medial left
	'□' initial, '◇' initial, '<>' initial % , '[]'
	'^' medial left, '^^' medial left
	'`' medial left
	jux medial left  % application


adt-or-theories	::= {adt-or-theory+} <adt-or-modules(adt-or-theory+)>;

% SO - require endid so that multiple theories parse

adt-or-theory ::= {id [theory-formals] ':' {theory | datatype}}
		    <adt-or-module(id,[no-theory-formals()|theory-formals],
                                   alt)>;

theory ::= {'THEORY' [exporting]^e 'BEGIN' [assuming-part]^a
            [theory-part]^t 'END' id}
	      <module([noexp()|exporting]^e,
		      [noass()|assuming-part]^a,
                      [notheory()|theory-part]^t,id)>;

datatype ::= {{'DATATYPE'|'CODATATYPE'}^k ['WITH' 'SUBTYPES' pidops^s]
	      'BEGIN'
	      {importing-elt|assuming-part|id-datatype-elt}+
	      'END' pidop}
	        <{[datatype(adtbody(plus),pidop)
		  |datatypes(pidops^s,adtbody(plus),pidop)]
                 |[codatatype(adtbody(plus),pidop)
		  |codatatypes(pidops^s, adtbody(plus),pidop)]}^k>;

id-datatype-elt ::= {pidop {{':' theory-decl [semic]} | {[theory-formals]^f adtcase}}}
                     <{id-theory-decl(pidop, theory-decl, opt)
                      |id-adtcase(pidop, [nofmls() | theory-formals]^f, adtcase)}>;

adtcase ::= {[constructor]^c ':' pidop^r [':' pidop^s]}
              <[adtcase(opt^c,pidop^r)
               |adtcase-subtype(opt^c,pidop^r,pidop^s)]>;

constructor ::= {'(' {{{pidops ':' type-expr}
 		  <adtdecl(pidops,type-expr)>} ++ ','} ')'}
 		<adtdecls(doubleplus)>;

theory-formals	::= {'[' {theory-formal ++ ','} ']'}
			<theory-formals(theory-formal+)>;

theory-formal ::= {[{'(' [idop ':' lib-decl] importing ')'}
                     <formal-importing-elt([nolib()|lib-fdecl(idop,lib-decl)],
                                           importing)>]
                   idopappls ':' theory-formal-decl}
		     <theory-formal(opt,idopappls,theory-formal-decl)>;

%% theory-formal ::= {[{'(' importing ')'}
%%                      <formal-importing-elt(importing)>]
%%                    depidops ':' theory-formal-decl}
%% 		     <theory-formal(opt,depidops,theory-formal-decl)>;

idopappls ::= {idopappl++','} <idopappls(idopappl+)>;

idopappl ::= {idop ['(' type-expr++',' ')']}
                <[idop|idopappl(idop,deptypes(type-expr+))]>;

theory-formal-decl ::= {type-keyword [{'FROM' type-expr}|{'<' ':' type-expr}]}
		        <ftype-decl(type-keyword,[notype()|{type-expr|struct-subtype(type-expr)}])>
		     | {type-expr} <fconst-decl(type-expr)>
		     % | {type-expr [auto-extend]}
                     %    <fconst-decl(type-expr, [noext()|auto-extend])>
		     | {'THEORY' theory-decl-modname}
                        <ftheory-decl(theory-decl-modname)>
		     ;

exporting ::= {'EXPORTING' exportings [{ 'WITH' exportingmods}]}
	        <exporting(exportings,[noexportingmods()|exportingmods])>;

exportings ::= {'ALL' ['BUT' {expname ++ ','}]}
			<exporting-all([noexpbuts()|expbuts(doubleplus)])>
		 |  {expname ++ ','}
			<expnames(doubleplus)>
		 ;

expname ::= {pidop [':' {type-expr <type-expr> |
			'TYPE' <exptype()> |
			'FORMULA' <expformula()>}]}
			<expname(pidop,[noexpkind()|alt])>
%		 |  {'|' idop '|'} <absexpname(idop)>
		 ;

exportingmods ::= 'ALL' <expmodall()>
		|  'CLOSURE' <expmodclosure()>
		|  modnames
		;

assuming-part ::= {'ASSUMING' assumings 'ENDASSUMING'} <assumings>;

assumings ::= {assuming+} <assuming-part(plus)>;

assuming ::= {importing [semic]}
               <importing-elt(importing,[nosemic()|semic(semic)])>
           | {judgement [semic]}
                 <judgement-elt(judgement,[nosemic()|semic(semic)])>
	   | {conversion [semic]}
		 <conversion-elt(conversion,[nosemic()|semic(semic)])>
	   | {auto-rewrite [semic]}
		 <auto-rewrite-elt(auto-rewrite,[nosemic()|semic(semic)])>
	   | {['§']^d pidops [theory-formals]^f [pdformals+]
                          ':' assuming-decl [semic]^s}
		<assuming([no-sec()|sec()]^d,pidops,
		          [no-theory-formals()|theory-formals]^f,
		          [noformals()|pdf(plus)],assuming-decl,
                          [nosemic()|semic(semic)]^s,[noatdecl()|atdecl()]^d)>
	   ;

theory-part ::= {theory-elt+} <theory-part(plus)>;

theory-elt ::= {importing [semic]}
                 <importing-elt(importing,[nosemic()|semic(semic)])>
	     | {judgement [semic]}
                 <judgement-elt(judgement,[nosemic()|semic(semic)])>
	     | {conversion [semic]}
		 <conversion-elt(conversion,[nosemic()|semic(semic)])>
	     | {auto-rewrite [semic]}
		 <auto-rewrite-elt(auto-rewrite,[nosemic()|semic(semic)])>
	     | {['§']^d pidops [theory-formals]^f [pdformals+]
	                    ':' theory-declaration [semic]^s}
		 <theory([no-sec()|sec()]^d,pidops,
		         [no-theory-formals()|theory-formals]^f,
		         [noformals()|pdf(plus)],theory-declaration,
                         [nosemic()|semic(semic)]^s,[noatdecl()|atdecl()]^d)>
	     ;

importing-elt ::= {importing [semic]}
                  <importing-elt(importing,[nosemic()|semic(semic)])>;

importing ::= {'IMPORTING' {importing-item++ ','}}
              <importing(importing-item+)>;

importing-item ::= {modname ['AS' pidop]}
                  <[modname|theory-abbreviation-decl(modname,pidop)]>;

judgement ::= {['RECURSIVE'] 'JUDGEMENT' {jdecl++','}
               {'HAS_TYPE'|'SUBTYPE_OF'} type-expr}
	      <{judgement(jdecls(doubleplus),
                 [{has-type()|subtype-of()}|{rec-has-type()|rec-subtype-of()}],
                 type-expr)>
            % | {'EXPRESSION' 'JUDGEMENT' expr 'HAS_TYPE' type-expr}
            %   <expr-judgement(expr, type-expr)>
            ;

jdecl ::= expr <jdecl-expr(expr)>
        | comp-type-expr <jdecl-type(comp-type-expr)>
        ;

ename ::= {name [':' type-expr]} <ename(name,[notype()|type-expr])>;


conversion ::= {{'CONVERSION'|'CONVERSION+'|'CONVERSION-'} {expr++','}}
          <{conversion(expr+)|conversionplus(expr+)|conversionminus(expr+)}>;

auto-rewrite ::= {{'AUTO_REWRITE'|'AUTO_REWRITE+'|'AUTO_REWRITE-'}
                  {rewrite-name++','}}
	         <{auto-rewrite(rewrite-name+)
                  |auto-rewriteplus(rewrite-name+)
                  |auto-rewriteminus(rewrite-name+)}> ;

rewrite-name-or-fnum ::= {'-' number ['!' ['!']^m]^e}
                         <rewrite-fnum(fnum(number,`-()),
                                       [lazy()|[eager()|macro()]^m]^e)>
                       | rewrite-name
                       ;

% fnum ::= {['-'] number} <fnum(number,[`+()|`-()])> ;

rewrite-name ::= {name ['!' ['!']^m]^e [':' {type-expr|formula-name}]}
                 <{rewrite-name(name,
                                [lazy()|[eager()|macro()]^m]^e,
                                [noqual()|
                                 {type(type-expr)|formula(formula-name)}])}> ;

% called "Bindings" in language doc.
pdformals ::= {'(' adformals ')'} <adformals>;

adformals ::= {adformal++','} <adformals(adformal+)>;

adformal ::= typed-id
	   | {'(' typed-ids ')'} <typed-ids>
	   ;

assuming-decl ::= theory-declaration | assumption;

theory-declaration ::= lib-decl | theory-decl | type-decl | units-decl | var-decl
              | const-decl | macro-decl | def-decl | ind-decl | corec-decl
              | coind-decl | formula-decl | datatype | judgement;

lib-decl ::= {'LIBRARY' ['='] string} <lib-decl([noeq()|eq()],string)>;

theory-decl ::= {'THEORY' '=' theory-decl-modname}
                   <theory-decl(theory-decl-modname)>;

type-decl ::= {type-keyword [type-def ['CONTAINING' expr]^c]}
                <[uninterp-type-decl(type-keyword)
                 |type-decl(type-keyword,type-def,
                            [nocontains()|expr]^c)]>;

type-keyword ::= 'TYPE' <type()>
               | 'NONEMPTY_TYPE' <nonempty-type()>
               | 'TYPE+' <typeplus()>
               ;

% '=' must appear in name type-def, to avoid overlap with '=' as an opsym.
type-def ::= {{'=' <equal()> | 'FROM' <from()> | {'<' ':'} <`\<\:()>}
              type-expr}
		<type-def(alt,type-expr)>;

units-decl ::= {'_UNIT' '=' units-expr ['+' rational]}
                   <units-decl(units-expr,[no-offset()|rational])>;

units-expr ::= name
             | {units-expr '^' rational} <units-term(`^(),units-expr,rational)>
             | {units-expr^l '*' units-expr^r}
                      <units-term(`*(),units-expr^l,units-expr^r)>
             | {units-expr^l '/' units-expr^r}
                      <units-term(`\/(),units-expr^l,units-expr^r)>
             ;

rational ::= {['-']^s number^n ['/' number^d]}
              <rational([pos()|neg()]^s,number^n,[noden()|number^d])>;

var-decl ::= {'VAR' type-expr} <var-decl(type-expr)>;

const-decl ::= {type-expr [const-value]}
		<[uninterp-const-decl(type-expr)
		 |const-decl(type-expr,const-value)]>;

% const-decl ::= {type-expr [auto-extend]^a [const-value]}
% 		<[uninterp-const-decl(type-expr, [noext()|auto-extend]^a)
% 		 |const-decl(type-expr, [noext()|auto-extend]^a, const-value)]>;

const-value ::= {'=' expr} <expr>;

def-decl ::= {'RECURSIVE' type-expr '=' expr 'MEASURE' expr^b ['BY' expr^r]}
		<def-decl(type-expr,expr,expr^b, [noexpr()| expr^r])>;

% def-decl ::= {'RECURSIVE' type-expr [auto-extend]^a '=' expr 'MEASURE' expr^b ['BY' expr^r]}
% 		<def-decl(type-expr, [noext()|auto-extend]^a,
%                  expr, expr^b, [noexpr()| expr^r])>;

macro-decl ::= {'MACRO' type-expr '=' expr} <macro-decl(type-expr,expr)>;

% macro-decl ::= {'MACRO' type-expr [auto-extend] '=' expr}
%                 <macro-decl(type-expr, [noext()|auto-extend], expr)>;

ind-decl ::= {'INDUCTIVE' type-expr '=' expr} <ind-decl(type-expr,expr)>;

corec-decl ::= {'CORECURSIVE' type-expr '=' expr}
                  <corec-decl(type-expr,expr)>;

coind-decl ::= {'COINDUCTIVE' type-expr '=' expr} <coind-decl(type-expr,expr)>;
		
assumption ::= {'ASSUMPTION' expr} <assumption(expr)>;

formula-decl ::= {formula-name expr} <formula-decl(formula-name,expr)>;

type-expr ::= {['GHOST'] type-ex} <[type-ex|ghost(type-ex)]>;

type-ex ::= {{name [arguments] ['WITH' type-expr]^e}
              <[[type-name(name)|type-appl(name,arguments)]
               |[extended-type-name(name,type-expr)
                |extended-type-appl(name,arguments,type-expr)]]^e>
	  | {type-expr-sans-name ['WITH' type-expr]}
              <[type-expr-sans-name
               |extended-type(type-expr-sans-name,type-expr)]>}
	  ;

type-expr-sans-name ::= { '(' expr ')'} <expr-as-type(expr)>
		      | {'{' set-formals ['|' expr] '}'}
			<[enumtype(set-formals) | subtype(set-formals,expr)]>
		      | comp-type-expr
                      %% | {{'FORALL' | 'EXISTS'} lambda-formals ':' type-expr}
                      %%   <quant-type({forall()|exists()},lambda-formals,
                      %%               type-expr)>
		      ;

% Broken out so that type expressions could appear in actual parameters;
% names cause conflicts.

comp-type-expr	::= recordtype
		 |  {[fun-array]^f '[' [dep-type-exprs]^d
		     	[{'->' type-expr} <type-expr>]^r ']'}
		     <funtype(opt^f,[emptytuple()|dep-type-exprs]^d,opt^r)>
		 ;

recordtype ::= {'[#' [field-decls [{',' field-decls++','}|{'+' field-decls++'+'}]]^r '#]'}
                <[recordtype(fields(list()))|[recordtype(fields(list(field-decls)))
                 |{recordtype(fields(cons(field-decls,field-decls+)))
                  |varianttype(fields(cons(field-decls,field-decls+)))}]]^r>;

field-decls ::= {ids ':' type-expr} <field-decls(ids,type-expr)>;

fun-array ::= 'FUNCTION' <function()> | 'ARRAY' <array()>;

dep-type-exprs ::= {dep-type-expr
                    [{',' dep-type-expr++','}|{'+' dep-type-expr++'+'}]}
                   <[dom(list(dep-type-expr))
                    |{dom(cons(dep-type-expr,dep-type-expr+))
                     |cotupletype(cons(dep-type-expr,dep-type-expr+))}]>;

dep-type-expr ::= type-expr
	       |  {idop ':' type-expr} <dep-binding(idop,type-expr)>
	       ;

% auto-extend ::= {'AUTO_EXTEND' {{idop 'WITH' expr} <ext(idop, expr)>} ++ ','}
%                 <auto-extend(doubleplus)>;


%% Expressions
%% It would be nice to pull out, e.g., the infix ops, but this leads to
%% errors because the precedence can't easily be provided

expr ::= string <string-expr(string)>
       | keyword <char-expr(keyword)>
       | name-expr
       | bracket-expr
       | {'(#' {assignment ** ','} '#)'} <rec-expr(assignments(assignment*))>
       | {'`' {id | number} [actuals]} <{fieldex(id,[noactuals()|actuals])
                                        |projex(number,[noactuals()|actuals])}>
       | {expr '`' {id | number}} <{fieldappl(expr,id)|projappl(expr,number)}>
       | {expr jux fun-arguments} <application(expr,fun-arguments)>
       | {expr 'O' expr^1} <term-expr(o(),expr-args(list(expr,expr^1)))>
       | {expr '∘' expr^1} <term-expr(∘(),expr-args(list(expr,expr^1)))>
       | {expr 'IFF' expr^1} <term-expr(iff(),expr-args(list(expr,expr^1)))>
       | {expr '<=>' expr^1} <term-expr(`\<=\>(),expr-args(list(expr,expr^1)))>
       | {expr '⇔' expr^1} <term-expr(`⇔(),expr-args(list(expr,expr^1)))>
       | {expr 'IMPLIES' expr^1}
                    <term-expr(implies(),expr-args(list(expr,expr^1)))>
       | {expr '=>' expr^1} <term-expr(`=\>(),expr-args(list(expr,expr^1)))>
       | {expr '⇒' expr^1} <term-expr(`⇒(),expr-args(list(expr,expr^1)))>
       | {expr 'WHEN' expr^1} <term-expr(when(),expr-args(list(expr,expr^1)))>
       | {expr 'OR' expr^1} <term-expr(or(),expr-args(list(expr,expr^1)))>
       | {expr '∨' expr^1} <term-expr(`∨(),expr-args(list(expr,expr^1)))>
       | {expr '\\/' expr^1} <term-expr(`\\\/(),expr-args(list(expr,expr^1)))>
       | {expr 'AND' expr^1} <term-expr(and(),expr-args(list(expr,expr^1)))>
       | {expr '∧' expr^1} <term-expr(`∧(),expr-args(list(expr,expr^1)))>
       | {expr '/\\' expr^1} <term-expr(`\/\\(),expr-args(list(expr,expr^1)))>
       | {expr '&' expr^1} <term-expr(`&(),expr-args(list(expr,expr^1)))>
       | {expr 'XOR' expr^1} <term-expr(xor(),expr-args(list(expr,expr^1)))>
       | {expr 'ANDTHEN' expr^1}
                    <term-expr(andthen(),expr-args(list(expr,expr^1)))>
       | {expr 'ORELSE' expr^1}
                    <term-expr(orelse(),expr-args(list(expr,expr^1)))>
       | {expr '^' expr^1} <term-expr(`^(),expr-args(list(expr,expr^1)))>
       | {expr '+' expr^1} <term-expr(`+(),expr-args(list(expr,expr^1)))>
       | {expr '-' expr^1} <term-expr(`-(),expr-args(list(expr,expr^1)))>
       | {expr '*' expr^1} <term-expr(`*(),expr-args(list(expr,expr^1)))>
       | {expr '/' expr^1} <term-expr(`\/(),expr-args(list(expr,expr^1)))>
       | {expr '++' expr^1} <term-expr(`++(),expr-args(list(expr,expr^1)))>
       | {expr '~' expr^1} <term-expr(`~(),expr-args(list(expr,expr^1)))>
       | {expr '**' expr^1} <term-expr(`**(),expr-args(list(expr,expr^1)))>
       | {expr '//' expr^1} <term-expr(`\/\/(),expr-args(list(expr,expr^1)))>
       | {expr '^^' expr^1} <term-expr(`\^\^(),expr-args(list(expr,expr^1)))>
       | {expr '⊕' expr^1} <term-expr(`⊕(),expr-args(list(expr,expr^1)))>
       | {expr '⊘' expr^1} <term-expr(`⊘(),expr-args(list(expr,expr^1)))>
       | {expr '⊗' expr^1} <term-expr(`⊗(),expr-args(list(expr,expr^1)))>
       | {expr '⊖' expr^1} <term-expr(`⊖(),expr-args(list(expr,expr^1)))>
       | {expr '⊙' expr^1} <term-expr(`⊙(),expr-args(list(expr,expr^1)))>
       | {expr '⊛' expr^1} <term-expr(`⊛(),expr-args(list(expr,expr^1)))>
       | {expr '⨁' expr^1} <term-expr(`⨁(),expr-args(list(expr,expr^1)))>
       | {expr '⨂' expr^1} <term-expr(`⨂(),expr-args(list(expr,expr^1)))>
       | {expr '⨀' expr^1} <term-expr(`⨀(),expr-args(list(expr,expr^1)))>
       | {expr '|-' expr^1} <term-expr(`\|-(),expr-args(list(expr,expr^1)))>
       | {expr '⊢' expr^1} <term-expr(`⊢(),expr-args(list(expr,expr^1)))>
       | {expr '|=' expr^1} <term-expr(`\|=(),expr-args(list(expr,expr^1)))>
       | {expr '⊨' expr^1} <term-expr(`⊨(),expr-args(list(expr,expr^1)))>
       | {expr '<|' expr^1} <term-expr(`\<\|(),expr-args(list(expr,expr^1)))>
       | {expr '|>' expr^1} <term-expr(`\|\>(),expr-args(list(expr,expr^1)))>
       | {expr '=' expr^1} <term-expr(`=(),expr-args(list(expr,expr^1)))>
       | {expr '≠' expr^1} <term-expr(`≠(),expr-args(list(expr,expr^1)))>
       | {expr '/=' expr^1} <term-expr(`\/=(),expr-args(list(expr,expr^1)))>
       | {expr '==' expr^1} <term-expr(`==(),expr-args(list(expr,expr^1)))>
       | {expr '<' expr^1} <term-expr(`\<(),expr-args(list(expr,expr^1)))>
       | {expr '<=' expr^1} <term-expr(`\<=(),expr-args(list(expr,expr^1)))>
       | {expr '>' expr^1} <term-expr(`\>(),expr-args(list(expr,expr^1)))>
       | {expr '>=' expr^1} <term-expr(`\>=(),expr-args(list(expr,expr^1)))>
       | {expr '<<' expr^1} <term-expr(`\<\<(),expr-args(list(expr,expr^1)))>
       | {expr '>>' expr^1} <term-expr(`\>\>(),expr-args(list(expr,expr^1)))>
       | {expr '<<=' expr^1} <term-expr(`\<\<=(),expr-args(list(expr,expr^1)))>
       | {expr '>>=' expr^1} <term-expr(`\>\>=(),expr-args(list(expr,expr^1)))>
       | {expr '#' expr^1} <term-expr(`#(),expr-args(list(expr,expr^1)))>
       | {expr '@@' expr^1} <term-expr(`\@\@(),expr-args(list(expr,expr^1)))>
       | {expr '##' expr^1} <term-expr(`\#\#(),expr-args(list(expr,expr^1)))>
       | {expr '±' expr^1} <term-expr(`±(),expr-args(list(expr,expr^1)))>
       | {expr '∓' expr^1} <term-expr(`∓(),expr-args(list(expr,expr^1)))>
       | {expr '∔' expr^1} <term-expr(`∔(),expr-args(list(expr,expr^1)))>
       | {expr '×' expr^1} <term-expr(`×(),expr-args(list(expr,expr^1)))>
       | {expr '÷' expr^1} <term-expr(`÷(),expr-args(list(expr,expr^1)))>
       | {expr '⊞' expr^1} <term-expr(`⊞(),expr-args(list(expr,expr^1)))>
       | {expr '⊟' expr^1} <term-expr(`⊟(),expr-args(list(expr,expr^1)))>
       | {expr '⊠' expr^1} <term-expr(`⊠(),expr-args(list(expr,expr^1)))>
       | {expr '≁' expr^1} <term-expr(`≁(),expr-args(list(expr,expr^1)))>
       | {expr '∼' expr^1} <term-expr(`∼(),expr-args(list(expr,expr^1)))>
       | {expr '≃' expr^1} <term-expr(`≃(),expr-args(list(expr,expr^1)))>
       | {expr '≇' expr^1} <term-expr(`≇(),expr-args(list(expr,expr^1)))>
       | {expr '≈' expr^1} <term-expr(`≈(),expr-args(list(expr,expr^1)))>
       | {expr '≉' expr^1} <term-expr(`≉(),expr-args(list(expr,expr^1)))>
       | {expr '≍' expr^1} <term-expr(`≍(),expr-args(list(expr,expr^1)))>
       | {expr '≎' expr^1} <term-expr(`≎(),expr-args(list(expr,expr^1)))>
       | {expr '≏' expr^1} <term-expr(`≏(),expr-args(list(expr,expr^1)))>
       | {expr '≐' expr^1} <term-expr(`≐(),expr-args(list(expr,expr^1)))>
       | {expr '≗' expr^1} <term-expr(`≗(),expr-args(list(expr,expr^1)))>
       | {expr '≙' expr^1} <term-expr(`≙(),expr-args(list(expr,expr^1)))>
       | {expr '≡' expr^1} <term-expr(`≡(),expr-args(list(expr,expr^1)))>
       | {expr '⋈' expr^1} <term-expr(`⋈(),expr-args(list(expr,expr^1)))>
       | {expr '≤' expr^1} <term-expr(`≤(),expr-args(list(expr,expr^1)))>
       | {expr '≥' expr^1} <term-expr(`≥(),expr-args(list(expr,expr^1)))>
       | {expr '≦' expr^1} <term-expr(`≦(),expr-args(list(expr,expr^1)))>
       | {expr '≧' expr^1} <term-expr(`≧(),expr-args(list(expr,expr^1)))>
       | {expr '≨' expr^1} <term-expr(`≨(),expr-args(list(expr,expr^1)))>
       | {expr '≩' expr^1} <term-expr(`≩(),expr-args(list(expr,expr^1)))>
       | {expr '≪' expr^1} <term-expr(`≪(),expr-args(list(expr,expr^1)))>
       | {expr '≫' expr^1} <term-expr(`≫(),expr-args(list(expr,expr^1)))>
       | {expr '≮' expr^1} <term-expr(`≮(),expr-args(list(expr,expr^1)))>
       | {expr '≯' expr^1} <term-expr(`≯(),expr-args(list(expr,expr^1)))>
       | {expr '≰' expr^1} <term-expr(`≰(),expr-args(list(expr,expr^1)))>
       | {expr '≱' expr^1} <term-expr(`≱(),expr-args(list(expr,expr^1)))>
       | {expr '≺' expr^1} <term-expr(`≺(),expr-args(list(expr,expr^1)))>
       | {expr '≻' expr^1} <term-expr(`≻(),expr-args(list(expr,expr^1)))>
       | {expr '▷' expr^1} <term-expr(`▷(),expr-args(list(expr,expr^1)))>
       | {expr '◁' expr^1} <term-expr(`◁(),expr-args(list(expr,expr^1)))>
       | {expr '∈' expr^1} <term-expr(`∈(),expr-args(list(expr,expr^1)))>
       | {expr '∉' expr^1} <term-expr(`∉(),expr-args(list(expr,expr^1)))>
       | {expr '∋' expr^1} <term-expr(`∋(),expr-args(list(expr,expr^1)))>
       | {expr '∩' expr^1} <term-expr(`∩(),expr-args(list(expr,expr^1)))>
       | {expr '∪' expr^1} <term-expr(`∪(),expr-args(list(expr,expr^1)))>
       | {expr '⊂' expr^1} <term-expr(`⊂(),expr-args(list(expr,expr^1)))>
       | {expr '⊃' expr^1} <term-expr(`⊃(),expr-args(list(expr,expr^1)))>
       | {expr '⊄' expr^1} <term-expr(`⊄(),expr-args(list(expr,expr^1)))>
       | {expr '⊅' expr^1} <term-expr(`⊅(),expr-args(list(expr,expr^1)))>
       | {expr '⊆' expr^1} <term-expr(`⊆(),expr-args(list(expr,expr^1)))>
       | {expr '⊇' expr^1} <term-expr(`⊇(),expr-args(list(expr,expr^1)))>
       | {expr '⊊' expr^1} <term-expr(`⊊(),expr-args(list(expr,expr^1)))>
       | {expr '⊋' expr^1} <term-expr(`⊋(),expr-args(list(expr,expr^1)))>
       | {expr '⊎' expr^1} <term-expr(`⊎(),expr-args(list(expr,expr^1)))>
       | {expr '⊏' expr^1} <term-expr(`⊏(),expr-args(list(expr,expr^1)))>
       | {expr '⊐' expr^1} <term-expr(`⊐(),expr-args(list(expr,expr^1)))>
       | {expr '⊑' expr^1} <term-expr(`⊑(),expr-args(list(expr,expr^1)))>
       | {expr '⊒' expr^1} <term-expr(`⊒(),expr-args(list(expr,expr^1)))>
       | {expr '⊓' expr^1} <term-expr(`⊓(),expr-args(list(expr,expr^1)))>
       | {expr '⊔' expr^1} <term-expr(`⊔(),expr-args(list(expr,expr^1)))>
       | {expr '⋀' expr^1} <term-expr(`⋀(),expr-args(list(expr,expr^1)))>
       | {expr '⋁' expr^1} <term-expr(`⋁(),expr-args(list(expr,expr^1)))>
       | {expr '⋂' expr^1} <term-expr(`⋂(),expr-args(list(expr,expr^1)))>
       | {expr '⋃' expr^1} <term-expr(`⋃(),expr-args(list(expr,expr^1)))>
       | {expr '•' expr^1} <term-expr(`•(),expr-args(list(expr,expr^1)))>
       | {expr '←' expr^1} <term-expr(`←(),expr-args(list(expr,expr^1)))>
       | {expr '↑' expr^1} <term-expr(`↑(),expr-args(list(expr,expr^1)))>
       | {expr '→' expr^1} <term-expr(`→(),expr-args(list(expr,expr^1)))>
       | {expr '↓' expr^1} <term-expr(`↓(),expr-args(list(expr,expr^1)))>
       | {expr '↝' expr^1} <term-expr(`↝(),expr-args(list(expr,expr^1)))>
       | {expr '↦' expr^1} <term-expr(`↦(),expr-args(list(expr,expr^1)))>
       | {expr '⇐' expr^1} <term-expr(`⇐(),expr-args(list(expr,expr^1)))>
       | {expr '⇑' expr^1} <term-expr(`⇑(),expr-args(list(expr,expr^1)))>
       | {expr '⇓' expr^1} <term-expr(`⇓(),expr-args(list(expr,expr^1)))>
       | {expr '∇' expr^1} <term-expr(`∇(),expr-args(list(expr,expr^1)))>
       | {expr '⊣' expr^1} <term-expr(`⊣(),expr-args(list(expr,expr^1)))>
       | {expr '⊥' expr^1} <term-expr(`⊥(),expr-args(list(expr,expr^1)))>
       | {expr '⊩' expr^1} <term-expr(`⊩(),expr-args(list(expr,expr^1)))>
       | {expr '◯' expr^1} <term-expr(`◯(),expr-args(list(expr,expr^1)))>
       | {expr '★' expr^1} <term-expr(`★(),expr-args(list(expr,expr^1)))>
       | {expr '✠' expr^1} <term-expr(`✠(),expr-args(list(expr,expr^1)))>
       | {expr '√' expr^1} <term-expr(`√(),expr-args(list(expr,expr^1)))>
       | {'NOT' expr} <unary-term-expr(not(),expr)>
       | {'~' expr} <unary-term-expr(`~(),expr)>
       | {'¬' expr} <unary-term-expr(`¬(),expr)>
%       | {'[]' expr} <unary-term-expr(`\[\](),expr)>
       | {'□' expr} <unary-term-expr(`□(),expr)>
       | {'◇' expr} <unary-term-expr(`◇(),expr)>
       | {'<>' expr} <unary-term-expr(`\<\>(),expr)>
       | {'+' expr} <unary-term-expr(`+(),expr)>
       | {'-' expr} <unary-term-expr(`-(),expr)>
       | {'√' expr} <unary-term-expr(`√(),expr)>
       | {'◯' expr} <unary-term-expr(`◯(),expr)>
       | {expr '::' type-expr} <coercion(expr,type-coercion(type-expr))>
       | {'IF' expr^c ['THEN' expr^t
          {{'ELSIF' expr^ic 'THEN' expr^it} <elsif(expr^ic,expr^it)>}*
          'ELSE' expr^e 'ENDIF']}
          <[ifappl(expr^c)|if-expr(expr^c,expr^t,elsifs(star),expr^e)]>
       | {{lambda-op | forall-op | exists-op} lambda-body}
	  <bind-expr(alt,lambda-body)>
       | {id '!' {number | lambda-body}^1}
	  <{skovar(id,number)| name-bind-expr(id,lambda-body)}^1>
       | set-expr
       | {'LET' {bind++','} 'IN' expr}
           <let-expr(let-bindings(doubleplus),expr)>
       | {expr 'WHERE' {bind++','}}
	  <where-expr(let-bindings(doubleplus),expr)>
       | {expr 'WITH' '[' {assignment ++ ','} ']'}
	  <update-expr(expr,assignments(assignment+))>
       | {'CASES' expr 'OF' {selection ++ ','}
		[{'ELSE' expr^e} <expr^e>] 'ENDCASES'}
	  <cases-expr(expr,args(selection+),opt)>
       | {'COND' {cond-case ++ ','}
		[{',' 'ELSE' '->' expr^e}] 'ENDCOND'}
	  <cond-expr(args(cond-case+),[noelse()|expr^e])>
       | table-expr
       ;

% '%VBAR' becomes '|' when in judgement-decls - see pvs-parse-fixes.lisp
name-expr ::= {name [':' type-expr]^t ['%VBAR' expr]^e}
               <name-expr(name, [notype()|type-expr]^t, [nopred()|expr]^e)>;

bracket-expr ::= tuple-expr
               | {'(:' {expr ** ','} ':)'} <list-expr(expr*)>
               | {'[:' {expr ** ','} ':]'} <array-expr(expr*)>
               | {'[|' {expr ** ','} '|]'} <bracket-expr(\[\|\|\](), btup(expr*))>
               | {'(|' {expr ** ','} '|)'} <bracket-expr(\(\|\|\)(), btup(expr*))>
               | {'{|' {expr ** ','} '|}'} <bracket-expr(\{\|\|\}(), btup(expr*))>
               | {'〈' {expr ** ','} '〉'} <bracket-expr(〈〉(), btup(expr*))>
 	       | {'⟦' {expr ** ','} '⟧'} <bracket-expr(⟦⟧(), btup(expr*))>
	       | {'«' {expr ** ','} '»'} <bracket-expr(«»(), btup(expr*))>
	       | {'⟪' {expr ** ','} '⟫'} <bracket-expr(⟪⟫(), btup(expr*))>
	       | {'⌈' {expr ** ','} '⌉'} <bracket-expr(⌈⌉(), btup(expr*))>
	       | {'⌊' {expr ** ','} '⌋'} <bracket-expr(⌊⌋(), btup(expr*))>
	       | {'⌜' {expr ** ','} '⌝'} <bracket-expr(⌜⌝(), btup(expr*))>
	       | {'⌞' {expr ** ','} '⌟'} <bracket-expr(⌞⌟(), btup(expr*))>
               % Following not easily done in Ergo
	       % | {'∣' {expr ** ','} '∣'} <abs-brace-expr(expr*)>
	       % | {'∥' {expr ** ','} '∥'} <par-brace-expr(expr*)>
	       ;

tuple-expr ::= {'(' {expr ** ','} ')'} <tuple-expr(expr*)>;

set-expr ::= {'{' set-formals ['->' type-expr] '|' expr '}'}
                  <set-expr(set-formals,[no-type-expr()|type-expr],expr)>
           | {'{:' expr**',' ':}'} <set-list-expr(expr*)>;

cond-case ::= {expr^l '->' expr^r} <cond-case(expr^l,expr^r)>;

lambda-op ::= 'LAMBDA' <lambda()> | 'λ' <λ()>;

forall-op ::= 'FORALL' <forall()> | '∀' <∀()>;

exists-op ::= 'EXISTS' <exists()> | '∃' <∃()>;

lambda-body ::= {lambda-formals ['->' type-expr] ':' expr}
		   <lambda-body(lambda-formals,[no-type-expr()|type-expr],expr)>;

% What we would really like to say here is
%   lambda-formals ::= adformal++',' | pdformals+
% but this leads to problems: first, the adformals have optional ':'s,
% that can lead to ambiguities, second, the optional parens around the
% adformals clash with those around the pdformals.  Thus we make our own
% formals below.  Note that lambda-formals may be separated by a comma or
% not; an extra check is needed in parse.lisp to ensure it is being used
% correctly.

lambda-formals ::= {lambda-formal [[',']^c lambda-formals]}
			<[lambda-formal|
			  lambda-formals(lambda-formal,
					 [nocomma()|comma()]^c,
					 lambda-formals)]>;

lambda-formal ::= idop-not-number | pdformals ;

set-formals ::= {set-formal [[',']^c set-formals]}
		<[set-formal|
		  set-formals(set-formal,[nocomma()|comma()]^c,set-formals)]>;

set-formal ::= {{idop [':' type-expr]} | pdformals}
	       <{set-id(idop,[notype()|type-expr])|pdformals}>;

selection ::= {pidop [{'(' typed-ids ')'} <typed-ids>] ':' expr}
	      <selection(pidop,opt,expr)>;

% assignment	::= {expr {':='|'|->'} !+ @> expr^1 @^ !- }
%			<assignment(expr,expr^1,{ceq()|arr()})>;

assignment ::= {assign-arg+ {':='|'|->'} expr}
			<assignment(args(plus),expr,{ceq()|arr()})>;

assign-arg ::= {'(' expr++',' ')'} <assign-tuple(expr+)>
             | {'`' {id | number}} <{id-assign(id)|proj-assign(number)}>
	     | {id ['!' number]} <[assign-id(id)|assign-skoname(id,number)]>
             | number <assign-num(number)>
	     ;

table-expr ::= {'TABLE' [expr^1]^r [',' expr^2]^c [col-heading]^h
                 table-entries 'ENDTABLE'}
			<table-expr([norowvar()|expr^1]^r,
                                    [nocolvar()|expr^2]^c,
				    [nocolheading()|col-heading]^h,
				    table-entries)>;

col-heading ::= {'|[' expr^1 {'|' {expr | 'ELSE'}}+ ']|'}
		<col-heading(expr^1,colrest({expr|else()}+))>;

table-entries ::= {table-entry+} <table-entries(table-entry+)>;

table-entry ::= {{'|' [{expr | 'ELSE'}]}+ '||'}
			<table-entry([notableentry()|{expr|else()}]+)>;

bind ::= {{simplebind | {'(' simplebind++',' ')'}} '=' expr}
	 <bind({simplebind|binds(doubleplus)},expr)>;

simplebind ::= {idop pdformals* [':' type-expr]}
	       <simplebind(idop,pdf(star),[notype()|type-expr])>;

modnames ::= {modname ++ ','} <modnames(modname+)>;

modname ::= {[{id^1 '@'}]^p id [actuals] [mappings]^m [':->' modname]^t}
	    <modname(id,[nolib()|id^1]^p,[noactuals()|actuals],
                        [nomap()|mappings]^m, [notgt()|modname]^t)>;

theory-decl-modname ::= {[{id^1 '@'}]^p id [actuals]
	    [theory-decl-mappings]^m [':->' theory-decl-modname]^t}
	    <modname(id,[nolib()|id^1]^p,[noactuals()|actuals],
                        [nomap()|theory-decl-mappings]^m,
                        [notgt()|theory-decl-modname]^t)>;

names ::= {name ++ ','}	<names(name+)>;

fun-arguments ::= {'(' {expr ** ','} ')'} <fun-arguments(expr*)>;

arguments ::= {'(' {expr ++ ','} ')'} <arguments(expr+)>;

pidops ::= {pidop ++ ','} <pidops(pidop+)>;

pidop ::= {idop ++ '.'} <pidop(idop+)>;

idops ::= {idop ++ ','} <idops(idop+)>;

idop ::=  id  <idop(id)> | opsym <idop(opsym)> | number <idop(number)> ;

idop-not-number ::= id  <idop(id)> | opsym <idop(opsym)> ;

ids ::= {id ++ ','} <ids(id+)>;

typed-id ::= {idop [':' type-expr]^t ['|' expr]^e} 
	     <typed-id(idop,[no-type-expr()|type-expr]^t,[no-pred()|expr]^e)>;

typed-ids ::= {idops [':' type-expr]^t ['|' expr]^e}
	      <{typed-ids(idops,[no-type-expr()|type-expr]^t,
				[no-pred()|expr]^e)>;

%% name ::= {[{id '@'}]^L idop [actuals] [mappings]^m [':->' modname]^t ['.' pidop]^i}
%% 	 <name(idop,[nolib()|id]^L,[noactuals()|actuals],[nomod()|pidop]^i,
%% 	       [nomap()|mappings]^m, [notgt()|modname]^t)>;

name ::= {[{id '@'}]^L idop [actuals] [mappings]^m [':->' modname]^t
          ['.' pidop [actuals]^d]^i}
	 <name(idop,[nolib()|id]^L,[noactuals()|actuals],
               [nomod()|[pidop|pidacts(pidop, actuals)]^d]^i,
	       [nomap()|mappings]^m, [notgt()|modname]^t)>;

unique-name ::= {name [':' {'TYPE'|type-expr|formula-name}]}
		<unique-name
                  (name,[noqual()|{type()|typed(type-expr)|formula(formula-name)}])>;

bname ::= {name ['!' number]} <[name|bname(name,number)]>;

opsym ::= '+' <`+()> | '-' <`-()> | '*' <`*()> | '/' <`\/()>
	| '=' <`=()> | '≠' <`≠()> | '/=' <`\/=()> | '==' <`==()> | '<' <`\<()>
	| '<=' <`\<=()> | '>' <`\>()> | '>=' <`\>=()>
	| 'IFF' <iff()> | 'IMPLIES' <implies()> | 'WHEN' <when()>
	| 'OR' <or()> | 'AND' <and()> | 'NOT' <not()> | '¬' <¬()> | '&' <`&()>
	| '⇒' <⇒()> | '∧' <∧()> | '∨' <∨()>
	| '/\\' <`\/\\()> | '\\/' <`\\\/()> | '^' <`^()>
	% | '[]' <`\[\]()>
        | '□' <□()> | '◇' <◇()> | '<>' <`\<\>()> | '~' <`~()>
	| '=>' <`=\>()> | '<=>' <`\<=\>()> | 'IF' <if()>
	| 'TRUE' <true()> | 'FALSE' <false()> | 'O' <o()>
	| 'XOR' <xor()> | 'ORELSE' <orelse()> | 'ANDTHEN' <andthen()>
	| '++' <`++()> | '**' <`**()> | '//' <`\/\/()>
	| '^^' <`\^\^()> | '<<' <`\<\<()> | '>>' <`\>\>()>
        | '<<=' <`\<\<=()> | '>>=' <`\>\>=()>
	| '#' <`#()> 
	| '@@' <`\@\@()> | '##' <`\#\#()> 
	| '|-' <`\|-()> | '|=' <`\|=()> | '<|' <`\<\|()>
	| '|>' <`\|\>()> | '[||]' <`\[\|\|\]()> | '(||)' <`\(\|\|\)()>
        | '{||}' <`\{\|\|\}()>
	| '∘' <`∘()> | '⊕' <`⊕()> | '⊖' <`⊖()> | '⊗' <`⊗()> | '⊘' <`⊘()>
	| '⊙' <`⊙()> | '⨁' <`⨁()> | '⨂' <`⨂()> | '⨀' <`⨀()>
 	| '⊢' <`⊢()> | '⊨' <`⊨()> | '±' <`±()> | '∓' <`∓()> | '∔' <`∔()>
	| '×' <`×()> | '÷' <`÷()> | '⊞' <`⊞()> | '⊟' <`⊟()> | '⊠' <`⊠()>
	| '≁' <`≁()> | '≃' <`≃()> | '≅' <`≅()> | '≇' <`≇()> | '≈' <`≈()>
        | '∼' <`∼()>
	| '≉' <`≉()> | '≍' <`≍()> | '≎' <`≎()> | '≏' <`≏()> | '≐' <`≐()>
	| '≗' <`≗()> | '≙' <`≙()> | '≡' <`≡()> | '⋈' <`⋈()> | '≤' <`≤()>
	| '≥' <`≥()> | '≦' <`≦()> | '≧' <`≧()> | '≨' <≨()> | '≩' <≩()>
	| '≪' <≪()> | '≫' <≫()> | '≮' <≮()>| '≯' <≯()> | '≰' <≰()> | '≱' <≱()>
	| '≺' <≺()> | '≻' <≻()> | '◁' <◁()> | '▷' <▷()> | '∈' <∈()>
	| '∉' <∉()> | '∋' <∋()> | '∩' <∩()> | '∪' <∪()> | '⊂' <⊂()>
	| '⊃' <⊃()> | '⊄' <⊄()> | '⊅' <⊅()> | '⊆' <⊆()> | '⊇' <⊇()> | '⊊' <⊊()> | '⊋' <⊋()>
	| '⊎' <⊎()> | '⊏' <⊏()> | '⊐' <⊐()> | '⊑' <⊑()> | '⊒' <⊒()> | '⊓' <⊓()> | '⊔' <⊔()>
	| '⋀' <⋀()> | '⋁' <⋁()> | '⋂' <⋂()> | '⋃' <⋃()> | '•' <•()>
	| '←' <←()> | '↑' <↑()> | '→' <→()> | '↓' <↓()> | '↝' <↝()>
	| '↦' <↦()> | '⇐' <⇐()> | '⇑' <⇑()> | '⇓' <⇓()>
	| '⇔' <⇔()> | '∇' <∇()> | '⊣' <⊣()> | '⊥' <⊥()> | '⊩' <⊩()>
	| '◯' <◯()> | '★' <★()> | '✠' <✠()> 
	| '«»' <«»()> | '〈〉' <〈〉()> | '⟦⟧' <⟦⟧()> | '⟪⟫' <⟪⟫()>
	| '⌈⌉' <⌈⌉()> | '⌊⌋' <⌊⌋()> | '⌜⌝' <⌜⌝()> | '⌞⌟' <⌞⌟()>
	;

semic ::= ';' <`;()> | '§' <`§()>;

actuals ::= {actuals1^1 [actuals1]^2} <[actuals1^1|actuals2(actuals1^1, actuals1)]^2>;

actuals1 ::= {'[' {actual ** ','} ']'} <actuals(actual*)>;

% mappings are not really allowed, but we want to give a reasonable error
% see xt-actual in parse.lisp
actual ::= expr | comp-type-expr | mappings;

mappings ::= {'{{' mapping++ ',' '}}'} <mappings(mapping+)>;

mapping ::= {mapping-lhs ':=' mapping-rhs}
              <{mapping-subst(mapping-lhs,mapping-rhs)}>;

theory-decl-mappings ::= {'{{' theory-decl-mapping++ ',' '}}'}
                           <mappings(theory-decl-mapping+)>;

theory-decl-mapping ::= {mapping-lhs {':='|'::='} mapping-rhs}
              <{mapping-subst(mapping-lhs,mapping-rhs)
               |mapping-rename(mapping-lhs,mapping-rhs)}>;

mapping-lhs ::= {pidop [theory-formals]^f [pdformals+]^a
		 [':' {'TYPE'|'THEORY'|type-expr}]^q}
                  <mapping-lhs(pidop,
			       [no-theory-formals()|theory-formals]^f,
			       [noformals()|pdf(plus)]^a,
                               [noqual()|{type()|theory()
                                |typed(type-expr)}]^q)>;

mapping-rhs ::= expr | comp-type-expr;

formula-name	::= 'AXIOM' <`AXIOM()> | 'CHALLENGE' <`CHALLENGE()>
		|   'CLAIM' <`CLAIM()> | 'CONJECTURE' <`CONJECTURE()>
		|   'COROLLARY' <`COROLLARY()> | 'FACT' <`FACT()>
		|   'FORMULA' <`FORMULA()> | 'LAW' <`LAW()>
                |   'LEMMA' <`LEMMA()> | 'OBLIGATION' <`OBLIGATION()>
		|   'POSTULATE' <`POSTULATE()>
		|   'PROPOSITION' <`PROPOSITION()> | 'SUBLEMMA' <`SUBLEMMA()>
		|   'THEOREM' <`THEOREM()>
		;
