% PVSio support theories

%% stdlang.pvs
%% In PVS-8.0, stdlang theory was integrated into stdpvs

%% stdpvs
%% Basic language definitions

stdpvs : THEORY
BEGIN

  void : TYPE = bool

  skip : void = TRUE
  fail : void = FALSE

  try(s1:void,s2:void)  : MACRO void = s1 OR s2
  try(s:void)           : MACRO void = try(s,skip)
  ifthen(b:bool,s:void) : MACRO void = IF b THEN s ELSE skip ENDIF
  ifelse(b:bool,s:void) : MACRO void = IF b THEN skip ELSE s ENDIF
  do_when(b:bool,s:void)    : MACRO void = ifthen(b,s)
  do_unless(b:bool,s:void)  : MACRO void = ifelse(b,s)

  Dummy : TYPE  = bool
  dummy : MACRO Dummy = FALSE
  dummy_fun[T:TYPE](t:T): Dummy = dummy

  prog[T:TYPE](s:void,t:T): T = t

  %% Format test (uses Common Lisp's format convention)
  format_lisp[T:TYPE](s:string,t:T):string

  format[T:TYPE](s:string,t:T): MACRO string =
    format_lisp[T](s,t)

  format(s:string) : MACRO string =
    format[Dummy](s,dummy)

  %% Throw a PVSio error with a message provided by the user.
  %% PVSio errors, in contrast to PVSio exceptions, cannot be
  %% programatically caught
  error_lisp[T:TYPE+](mssg:string):T

  error[T:TYPE+](mssg:string): MACRO T =
    error_lisp(mssg)

  %% Exit the current evaluation and return to PVSio
  exit[T:TYPE+] : T

  %% last_iteration breaks a loop with a given value
  last_iteration[T:TYPE](t:T):T

  return[T:TYPE](t:T):T 

  %% Loops
  loop_lift[T:TYPE+](f:[Dummy->void]): T

  loop[T:TYPE+](s:void): MACRO T = loop_lift(LAMBDA(d:Dummy):s)

  %% While loops
  break : MACRO void = last_iteration(skip)

  while(b:bool,s:void) : MACRO void =
    loop(if b then s else break endif)

  for(si:void,b:bool,sinc,s:void): MACRO void =
    si & while(b,s & sinc)

  %% Used for untyped lisp attachments
  Lisp_ : TYPE+  

  %% Used when lisp attachments need the type
  Lisp[T:TYPE+] : TYPE+

  %% To PVS-typed lisp
  to_lisp[T:TYPE+](t:T) : Lisp[T]

  %% To untyped lisp
  to_lisp_[T:TYPE](t:T) : Lisp_

  %% {| e |} makes a lisp representation of the PVS expression e suitable as
  %% input to format's directives.
  %% {| a1,..,an |} becomes a1 ... an parameters to format
  %% {| (: a1,..,an :) |} becomes a list to format's iterative directive ~{...~}
  %% If e is a boolean, a string, a Mutable, or a Maybe, {| e |} becomes NIL if
  %% e is, respectively, FALSE, the empty string, undef, or None. Otherwise,
  %% it returns its value. So, this makes {| e |} suitable as input to the
  %% fomat's conditional directive ~@[...~]

  {||}[T:TYPE+](t:T) : Lisp[T] = to_lisp(t)

  unwind_protect_lift[T:TYPE+](ft:[Dummy->T],fcu:[Dummy->void]) : T

  %% Evaluate t, returning its value. The cleanup code will be evaluated if
  %% control leaves t.
  unwind_protect[T:TYPE](t:T,cleanup:void) : MACRO T =
    unwind_protect_lift(LAMBDA(d:Dummy):t,LAMBDA(d:Dummy):cleanup)

  type_of_domain_lisp[T:TYPE](f:[T->void]): string

  %% Return string representing the type of t (t may be an uninterpreted
  %% constant)
  typeof[T:TYPE](t:T) : MACRO string =
    type_of_domain_lisp[T](dummy_fun)

  %% Functionally PVSioValue[T] is the same as T. Computationally, in the
  %% following constant declaration, <expr> is evaluated only once and assigned
  %% to <name> at compilation time
  %%   <name> : PVSioValue[T] = <expr>
  PVSioValue[T:TYPE] : TYPE = T

END stdpvs

%% stdprog.pvs
%% Imperative aspects such as mutables and global variables

stdprog[T:TYPE+] : THEORY
BEGIN

  %% Mutable data
  Mutable : TYPE+

  %% Create a mutable variable and sets it to given value
  ref(t:T): Mutable

  %% Create a new mutable variable with an undefined value
  new: Mutable

  %% Set mutable variable to undefined
  reset(v:Mutable): void

  %% Return TRUE if mutable variable is undefined"
  undef(v:Mutable): bool

  undefined?(v:Mutable): MACRO bool =
    undef(v)

  defined?(v:Mutable): MACRO bool =
    NOT undef(v)

  val_lisp(v:Mutable): T

  %% Return value of mutable variable.
  %% Throw exception UndefinedMutableVariable when undefined?(v)"
  val(v:Mutable): T = val_lisp(v)

  %% Set mutable variable gvar to given value
  def(v:Mutable,t:T) : T = t

  set(v:Mutable,t:T) : void =
    LET nt = def(v,t) IN
    skip

%% Mutable variables can be used as stacks, where val is the top of the stack.
%% Stack is empty when undef is true

  push_lisp(v:(defined?),t:T) : void

  %% Push value to the top of the mutable variable and skips
  push_val(v:Mutable,t:T) : MACRO void =
    IF undef(v) THEN set(v,t)
    ELSE push_lisp(v,t)
    ENDIF

  pop_lisp(v:(defined?)) : void

  %% Pop value of the mutable variable and fails silently when mutable variable
  %% is undefined
  pop_val(v:Mutable) : MACRO void =
    IF undef(v) THEN fail
    ELSE pop_lisp(v)
    ENDIF

  %% Top value with a default value if Mutable is undef
  top_val(v:Mutable,default:T) : T =
    IF undef(v) THEN default
    ELSE val(v)
    ENDIF

  CONVERSION val

  %% Global mutable variables
  Global : TYPE+ = PVSioValue[Mutable]

  %% Return name of Global variable. Issue an error if parameter is not
  %% a global variable.
  name_of(g:Global): string

  %% Return TRUE iff mutable is a Global variable
  global?(m:Mutable): bool

END stdprog

%% stdglobal.pvs
%% Global variables

stdglobal[T:TYPE,t:T] : THEORY
BEGIN

  Global : TYPE+ = PVSioValue[Mutable[T]]

END stdglobal

%% stdmutable.pvs
%% Utility for mutable variables

stdmutable[T,P:TYPE+] : THEORY
BEGIN

  save_lift(fp:[Dummy->P],gv:Mutable[T],val:T):P =
    unwind_protect(fp(dummy),set(gv,val))

  %% Save mutable variable gv of type T and restore its value after p of type
  %% P is evaluated, even if control leaves p, e.g., due to an exception
  with_mutable(gv:Mutable[T],p:P) : MACRO P =
    IF undef(gv) THEN
      unwind_protect(p,reset(gv))
    ELSE
      save_lift(LAMBDA(dummy:Dummy):p,gv,val(gv))
    ENDIF

  %% Set mutable variable gv to t and restore its value after p of type P is
  %% evaluated, even if control leaves p, e.g., due to an exception
  with_mutable(gv:Mutable[T],t:T,p:P) : MACRO P =
   with_mutable(gv,prog(set(gv,t),p))

END stdmutable

%% stdexc.pvs
%% Definition of exception type
%% For usage see:
%% https://github.com/SRI-CSL/PVS/tree/master/src/PVSio#exceptions

stdexc[ExceptionType:TYPE] : THEORY
BEGIN

  Formatter : DATATYPE
  BEGIN
    NoFmter : nofmter?
    Fmter(fmter:[ExceptionType->string]) : fmter?
  END Formatter

  Exception_ : TYPE = [#
    root_      : list[string],
    formatter_ : Formatter
  #]

  mk_corexc_ : Exception_ = (#
    root_ := null,
    formatter_ := NoFmter
  #)

  CoreException : TYPE = Global[Exception_,mk_corexc_]

  PVSioException : CoreException

  mk_exc_ : Exception_ = (#
    root_ := (: name_of(PVSioException) :),
    formatter_ := NoFmter
  #)

  Exception : TYPE = Global[Exception_,mk_exc_]

  qid(exc:Exception) : list[string] =
    IF global?(exc) AND defined?(exc) THEN
      append(root_(val(exc)),(: name_of(exc) :))
    ELSE error("Only exceptions declared as constants can be thrown or caught")
    ENDIF

  say(exc:Exception)(t:ExceptionType) : MACRO string =
    IF nofmter?(val(exc)`formatter_) THEN
      format("~@[~a~]",t)
    ELSE
      fmter(val(exc)`formatter_)(t)
    ENDIF

  make_exception(exc:Exception) : Exception =
    ref[Exception_]((#
      root_ := qid(exc),
      formatter_ := formatter_(val(exc))
    #))

  make_exception(exc:Exception,fmter:[ExceptionType->string]) : Exception =
    ref[Exception_]((#
      root_ := qid(exc),
      formatter_ := Fmter(fmter)
    #))

  str2fmter(mssg:string)(t:ExceptionType):string =
    mssg

  make_exception(exc:Exception,mssg:string) : Exception =
    make_exception(exc,str2fmter(mssg))

  mk_exc_fmter(fmter:[ExceptionType->string]) : MACRO Exception =
    make_exception(PVSioException,fmter)

  mk_exc_str(mssg:string) : MACRO Exception =
    mk_exc_fmter(str2fmter(mssg))

  CONVERSION mk_exc_str

  make_exception(fmter:[ExceptionType->string]) : Exception =
    mk_exc_fmter(fmter)

  make_exception(mssg:string) : Exception =
    mk_exc_str(mssg)

  %% The following definition forces the type ExceptionType to be
  %% relevant for the list of strings. This is used to guarantee
  %% type correctness of the throw/catch mechanism.
  ExceptionTag : DATATYPE
  BEGIN
    NewExceptionTag(qid:list[string]) : ExceptionTag?
  END ExceptionTag

  tag(exc:Exception) : ExceptionTag =
    NewExceptionTag(qid(exc))

END stdexc

stdexceptions : THEORY
BEGIN

  %% A Simple exeption is an exception that doesn't return a value

  SimpleExceptionType : TYPE = Lisp[void]

  SimpleExceptionVal : SimpleExceptionType = {| fail |}

  SimpleException : TYPE = Exception[SimpleExceptionType]

  PVSioSimpleException : SimpleException =
    PVSioException[SimpleExceptionType]

  %% Exceptions are hierarchical and they can be caught through the hierarchy

  %% Conversion Exceptions
  String2PVS: Exception[string]

  NotABoolean: Exception[string] = make_exception(String2PVS,
     LAMBDA(str:string):format("String ~s doesn't represent a PVS Boolean",str))

  NotANumber : Exception[string] = make_exception(String2PVS,
     LAMBDA(str:string):format("String ~s doesn't represent a PVS number",str))

  NotARealNumber: Exception[string] = make_exception(NotANumber,
     LAMBDA(str:string):format("String ~s doesn't represent a PVS real number",str))

  NotAnInteger: Exception[string] = make_exception(NotANumber,
     LAMBDA(str:string):format("String ~s doesn't represent a PVS integer",str))

  PVS2String: Exception[string] = make_exception(LAMBDA(str:string):
    format("PVS Object ~a doesn't have literal representation",str))

  %% I/O Exceptions
  IOException: Exception[string]

  ReadPVS : Exception[string] = make_exception(IOException)

  FileNotFound: Exception[string] = make_exception(IOException,
     LAMBDA(str:string):format("File not found (~a)",str))

  FileAlreadyExists: Exception[string] = make_exception(IOException,
     LAMBDA(str:string):format("File already exists (~a)",str))
     
  ClosedStream: Exception[string] = make_exception(IOException,
     LAMBDA(str:string):format("File is closed~@[ (~a)~]", {| str |}))

  EndOfFile: Exception[string] = make_exception(IOException,
     LAMBDA(str:string):format("Reached end of file~@[ (~a)~]", {| str |}))

END stdexceptions

%% stdcatch.pvs
%% Definition of catch and throw 

stdcatch[ResultType:TYPE+,ExceptionType:TYPE] : THEORY
BEGIN

  catch_lift(exctag:ExceptionTag[ExceptionType],
             result:[Dummy->ResultType],
             handler:[ExceptionType->ResultType]) : ResultType

  %% Catch with a handler
  catch(exc:Exception[ExceptionType],
        result:ResultType,
        handler:[ExceptionType->ResultType]) : MACRO ResultType =
    catch_lift(tag(exc),LAMBDA(d:Dummy):result,handler)

  %% Catch with an exceptional result (exc_result)
  catch(exc:Exception[ExceptionType],
        result,exc_result:ResultType): MACRO ResultType =
    catch(exc,result,LAMBDA(val:ExceptionType):exc_result)

  catch_list_lift(l:list[Exception[ExceptionType]],
                  f1:[Dummy->ResultType],
                  f2:[ExceptionType->ResultType]) : RECURSIVE ResultType =
    CASES l OF
      null : f1(dummy),
      cons(exc,rest) : catch_lift(tag(exc),
                             LAMBDA(d:Dummy):catch_list_lift(rest,f1,f2),
                             f2)
    ENDCASES
    MEASURE l BY <<  

  %% Catch list with a handler
  catch(l:list[Exception[ExceptionType]],
        result:ResultType,
	handler:[ExceptionType->ResultType]) : MACRO ResultType =
    catch_list_lift(l,LAMBDA(d:Dummy):result,handler)

  %% Catch list with an exceptional result (exc_result)
  catch(l:list[Exception[ExceptionType]],
        result,exc_result:ResultType) : MACRO ResultType =
    catch(l,result,LAMBDA(val:ExceptionType):exc_result)

  throw_lisp(tag:ExceptionTag[ExceptionType],
             val:ExceptionType,mssg:string): ResultType

  %% Throw exception using default formatter
  throw(exc:Exception[ExceptionType],val:ExceptionType) : MACRO ResultType =
    throw_lisp(tag(exc),val,say(exc)(val))

  %% Throw exception with specific message
  throw(exc:Exception[ExceptionType],
        val:ExceptionType,mssg:string): MACRO ResultType =
    throw_lisp(tag(exc),val,mssg)

END stdcatch

%% stdsimplexc.pvs
%% Definition of catch and throw for PVSioSimpleException

stdsimplexc[ResultType:TYPE+] : THEORY
BEGIN

  %% Catch any PVSioException using an exceptional result (exc_result)
  catch(result,exc_result:ResultType): MACRO ResultType =
    catch(PVSioSimpleException,result,exc_result)

  %% Throw a simple PVSioException with a specific message
  throw(mssg:string): MACRO ResultType =
    throw(PVSioSimpleException,SimpleExceptionVal,mssg)

  throw(exc:SimpleException,mssg:string) : MACRO ResultType =
    throw(exc,SimpleExceptionVal,mssg)

  throw(exc:SimpleException): MACRO ResultType =
    throw(exc,"")

END stdsimplexc

%% stdmath.pvs
%% PVSio math library 

stdmath : THEORY
BEGIN

  %% The following functions are available in the NASA PVS Library
  %% div and mod: ints@div_nat and ints@mod_nat
  %% sq: reals@sq
  %% sqrt: reals@sqrt
  %% sin and cos: trig@sincos_def
  %% tan: trig@trig_basic
  %% acos: trig@acos
  %% asin: trig@asin
  %% atan: trig@atan
  %% pi: trig@pi_def
  %% ln, exp, e:lnexp@ln_exp
  %% sinh, cosh, tanh: lnexp@hyperbolic

  %% Rounding Modes
  RoundingMode : TYPE = {TowardsZero,
			 TowardsInfnty,
			 TowardsNegInfnty,
			 TowardsPosInfnty}

  Truncate     : MACRO RoundingMode = TowardsZero
  AwayFromZero : MACRO RoundingMode = TowardsInfnty
  Ceiling      : MACRO RoundingMode = TowardsPosInfnty
  Floor        : MACRO RoundingMode = TowardsNegInfnty

  %% set(ROUNDING,<mode>) sets default rounding mode for computation
  %% and printing
  ROUNDING  : Global[RoundingMode] = ref(TowardsZero)

  %% set(PRECISION,<precision>) sets default precision to 10^(-val(PRECISION))
  %% for computations and printing.
  %% This global variable corresponds to *pvsio-precision* in in pp.lisp and
  %% has the initial value 6
  PRECISION : Global[nat]

  %% set(PP_RATIONALS,<bool>) sets default for pretty printing rational
  %% numbers in PVSio.
  %% This global variable corresponds to *pvsio-pp_rationals* in pp.lisp and
  %% has the initial value t
  PP_RATIONALS : Global[bool]

  RANDOM_lisp : {y:nnreal | y <= 1}
  NRANDOM_lisp(n:posnat) : {y:nat | y < n}

  RANDOM            : MACRO nnreal = RANDOM_lisp
  NRANDOM(n:posnat) : MACRO nat = NRANDOM_lisp(n)
  BRANDOM           : bool = (NRANDOM(2) = 0)

  %% Return a rational number that is close to the real number (identity when
  %% input is rational)
  rational_lisp(x:real) : {q:rat | rational?(x) IMPLIES q=x}
  rational(x:real) : MACRO rat = rational_lisp(x)

  %% Return numerator,denominator of rational number
  rat2numden_lisp(r:rat) : {nd:[int,posnat] | LET (num,den) = nd IN r = num/den}

  rat2numden(r:rat) : [int,posnat] = rat2numden_lisp(r)

  %% Return numerator of rational number
  numerator(r:rat) : int =
    rat2numden(r)`1

  %% Return denominator of rational number
  denominator(r:rat): posnat =
    rat2numden(r)`2

  %% Compute the decimal precision of a rational number. Return 2 values.
  %% The first one is the number of non-repeating digits. If maxperiod is
  %% negative, the second value is the period of the repeating digits.
  %% Computing the period is expensive for rationals with large denominators.
  %% Therefore, if maxperiod is non-negative, the second value is the minimum
  %% between the period and maxperiod+1. In either case, if the second value
  %% is 0, the rational has a finite decimal representation.
  decimal_precision(r:rat,maxperiod:int) : [nat,nat] 

END stdmath


%% stdstr.pvs
%% String operations

stdstr: THEORY
BEGIN

  StringChar : TYPE = {str:string | length(str) = 1}

  %% StringChar from code n
  charcode(n:nat) : StringChar

  %% Print standard table of characters
  chartable   : void

  emptystr    : string = ""
  space       : StringChar = " "
  newline     : StringChar
  tab         : StringChar
  singlequote : StringChar = "'"
  backquote   : StringChar = "`"
  doublequote : StringChar = charcode(34)

  spaces_lisp(n:nat) : {str: string | length(str)=n}
  spaces(n:nat) : MACRO string = spaces_lisp(n)

  upcase_lisp(s:string): {str: string | length(str)=length(s)}
  upcase(s:string): MACRO string = upcase_lisp(s)

  downcase_lisp(s:string): {str: string | length(str)=length(s)}
  downcase(s:string): MACRO string = downcase_lisp(s)

  capitalize_lisp(s:string): {str: string | length(str)=length(s)}
  capitalize(s:string): MACRO string = capitalize_lisp(s)

  %% Index of leftmost occurrence of s1 in s2 or -1 if s1 doesn't occur in s2
  strfind_lisp(s1,s2:string): {i:int | i >= 0 IMPLIES
			       (i <= length(s2)-length(s1) AND
			       FORALL(k:below(length(s1))):get(s1,k) =
			       get(s2,i+k))}

  strfind(s1,s2:string): MACRO int = strfind_lisp(s1,s2)

  %% Index of rightmost occurrence of s1 in s2 or -1 if s1 doesn't occur in s2
  strfind_from_end_lisp(s1,s2:string): {i:int | i >= 0 IMPLIES
                                        (i <= length(s2)-length(s1) AND
					FORALL(k:below(length(s1))):get(s1,k) =
					get(s2,i+k))}

  strfind_from_end(s1,s2:string): MACRO int = strfind_from_end_lisp(s1,s2)

  %% If i <= j returns substring s[i..j]. Otherwise, returns substring s[j..i].
  %% When 0 <= i < j < length(s), substring(s,i,j) is the same as gen_strings.substr(s,i,j+1)
  substring_lisp(s:string,i,j:below(length(s))) :
    {str:string | length(str) = max(i,j)-min(i,j)+1 AND
		  IF i <= j THEN
		    FORALL (k:below(length(str))): get(str,k) = get(s,i+k)
		  ELSE
		    FORALL (k:below(length(str))): get(str,k) = get(s,i-k)
		  ENDIF}

  substring_lisp_j : JUDGEMENT
    substring_lisp(s:string,i,j:below(length(s))) HAS_TYPE
      {str : string | length(str) > 0}

  %% Returns empty string if i and j are out of range
  substring(s:string,i,j:int) : string =
    IF 0 <= i < length(s) AND 0 <= j < length(s) THEN
      substring_lisp(s,i,j)
    ELSE emptystr
    ENDIF

  %% Reverse string
  strreverse(s:string) : string =
    IF length(s) = 0 THEN s
    ELSE 
      substring(s,length(s)-1,0)
    ENDIF

  strreverse_j : JUDGEMENT
    strreverse(s:string) HAS_TYPE {str : string | length(str) = length(s) AND
                                   FORALL (k:below(length(str))):get(str,k) =
				   get(s,length(s)-1-k)}

  %% Return a new string in which all the occurences of part in s
  %% is replaced with replacement
  strreplace(s,part,replacement:string): string

  %% Split str using separator
  strsplit(str: string, separator: StringChar): list[string]

  %% Convert real number to string decimal representation using given precision,
  %% i.e., natural number n denoting 10^(-n), rounding mode, i.e, TowardsZero,
  %% TowardsInfnty,TowardsNegInfnty, TowardsPosInfnty. Display trailing zeros
  %% when zeros is set to TRUE
  rat2decstr_with_zeros(r:rat,precision:nat,rounding:RoundingMode,zeros:bool) :
    string

  rat2decstr(r:rat,precision:nat,rounding:RoundingMode) : string =
    rat2decstr_with_zeros(r,precision,rounding,FALSE)

  %% Convert rational number to string decimal representation, truncating at
  %% precision, and with trailing zeros when significant
  rat2decstr(r:rat,precision:nat) : string =
    LET (finp,infp) = decimal_precision(r,precision),
        prec = IF infp = 0 AND finp <= precision THEN finp ELSE precision ENDIF
    IN
      rat2decstr_with_zeros(r,prec,Truncate,TRUE)

  rat2decstr(r:rat) : string =
    rat2decstr(r,val(PRECISION))

  %% Convert rational number to string. The rational is printed in decimal
  %% representation if the representation is finite. Otherwise, it prints its
  %% rational form.
  rat2str(r:rat) : string =
    LET (finp,infp) = decimal_precision(r,0) IN
    IF infp = 0 THEN
      rat2decstr(r,finp,Truncate)
    ELSE
      format("~a",r)
    ENDIF
      
  %% Pretty-print decimal using overline to indicate repeating digits. Finp is
  %% the number of non-repeating digits. Truncated indicates that the infinite
  %% representation was truncated.
  pp_decstr(str:string,finp:nat,truncated:bool) : string 

  %% Pretty prints rational numbers upto precision using overline to indicate
  %% repeating digits and ellipsis when decimal expansion is truncated.
  pp_rat(r:rat) : string =
    LET  precision = val(PRECISION),
         (finp,infp) = decimal_precision(r,precision),
	 str = rat2decstr_with_zeros(r,min(precision,finp+infp),Truncate,TRUE)
    IN
      pp_decstr(str,finp,finp+infp > precision)

  %% Convert real number r to string using a given precision and rounding,
  %% where the precision represents the accuracy 10^-precision and rounding
  %% mode is one of TowardsZero,TowardsInfnty,TowardsNegInfnty,TowardsPosInfnty.
  real2decstr(r:real,precision:nat,rounding:RoundingMode) : string =
    LET rat  = rational(r) IN
      rat2decstr(rat,precision,rounding)

  %% Convert real number to string decimal representation using default
  %% precision and rounding mode
  real2str(r:real) :string =
    real2decstr(r,val(PRECISION),val(ROUNDING))

  %% Convert string representing a decimal number to rational number
  %% Throw exception NotARealNumber if string doesn't represent a number
  decstr2rat(s:string) : rat

  %% Bool to string
  bool2str(b:bool): string =
    IF b THEN "TRUE" ELSE "FALSE" ENDIF

  tostr(r:real): MACRO string = real2str(r)
  tostr(b:bool): MACRO string = bool2str(b)

  %% String to real. Throw exception NotARealNumber is string doesn't
  %% represent a PVS real number
  str2real(s:string): rat

  %% String to real. Throw exception NotAnInteger if string doesn't represent
  %% an integer
  str2int(s:string) : int
  
  str2bool(s,answer:string):bool = downcase(s) = downcase(answer)

  %% Convert from string to boolean. Throw exception NotABoolean if string
  %% doesn't represent a PVS boolean
  str2boolean(s:string): bool =
    IF str2bool(s,"TRUE")  THEN TRUE
    ELSIF str2bool(s,"FALSE") THEN FALSE
    ELSE throw(NotABoolean,s)
    ENDIF

  %% String is a number
  number?(s:string):bool

  %% String is an integer
  int?(s:string):bool

  %% String concatenation
  strconcat_lisp(s1:string,s2:string):
    { str:string | length(str)=length(s1)+length(s2) AND
      FORALL(k:below(length(str))) :
        IF k < length(s1) THEN get(str,k) = get(s1,k)
	ELSE get(str,k) = get(s2,k-length(s1))
	ENDIF}

  strconcat(s1:string,s2:string) : string =
    strconcat_lisp(s1,s2)

  ;+(s1:string,s2:string): MACRO string = strconcat(s1,s2)
  ;+(r:real,s:string): MACRO string = strconcat(tostr(r),s)
  ;+(s:string,r:real): MACRO string = strconcat(s,tostr(r))
  ;+(b:bool,s:string): MACRO string = strconcat(tostr(b),s)
  ;+(s:string,b:bool): MACRO string = strconcat(s,tostr(b))

  %% String comparison, with case sensitivity
  %% = 0 if s1 = s2
  %% < 0 if s1 < s2
  %% > 0 if s1 > s2
  %% NOTE: strcompare(s1,s2,TRUE) is the same as gen_strings.strcmp(s1,s2)
  strcompare_lisp(s1,s2:string,sensitive:bool):subrange(-1,1)

  strcompare(s1,s2:string,sensitive:bool): MACRO int =
    strcompare_lisp(s1,s2,sensitive)

  %% A substring of s2, with all the characters in s1 stripped of
  %% the beginning and end
  strtrim(s1,s2:string):string

  %% Return a substring of s2, with all the characters in s1 stripped of
  %% the beginning 
  strtrim_left(s1,s2:string):string

  %% Return a substring of s2, with all the characters in s1 stripped of
  %% the end
  strtrim_right(s1,s2:string):string

  %% Return a substring of s, with all the space characters stripped of
  %% the beginning and end
  trim(s:string):string

  %% Return a substring of s, with all the space characters stripped of
  %% the beginning 
  trim_left(s:string):string

  %% Return a substring of s, with all the space characters stripped of
  %% the end
  trim_right(s:string):string

  %% Concatenates n-times string s
  pad(n:nat,s:string): RECURSIVE string =
    IF n=0 THEN emptystr
    ELSE s+pad(n-1,s)
    ENDIF
    MEASURE n

  pad_j : RECURSIVE JUDGEMENT
    pad(n:nat,s:string) HAS_TYPE { str: string | length(str) = n*length(s) }

  ;^(s:string,n:nat) : MACRO string = pad(n,s)

  %% Formatting functions

  center(col:nat,s:string):string = format("~"+col+":@<~a~>",s)

  flushleft(col:nat,s:string) :string = format("~"+col+"a",s)

  flushright(col:nat,s:string):string = format("~"+col+"@a",s)

  %% Return TRUE if T1 is a subtype of T2 (types are represented using strings).
  %% Uses subtype judgements, but otherwise it's essentially syntactic
  subtypeof?(T1,T2:string) : bool

  %% Return a PVS object represented by a string
  str2pvs[T:TYPE+](s:string):T 

  pvs2str_lisp[T:TYPE](t:T) : string

  %% Return string representing a PVS object. Throw exception PVS2String
  %% if string representation doen't exist, e.g., object is not a literal.
  pvs2str[T:TYPE](t:T) : MACRO string =
    pvs2str_lisp[T](t)

END stdstr

%% stdio.pvs
%% Input/output operations

stdio : THEORY
BEGIN

%% Assert
  assert(b:bool,str:string):void =
    try(b,error[void](format("PVSio Assertion Failure: ~a",str)) & fail)

%% Print, Println 

  %% Print lisp format of string s
  printstr(s:string):void = skip

  print(s:string)   : MACRO void = printstr(s)
  print(r:real)     : MACRO void = print(r+emptystr)
  print(b:bool)     : MACRO void = print(b+emptystr)
  println(s:string) : MACRO void = print(s+newline)
  println(r:real)   : MACRO void = print(r+newline)
  println(b:bool)   : MACRO void = print(b+newline)

%% Reading

  %% Querying from stdin with prompt message
  query_token(mssg,s:string): string
  query_word(mssg:string)   : MACRO string = query_token(mssg,emptystr) 
  query_line(mssg:string)   : string

  %% Read a real number. Throw exception NotARealNumber if string doesn't
  %% represent a PVS real number
  query_real(mssg:string)   : rat

  %% Read an integer. Throw exception NotAnInteger if string doesn't represent
  %% an integer
  query_int(mssg:string)    : int

  %% Read a boolean. Throw exception NotABoolean if string doesn't represent
  %% a boolean
  query_bool(mssg,answer:string):bool = str2bool(query_word(mssg),answer)

  %% Reads from stdin
  read_token(s:string): MACRO string = query_token(emptystr,s)
  read_word : MACRO string = query_word(emptystr)
  read_line : MACRO string = query_line(emptystr)

  %% Read a real number. Throw exception NotARealNumber if string doesn't
  %% represent a PVS real number
  read_real : MACRO rat = query_real(emptystr)

  %% Read an integer. Throw exception NotAnInteger if string doesn't represent
  %% an integer
  read_int  : MACRO int = query_int(emptystr)

  %% Read a boolean. Throw exception NotABoolean if string doesn't represent a
  %% boolean
  read_bool(answer:string): MACRO bool = query_bool(emptystr,answer)

%% Character Streams
  Stream   : TYPE+ 
  IStream  : TYPE+ FROM Stream
  OStream  : TYPE+ FROM Stream

  %% Close an stream
  fclose(f:Stream) :void = skip

  %% true IFF file s exists
  fexists(s:string): bool

  %% Open stream?
  fopen?(f:Stream): bool

  %% String stream?
  strstream?(f:Stream): bool

  %% File stream?
  filestream?(f:Stream): bool

  %% Standard stream?
  sdtstream?(f:Stream): bool =
    NOT (filestream?(f) OR strstream?(f))

  %% Input stream?
  finput?(f:Stream): bool

  %% Output stream?
  foutput?(f:Stream)   :bool

  %% Rename file. Return newname
  frename(oldname,newname:string) : string

%% Standard I/O Steams
  stdin    : IStream 
  stdout   : OStream 
  stderr   : OStream

  Mode   : TYPE = {
    %% Open input file stream or throw exception FileNotFound if file doesn't
    %% exist
    input,
    %% Open output file stream or throw exception FileAlreadyExists if file
    %% does exist
    output,
    %% Create output file stream regardless of existence of the file
    create,
    %% Open output file stream and prepare for writing at end of stream
    %% (create file if it doesn't exist)
    append,
    %% Open output file stream and prepare for writing at beggining of stream
    %% (create file if it doesn't exist)
    overwrite,
    %% Open output file stream (rename old file as name.bak if file does exist)
    rename,
    %% Open string stream for input or output
    str
  }    
 
  input_mode?(m:Mode) : bool =
    (m = input OR m = str)

  output_mode?(m:Mode) : bool =
    (m = output OR m = create OR m = append OR m = overwrite OR
     m = rename OR m = str)

  mode2str(m:Mode) : string = pvs2str[Mode](m)

  tostr(m:Mode) : MACRO string = mode2str(m) 

  fopenin_lisp(s:string)        : IStream 
  fopenout_lisp(s:string,n:nat) : OStream
  
  sopenin(s:string)             : IStream
  sopenout(s:string)            : OStream

  fopenin(s:string) : IStream =
    IF length(s) = 0 THEN stdin
    ELSE 
      fopenin_lisp(s)
    ENDIF

  %% Open a file as an input stream
  fopenin(m:(input_mode?),s:string) : IStream = 
    IF m = input THEN fopenin(s)
    ELSE sopenin(s) %% m = str
    ENDIF

  %% Close file when done (no matter what)
  with_openin_file[P:TYPE+](m:(input_mode?),s:string,fp:[IStream->P]): P =
    LET fin = fopenin(m,s) IN
    unwind_protect(fp(fin),fclose(fin))

  %% Close file when done (no matter what)
  with_openin_file[P:TYPE+](s:string,fp:[IStream->P]): MACRO P =
    with_openin_file(input,s,fp)

  fopenout(s:string) : OStream =
    IF length(s) = 0 THEN stdout
    ELSE
      fopenout_lisp(s,0)
    ENDIF

  %% Open a file as an oput stream
  fopenout(m:(output_mode?),s:string): OStream =
    IF m = output THEN fopenout(s)
    ELSIF m = create THEN fopenout_lisp(s,1)
    ELSIF m = append THEN
      IF fexists(s) THEN fopenout_lisp(s,2) ELSE fopenout_lisp(s,1) ENDIF
    ELSIF m = overwrite THEN
      IF fexists(s) THEN fopenout_lisp(s,3) ELSE fopenout_lisp(s,1) ENDIF
    ELSIF m = rename THEN
      LET name = IF fexists(s) THEN frename(s,format("~a.bak",s)) ELSE s ENDIF
      IN fopenout_lisp(s,1)
    ELSE sopenout(s) % m = str
    ENDIF

  %% Close file when done (no matter what)
  with_openout_file[P:TYPE+](m:(output_mode?),s:string,fp:[OStream->P]): P =
    LET fout = fopenout(m,s) IN
    unwind_protect(fp(fout),fclose(fout))

  %% Close file when done (no matter what)
  with_openout_file[P:TYPE+](s:string,fp:[OStream->P]): MACRO P =
    with_openout_file(output,s,fp)

  fname_lisp(f:Stream)           :string
  fgetstr_lisp(f:OStream)        :string
  eof_lisp(f:IStream)            :bool           
  flength_lisp(f:Stream)         :nat          
  fgetpos_lisp(f:Stream)         :nat         
  fsetpos_lisp(f:Stream,n:nat)   :void   
  fprint_lisp(f:OStream,s:string):void = skip

  %% Get the full name of a file string
  fname(f:Stream):string =
    if filestream?(f) then 
      fname_lisp(f)
    else
      emptystr
    endif

  %% Get string from an *output string* stream. Throw exception ClosedStream
  %% when stream is not open.
  fgetstr(f:OStream):string =
    if fopen?(f) then fgetstr_lisp(f)
    else throw(ClosedStream,fname(f))
    endif

  %% true IFF f has reached EOF. Throw exception ClosedStream when stream is
  %% not open.
  eof?(f:IStream):bool =
    if fopen?(f) then eof_lisp(f)
    else throw(ClosedStream,fname(f))
    endif

  %% Length of stream. Throw exception ClosedStream when stream is not open.
  flength(f:Stream):nat =
    if fopen?(f) then flength_lisp(f)
    else throw(ClosedStream,fname(f))
    endif

  %% Get current position. Throw exception ClosedStream when stream is not open.
  fgetpos(f:Stream):nat = 
    if fopen?(f) then fgetpos_lisp(f)
    else throw(ClosedStream,fname(f))
    endif

  %% Print to a stream. Throw exception ClosedStream when stream is not open.
  fprint(f:OStream,s:string):void = 
    if fopen?(f) then fprint_lisp(f,s)
    else throw(ClosedStream,fname(f))
    endif

  fprint(f:OStream,r:real)    : MACRO void = fprint(f,r+emptystr)
  fprint(f:OStream,b:bool)    : MACRO void = fprint(f,b+emptystr)
  
  %% Set current positions. Throw exception ClosedStream when stream is not
  %% open.
  fsetpos(f:Stream,n:nat):void =
    if fopen?(f) then fsetpos_lisp(f,n)
    else throw(ClosedStream,fname(f))
    endif

  %% Println to a stream
  fprintln(f:OStream,s:string): MACRO void = fprint(f,s+newline)
  fprintln(f:OStream,r:real)  : MACRO void = fprint(f,r+newline)
  fprintln(f:OStream,b:bool)  : MACRO void = fprint(f,b+newline)

  %% Print to a stream and echoes to stdout
  echo(f:OStream,s:string): MACRO void = print(s) & fprint(f,s) 
  echo(f:OStream,r:real)  : MACRO void = print(r) & fprint(f,r) 
  echo(f:OStream,b:bool)  : MACRO void = print(b) & fprint(f,b) 

  %% Println to a stream and echo to stdout
  echoln(f:OStream,s:string): MACRO void = println(s) & fprintln(f,s)
  echoln(f:OStream,r:real)  : MACRO void = println(r) & fprintln(f,r) 
  echoln(f:OStream,b:bool)  : MACRO void = println(b) & fprintln(f,b) 

%% Input functions

  fread_token_lisp(f:IStream,s:string) : string
  fread_line_lisp(f:IStream) : string
  fread_real_lisp(f:IStream) : rat
  fread_int_lisp(f:IStream)  : int

  %% Throw an exception if stream is closed or it's EOF
  fcheck(f:IStream): bool = 
    (fopen?(f)   OR throw(ClosedStream,fname(f))) AND
    (NOT eof?(f) OR throw(EndOfFile,fname(f)))

  %% Read a token from f separated by characters in s from a stream
  fread_token(f:IStream,s:string) : string =
    prog(fcheck(f),fread_token_lisp(f,s))

  %% Read a word from f
  fread_word(f:IStream) : MACRO string =
    fread_token(f,emptystr)

  %% Read a line from f
  fread_line(f:IStream) : string =
    prog(fcheck(f),fread_line_lisp(f))

  %% Read a real number from f. Throw exception NotARealNumber if next string
  %% doesn't represent a PVS real number
  fread_real(f:IStream) : rat =
    prog(fcheck(f),fread_real_lisp(f))

  %% Read an integer from f. Throw exception NotAnInteger if next string
  %% doesn't represent an integer
  fread_int(f:IStream)  : int =
    prog(fcheck(f),fread_int_lisp(f))

  %% Read a boolean from f. Throw exception NotABoolean if next string doesn't
  %% represent a PVS boolean
  fread_bool(f:IStream,answer:string): MACRO bool=
    str2bool(fread_word(f),answer)

  %% Return the name part of a file name
  filename(s:string):string

  %% Return the directory part of a file name
  directory(s:string):string

  %% Return path name as a list of directories
  pathname_path(name:string) : list[string]

  %% Split filename given a separator
  %% If name starts or ends with separator, the separator is considered part of
  %% the name
  split_filename(name:string,separator:StringChar) : [string,string] =
    LET pos = strfind_from_end(separator,name) IN
      IF pos <= 0 OR pos+1 = length(name) THEN
        (name,"")
      ELSE
        (substring(name,0,pos-1),
	 substring(name,pos+1,length(name)-1))
      ENDIF

  %% Filename without extension
  filename_without_extension(name:string) : string =
    split_filename(name,".")`1

  %% Extension of filename
  filename_extension(name:string) : string =
    split_filename(name,".")`2

  printf(s:string) : MACRO void =
    print(format(s))

  fprintf(f:OStream,s:string): MACRO void =
    fprint(f,format(s))

  %% Write a PVS object to an output stream, so that it can be retrieved
  %% afterwards by fread
  fwrite_lisp(f:OStream,typ:string,t:Lisp_) : void

  %% Write a PVS object to an output stream, so that it can be retrieved
  %% afterwards by fread
  fwrite[T:TYPE](f:OStream,t:T) : MACRO void =
    LET the_type = type_of_domain_lisp(dummy_fun[T]) IN
    fwrite_lisp(f,the_type,to_lisp_[T](t))

  FileWriter[T:TYPE]  : TYPE = [[OStream,T]->void]

  fwrite_writer[T:TYPE] : JUDGEMENT
    fwrite[T] HAS_TYPE FileWriter

  fread_lisp[T:TYPE+](f:IStream,typ:string) : T

  %% Read a PVS object of type T from an input stream written by fwrite.
  %% Throw ReadPVS exception if read object is not of type T
  fread[T:TYPE+](f:IStream) : MACRO T =
    LET the_type = type_of_domain_lisp(dummy_fun[T]) IN
      fread_lisp(f,the_type)

  FileReader[T:TYPE+] : TYPE = [[IStream]->T]

  fread_reader[T:TYPE+] : JUDGEMENT
    fread[T] HAS_TYPE FileReader

  %% Iterate a function on a file n times. Throw exception ClosedStream if
  %% stream is not open
  fmap[T:TYPE](f:IStream,fread:[IStream->string],t:T,st:[[string,T]->T],n:nat): 
    RECURSIVE T =
    IF fopen?(f) THEN
      IF n=0 or eof?(f) THEN t
      ELSE
        LET s  = fread(f) IN
        LET nt = st(s,t) IN
          fmap(f,fread,nt,st,n-1)
      ENDIF
    ELSE throw(ClosedStream,fname(f))
    ENDIF
    MEASURE n

  %% Iterate a function on a file until the end. Closes file when done
  %% (no matter what)
  fmap[T:TYPE](f:IStream,fread:[IStream->string],t:T,st:[[string,T]->T]) : T =
    LET l = flength(f) IN
    unwind_protect(fmap(f,fread,t,st,l),fclose(f))

  %% Iterate a function on a file line by line until the end. Closes file when
  %% done (no matter what)
  fmap_line[T:TYPE](f:IStream,t:T,st:[[string,T]->T]):T =
    LET l = flength(f) IN
    unwind_protect(fmap(f,fread_line,t,st,l),fclose(f))

  %% Formatting text to a file
  printf[T:TYPE](s:string,t:T): MACRO void =
    print(format(s,t))

  fprintf[T:TYPE](f:OStream,s:string,t:T): MACRO void =
    fprint(f,format(s,t))

END stdio

%% stdfmap.pvs
%% In PVS-8.0, stdfmap was integrated into stdio

%% stdindent.pvs
%% In PVS-8.0, stdindent was moved to NASALib/pvsio_utils

%% stdtokenizer.pvs
%% In PVS-8.0, stdindent theory was moved to NASALib/pvsio_utils

%% stdpvsio.pvs
%% PVSio interface

stdpvsio : THEORY
BEGIN

  help_pvs_attachment(s:string) : void 

  help_pvs_theory_attachments(s:string) : void 

  pvsio_version : string

  set_promptin(s:string) : void

  set_promptout(s:string) : void

END stdpvsio

%% stdsys.pvs
%% PVSio sytem library 

stdsys : THEORY
BEGIN
  
  Time : TYPE = [# 
    second : below(60),
    minute : below(60),
    hour   : below(24),
    day    : subrange(1,31),
    month  : subrange(1,12),
    year   : nat,
    dow    : below(7), % Day of week: 0 Monday
    dst    : bool,     % Dayligth saving time?
    tz     : {x:rat| -24 <= x AND x <= 24} % Time zone 
  #]

  tinybang : Time = (#
    day    := 1,
    dow    := 0,
    dst    := false,
    hour   := 0,
    minute := 0,
    month  := 1,
    second := 0,
    tz     := 0,
    year   := 0
  #)

  days_of_week(dow:below(7)):string =
    if    dow=0 then "Monday"
    elsif dow=1 then "Tuesday"
    elsif dow=2 then "Wednesday"
    elsif dow=3 then "Thursday" 
    elsif dow=4 then "Friday"
    elsif dow=5 then "Saturday"
    else  "Sunday"
    endif
 
  months(month:subrange(1,12)):string =
    if    month=1  then "January"
    elsif month=2  then "February"
    elsif month=3  then "March"
    elsif month=4  then "April"
    elsif month=5  then "May"
    elsif month=6  then "June"
    elsif month=7  then "July"
    elsif month=8  then "August"
    elsif month=9  then "September"
    elsif month=10 then "October"
    elsif month=11 then "November"
    else "December"
    endif

  tostr(t:Time): string =
    days_of_week(dow(t))+" "+months(month(t))+
    format(" ~2,'0d ",day(t))+year(t)+
    format(", ~2,'0d:~2,'0d:~2,'0d ",{| hour(t),minute(t),second(t) |})+
    format("(GMT~@d)",-tz(t))
    
  %% Get current time
  get_time : Time

  %% Today in US format mm/dd/yy
  today : string =
    LET t = get_time IN
    format("~2,'0d/~2,'0d/~d",{| month(t), day(t), year(t) |})

  %% Today in long format
  date : string =
    tostr(get_time)

  %% Today in yyyy-mm-dd format
  date_yyyy_mm_dd : string =
    LET t = get_time IN
    format("~d-~2,'0d-~2,'0d",{| year(t), month(t), day(t) |})

  %% Today in dd-mm-yyyy format
  date_dd_mm_yyyy : string =
    LET t = get_time IN
    format("~2,'0d-~2,'0d-~d",{| day(t), month(t), year(t) |})

  %% Timestamp in format yyyymmddhhmmss
  time_yyyymmddhhmmss : string =
    LET t = get_time IN
    format("~d~2,'0d~2,'0d~2,'0d~2,'0d~2,'0d",
           {| year(t), month(t), day(t), hour(t), minute(t), second(t) |})

  %% Realtime in internal units
  real_time : nat

  %% Runtime in internal units
  run_time  : nat

  %% Internal units
  internal_time_units : posreal

  %% (realtime,runtime)
  Stamp : Global[[nat,nat]] =
    LET zeros : [nat, nat] = (0,0) IN ref(zeros)

  tic : void =
    set[[nat,nat]](Stamp,(real_time,run_time))

  Toc : TYPE = [nnreal,nnreal]
  
  %% Return times in seconds
  toc : Toc = 
    LET (ret,rut) = (real_time,run_time),
        (re0,ru0) = val[[nat,nat]](Stamp) IN
      (max(0,(ret-re0))/internal_time_units,
       max(0,(rut-ru0)/internal_time_units))

  %% t is in secods; returns formatted string in the form "<h>h:<m>m:<s>s"
  hms(t:real) : string =
    LET ts : int = floor(t),
	ms : real = t-ts,
	h  : int = floor(ts/3600),
        m  : int = floor(mod(ts,3600)/60),
        s  : real = mod(mod(ts,3600),60)+ms IN
    format("~ah:~am:~,3fs",{|h,m,s|})

  strtoc(atoc:Toc) : MACRO string =
    LET (realtime,runtime) = atoc IN 
    format("Real Time: ~a (~,3f sec). Run Time: ~a (~,3f sec)~%",
	  {| hms(realtime), realtime, hms(runtime), runtime |})

  %% Time profiler of a function
  time_profiler[T:TYPE](fun:T) : MACRO T =
    LET (result,atoc) = prog[[T,Toc]](tic,(fun,toc)) IN
      prog(print(strtoc(atoc)),
    	   result)

  %% Sleep n seconds
  sleep(n:nat): void

  %% Get environment variable (default)
  get_env(name,default:string):string

  get_env(name:string): MACRO string = get_env(name,emptystr)

  %% Make a system call and return status and output string
  system_call(call:string) : [nat,string]

END stdsys
