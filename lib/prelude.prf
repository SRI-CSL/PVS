(booleans)(equalities)(notequal)(if_def (IF_TCC1 0 (IF_TCC1-1 nil 3237052399 ("" (inst 1 "LAMBDA (x: [boolean, T, T]): PROJ_2(x)") nil nil) ((T formal-type-decl nil if_def nil) (boolean nonempty-type-decl nil booleans nil)) nil (IF existence "" "[[booleans.boolean, if_def.T, if_def.T] -> if_def.T]"))))(boolean_props (bool_exclusive 0 (bool_exclusive-1 nil 3237052399 ("" (iff) (("" (prop) nil nil)) nil) nil nil)) (bool_inclusive 0 (bool_inclusive-1 nil 3237052399 ("" (skolem!) (("" (prop) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil) nil nil)) (not_def 0 (not_def-1 nil 3237052399 ("" (skosimp) (("" (iff) (("" (prop) nil nil)) nil)) nil) nil nil)) (and_def 0 (and_def-1 nil 3237052399 ("" (skolem!) (("" (iff) (("" (prop) nil nil)) nil)) nil) nil nil)) (syand_def 0 (syand_def-1 nil 3237052399 ("" (propax) nil nil) nil nil)) (or_def 0 (or_def-1 nil 3237052399 ("" (skolem!) (("" (iff) (("" (prop) nil nil)) nil)) nil) nil nil)) (implies_def 0 (implies_def-1 nil 3237052399 ("" (skolem!) (("" (iff) (("" (prop) nil nil)) nil)) nil) nil nil)) (syimplies_def 0 (syimplies_def-1 nil 3237052399 ("" (propax) nil nil) nil nil)) (when_def 0 (when_def-1 nil 3237052399 ("" (skolem!) nil nil) nil nil)) (iff_def 0 (iff_def-1 nil 3237052399 ("" (skolem!) (("" (iff) (("" (prop) nil nil)) nil)) nil) nil nil)) (syiff_def 0 (syiff_def-1 nil 3237052399 ("" (propax) nil nil) nil nil)) (excluded_middle 0 (excluded_middle-1 nil 3237052399 ("" (grind) nil nil) nil nil)))(xor_def (xor_def 0 (xor_def-1 nil 3237052399 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil) (XOR const-decl "bool" xor_def nil)) nil)))(quantifier_props (not_exists 0 (not_exists-1 nil 3237052399 ("" (skolem!) (("" (iff) (("" (prop) (("1" (skolem!) (("1" (inst?) nil nil)) nil) ("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (exists_not 0 (exists_not-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (exists_or 0 (exists_or-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (exists_implies 0 (exists_implies-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (exists_and 0 (exists_and-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (not_forall 0 (not_forall-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (forall_not 0 (forall_not-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (forall_and 0 (forall_and-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)) (forall_or 0 (forall_or-1 nil 3237052399 ("" (grind) nil nil) ((t formal-type-decl nil quantifier_props nil)) nil)))(defined_types)(exists1 (unique_lem 0 (unique_lem-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (expand "unique?") (("" (skolem!) (("" (flatten) (("" (inst-cp -1 "x!1") (("" (inst -1 "y!1") (("" (inst - "x!1" "y!1") (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil exists1 nil) (unique? const-decl "bool" exists1 nil)) nil)) (exists1_lem 0 (exists1_lem-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (expand "exists1") (("" (prop) nil nil)) nil)) nil)) nil) ((exists1 const-decl "bool" exists1 nil)) nil)))(equality_props (IF_true 0 (IF_true-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (IF_false 0 (IF_false-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (IF_same 0 (IF_same-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (reflexivity_of_equals 0 (reflexivity_of_equals-1 nil 3237052399 ("" (skolem!) nil nil) nil nil)) (transitivity_of_equals 0 (transitivity_of_equals-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil) nil nil)) (symmetry_of_equals 0 (symmetry_of_equals-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil) nil nil)))(if_props (lift_if1 0 (lift_if1-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (lift_if2 0 (lift_if2-1 nil 3237052399 ("" (grind) nil nil) nil nil)))(functions (extensionality_postulate 0 (extensionality_postulate-1 nil 3237052399 ("" (skosimp) (("" (prop) (("1" (apply-extensionality) nil nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ((D formal-type-decl nil functions nil) (R formal-type-decl nil functions nil)) nil)) (extensionality 0 (extensionality-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (apply-extensionality) nil nil)) nil)) nil) ((D formal-type-decl nil functions nil) (R formal-type-decl nil functions nil)) nil)) (congruence 0 (congruence-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (eta 0 (eta-1 nil 3237052399 ("" (skolem!) (("" (apply-extensionality) nil nil)) nil) ((R formal-type-decl nil functions nil) (D formal-type-decl nil functions nil)) nil)) (bij_is_inj 0 (bij_is_inj-1 nil 3835419715 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil functions nil) (R formal-type-decl nil functions nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil)) shostak (bij_is_inj_ subtype "(functions.bijective?)" "(functions.injective?)"))) (bij_is_surj 0 (bij_is_surj-1 nil 3835419715 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil functions nil) (R formal-type-decl nil functions nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil)) shostak (bij_is_surj_ subtype "(functions.bijective?)" "(functions.surjective?)"))))(functions_alt)(transpose)(restrict (injective_restrict 0 (injective_restrict-1 nil 3237052399 ("" (expand "injective?") (("" (skosimp*) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil restrict nil) (boolean nonempty-type-decl nil booleans nil) (S_pred const-decl "[T -> boolean]" restrict nil) (S formal-subtype-decl nil restrict nil) (restrict const-decl "R" restrict nil) (injective? const-decl "bool" functions nil)) nil)) (restrict_of_inj_is_inj 0 (restrict_of_inj_is_inj-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict nil) (R formal-type-decl nil restrict nil) (S formal-subtype-decl nil restrict nil) (S_pred const-decl "[T -> boolean]" restrict nil) (restrict const-decl "R" restrict nil) (injective? const-decl "bool" functions nil)) nil (restrict_of_inj_is_inj subtype "restrict.restrict(restrict.f)" "(functions[S, restrict.R].injective?)"))))(restrict_props (restrict_full 0 (restrict_full-1 nil 3245191654 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) nil nil)) nil) ((R formal-type-decl nil restrict_props nil) (T formal-type-decl nil restrict_props nil) (restrict const-decl "R" restrict nil)) shostak)))(extend (restrict_extend 0 (restrict_extend-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) nil nil)) nil) ((R formal-type-decl nil extend nil) (S formal-subtype-decl nil extend nil) (S_pred const-decl "[T -> boolean]" extend nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil extend nil) (extend const-decl "R" extend nil) (restrict const-decl "R" restrict nil)) nil)))(extend_bool)(extend_props (extend_full 0 (extend_full-1 nil 3245191700 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) nil nil)) nil) ((R formal-type-decl nil extend_props nil) (T formal-type-decl nil extend_props nil) (extend const-decl "R" extend nil) (d formal-const-decl "R" extend_props nil)) shostak)))(extend_func_props (surjective_extend 0 (surjective_extend-1 nil 3249327214 ("" (skolem-typepred) (("" (expand "surjective?") (("" (skolem!) (("" (inst?) (("" (skolem!) (("" (inst?) (("" (expand "extend") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (surjective? const-decl "bool" functions nil) (R formal-type-decl nil extend_func_props nil) (S formal-subtype-decl nil extend_func_props nil) (S_pred const-decl "[T -> boolean]" extend_func_props nil) (T formal-type-decl nil extend_func_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (surjective_extend subtype "extend[extend_func_props.T, S, extend_func_props.R, extend_func_props.d].extend(extend_func_props.f)" "(functions[extend_func_props.T, extend_func_props.R].surjective?)"))))(K_conversion)(K_props (K_preserves 0 (K_preserves-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((K_conversion const-decl "T1" K_conversion nil)) nil (K_preserves subtype "K_conversion[K_props.T1, K_props.T2].K_conversion(K_props.x)(K_props.y)" "S"))) (K_preserves1 0 (K_preserves1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((K_conversion const-decl "T1" K_conversion nil)) nil (K_preserves1 subtype "K_conversion[K_props.T1, K_props.T2].K_conversion(K_props.x)" "[K_props.T2 -> S]"))))(identity (I_TCC1 0 (I_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil identity nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) nil (I subtype "(LAMBDA x: identity.x)" "(functions[identity.T, identity.T].bijective?)"))))(identity_props (I_preserves 0 (I_preserves-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((I const-decl "(bijective?[T, T])" identity nil)) nil (I_preserves subtype "identity[identity_props.T].I(identity_props.x)" "S"))) (id_preserves 0 (id_preserves-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((id const-decl "(bijective?[T, T])" identity nil)) nil (id_preserves subtype "identity[identity_props.T].id(identity_props.x)" "S"))) (identity_preserves 0 (identity_preserves-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((identity const-decl "(bijective?[T, T])" identity nil)) nil (identity_preserves subtype "identity[identity_props.T].identity(identity_props.x)" "S"))))(relations (equiv_is_reflexive 0 (equiv_is_reflexive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "equivalence?") (("" (assert) nil nil)) nil)) nil) ((equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (equiv_is_reflexive_ subtype "(relations.equivalence?)" "(relations.reflexive?)"))) (equiv_is_symmetric 0 (equiv_is_symmetric-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "equivalence?") (("" (assert) nil nil)) nil)) nil) ((equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (equiv_is_symmetric_ subtype "(relations.equivalence?)" "(relations.symmetric?)"))) (equiv_is_transitive 0 (equiv_is_transitive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "equivalence?") (("" (assert) nil nil)) nil)) nil) ((equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (equiv_is_transitive_ subtype "(relations.equivalence?)" "(relations.transitive?)"))))(orders (preorder_is_reflexive 0 (preorder_is_reflexive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "preorder?") (("" (assert) nil nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (preorder_is_reflexive_ subtype "(orders.preorder?)" "(relations[orders.T].reflexive?)"))) (preorder_is_transitive 0 (preorder_is_transitive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "preorder?") (("" (assert) nil nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (preorder_is_transitive_ subtype "(orders.preorder?)" "(relations[orders.T].transitive?)"))) (equiv_is_preorder 0 (equiv_is_preorder-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "equivalence?") (("" (expand "preorder?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (equiv_is_preorder_ subtype "(relations[orders.T].equivalence?)" "(orders.preorder?)"))) (po_is_preorder 0 (po_is_preorder-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "partial_order?") (("" (assert) nil nil)) nil)) nil) ((partial_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (po_is_preorder_ subtype "(orders.partial_order?)" "(orders.preorder?)"))) (po_is_antisymmetric 0 (po_is_antisymmetric-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "partial_order?") (("" (assert) nil nil)) nil)) nil) ((partial_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (po_is_antisymmetric_ subtype "(orders.partial_order?)" "(relations[orders.T].antisymmetric?)"))) (strict_is_irreflexive 0 (strict_is_irreflexive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "strict_order?") (("" (assert) nil nil)) nil)) nil) ((strict_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_is_irreflexive_ subtype "(orders.strict_order?)" "(relations[orders.T].irreflexive?)"))) (strict_order_is_antisymmetric 0 (strict_order_is_antisymmetric-1 nil 3252220963 ("" (grind :if-match nil) (("" (inst -2 "x!2" "y!1" "x!2") (("" (assert) (("" (inst -1 "x!2") nil nil)) nil)) nil)) nil) ((irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil orders nil) (pred type-eq-decl nil defined_types nil) (strict_order? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil)) shostak (strict_order_is_antisymmetric subtype "orders.x" "(relations[orders.T].antisymmetric?)"))) (strict_is_transitive 0 (strict_is_transitive-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "strict_order?") (("" (assert) nil nil)) nil)) nil) ((strict_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_is_transitive_ subtype "(orders.strict_order?)" "(relations[orders.T].transitive?)"))) (total_is_po 0 (total_is_po-1 nil 3835419716 ("" (skolem-typepred) (("" (expand "total_order?") (("" (assert) nil nil)) nil)) nil) ((total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (total_is_po_ subtype "(orders.total_order?)" "(orders.partial_order?)"))) (total_is_dichotomous 0 (total_is_dichotomous-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "total_order?") (("" (assert) nil nil)) nil)) nil) ((total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (total_is_dichotomous_ subtype "(orders.total_order?)" "(orders.dichotomous?)"))) (linear_is_total 0 (linear_is_total-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "linear_order?") (("" (propax) nil nil)) nil)) nil) ((linear_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (linear_is_total subtype "orders.x" "(orders.total_order?)"))) (total_is_linear 0 (total_is_linear-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "linear_order?") (("" (propax) nil nil)) nil)) nil) ((linear_order? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (total_is_linear subtype "orders.x" "(orders.linear_order?)"))) (strict_total_is_strict 0 (strict_total_is_strict-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "strict_total_order?") (("" (assert) nil nil)) nil)) nil) ((strict_total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_total_is_strict_ subtype "(orders.strict_total_order?)" "(orders.strict_order?)"))) (strict_total_is_trichotomous 0 (strict_total_is_trichotomous-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "strict_total_order?") (("" (assert) nil nil)) nil)) nil) ((strict_total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_total_is_trichotomous_ subtype "(orders.strict_total_order?)" "(orders.trichotomous?)"))) (strict_well_founded_is_strict 0 (strict_well_founded_is_strict-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "strict_well_founded?") (("" (assert) nil nil)) nil)) nil) ((strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_well_founded_is_strict_ subtype "(orders.strict_well_founded?)" "(orders.strict_order?)"))) (strict_well_founded_is_well_founded 0 (strict_well_founded_is_well_founded-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "strict_well_founded?") (("" (assert) nil nil)) nil)) nil) ((strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (strict_well_founded_is_well_founded_ subtype "(orders.strict_well_founded?)" "(orders.well_founded?)"))) (well_ordered_is_strict_total 0 (well_ordered_is_strict_total-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "well_ordered?") (("" (assert) nil nil)) nil)) nil) ((well_ordered? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (well_ordered_is_strict_total_ subtype "(orders.well_ordered?)" "(orders.strict_total_order?)"))) (well_ordered_is_well_founded 0 (well_ordered_is_well_founded-1 nil 3835419717 ("" (skolem-typepred) (("" (expand "well_ordered?") (("" (assert) nil nil)) nil)) nil) ((well_ordered? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (well_ordered_is_well_founded_ subtype "(orders.well_ordered?)" "(orders.well_founded?)"))))(orders_alt (least_upper_bound_is_upper_bound 0 (least_upper_bound_is_upper_bound-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil orders_alt nil) (least_upper_bound? const-decl "[T -> bool]" orders_alt nil) (pe formal-const-decl "nonempty_pred[T]" orders_alt nil) (nonempty_pred type-eq-decl nil orders nil) (pred type-eq-decl nil defined_types nil) (least_upper_bound? const-decl "bool" orders nil) (least_upper_bound? const-decl "bool" orders nil) (upper_bound? const-decl "[T -> bool]" orders_alt nil) (upper_bound? const-decl "bool" orders nil) (upper_bound? const-decl "bool" orders nil)) nil (least_upper_bound_is_upper_bound subtype "orders_alt.x" "(orders_alt.upper_bound?)"))) (greatest_lower_bound_is_lower_bound 0 (greatest_lower_bound_is_lower_bound-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil orders_alt nil) (greatest_lower_bound? const-decl "[T -> bool]" orders_alt nil) (pe formal-const-decl "nonempty_pred[T]" orders_alt nil) (nonempty_pred type-eq-decl nil orders nil) (pred type-eq-decl nil defined_types nil) (greatest_lower_bound? const-decl "bool" orders nil) (greatest_lower_bound? const-decl "bool" orders nil) (lower_bound? const-decl "[T -> bool]" orders_alt nil) (lower_bound? const-decl "bool" orders nil) (lower_bound? const-decl "bool" orders nil)) nil (greatest_lower_bound_is_lower_bound subtype "orders_alt.x" "(orders_alt.lower_bound?)"))))(restrict_order_props (reflexive_restrict 0 (reflexive_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (restrict const-decl "R" restrict nil) (reflexive? const-decl "bool" relations nil)) nil (reflexive_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].reflexive?)"))) (irreflexive_restrict 0 (irreflexive_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (restrict const-decl "R" restrict nil) (irreflexive? const-decl "bool" relations nil)) nil (irreflexive_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].irreflexive?)"))) (symmetric_restrict 0 (symmetric_restrict-1 nil 3249347110 ("" (skolem-typepred) (("" (expand* "symmetric?" "restrict") (("" (skosimp) (("" (inst - "x!1" "y!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (symmetric? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil restrict_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (symmetric_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].symmetric?)"))) (antisymmetric_restrict 0 (antisymmetric_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (restrict const-decl "R" restrict nil) (antisymmetric? const-decl "bool" relations nil)) nil (antisymmetric_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].antisymmetric?)"))) (connected_restrict 0 (connected_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (/= const-decl "boolean" notequal nil) (restrict const-decl "R" restrict nil) (connected? const-decl "bool" relations nil)) nil (connected_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].connected?)"))) (transitive_restrict 0 (transitive_restrict-1 nil 3249347110 ("" (skolem-typepred) (("" (expand* "transitive?" "restrict") (("" (skosimp) (("" (inst - "x!1" "y!1" "z!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (transitive? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil restrict_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (transitive_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].transitive?)"))) (equivalence_restrict 0 (equivalence_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -6 "x!1" "y!1" "z!1") (("1" (assert) nil nil)) nil) ("2" (inst -4 "x!1" "y!1") (("2" (assert) nil nil)) nil) ("3" (inst -2 "x!1") nil nil)) nil) ((symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (equivalence? const-decl "bool" relations nil)) nil (equivalence_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(relations[S].equivalence?)"))) (preorder_restrict 0 (preorder_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -5 "x!1" "y!1" "z!1") (("1" (assert) nil nil)) nil) ("2" (inst -2 "x!1") nil nil)) nil) ((transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (preorder? const-decl "bool" orders nil)) nil (preorder_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].preorder?)"))) (partial_order_restrict 0 (partial_order_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -5 "x!1" "y!1") (("1" (assert) nil nil)) nil) ("2" (inst -5 "x!1" "y!1" "z!1") (("2" (assert) nil nil)) nil) ("3" (inst -2 "x!1") nil nil)) nil) ((preorder_restrict application-judgement "(preorder?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (partial_order? const-decl "bool" orders nil)) nil (partial_order_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].partial_order?)"))) (strict_order_restrict 0 (strict_order_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -5 "x!1" "y!1" "z!1") (("1" (assert) nil nil)) nil) ("2" (inst -2 "x!1") nil nil)) nil) ((antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (irreflexive_restrict application-judgement "(irreflexive?[S])" restrict_order_props nil) (strict_order? const-decl "bool" orders nil)) nil (strict_order_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].strict_order?)"))) (dichotomous_restrict 0 (dichotomous_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (pred type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (restrict const-decl "R" restrict nil) (dichotomous? const-decl "bool" orders nil)) nil (dichotomous_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].dichotomous?)"))) (total_order_restrict 0 (total_order_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -6 "x!1" "y!1") (("1" (assert) nil nil)) nil) ("2" (inst -5 "x!1" "y!1") (("2" (assert) nil nil)) nil) ("3" (inst -5 "x!1" "y!1" "z!1") (("3" (assert) nil nil)) nil) ("4" (inst -2 "x!1") nil nil)) nil) ((dichotomous_restrict application-judgement "(dichotomous?[S])" restrict_order_props nil) (partial_order_restrict application-judgement "(partial_order?[S])" restrict_order_props nil) (total_order? const-decl "bool" orders nil)) nil (total_order_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].total_order?)"))) (trichotomous_restrict 0 (trichotomous_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_order_props nil) (pred type-eq-decl nil defined_types nil) (S formal-subtype-decl nil restrict_order_props nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (restrict const-decl "R" restrict nil) (trichotomous? const-decl "bool" orders nil)) nil (trichotomous_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].trichotomous?)"))) (strict_total_order_restrict 0 (strict_total_order_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -5 "x!1" "y!1") (("1" (assert) nil nil)) nil) ("2" (inst -5 "x!1" "y!1" "z!1") (("2" (assert) nil nil)) nil) ("3" (inst -2 "x!1") nil nil)) nil) ((trichotomous_restrict application-judgement "(trichotomous?[S])" restrict_order_props nil) (strict_order_restrict application-judgement "(strict_order?[S])" restrict_order_props nil) (strict_total_order? const-decl "bool" orders nil)) nil (strict_total_order_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].strict_total_order?)"))) (well_founded_restrict 0 (well_founded_restrict-1 nil 3249347110 ("" (skolem-typepred) (("" (expand* "well_founded?" "restrict") (("" (skosimp*) (("" (inst - "extend[T, S, bool, FALSE](p!1)") (("" (split) (("1" (skolem-typepred) (("1" (expand "extend") (("1" (prop) (("1" (assert) (("1" (inst + "y!2") (("1" (skolem!) (("1" (inst - "x!1") (("1" (expand "extend") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "y!1") (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (S_pred const-decl "[T -> boolean]" restrict_order_props nil) (S formal-subtype-decl nil restrict_order_props nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (p!1 skolem-const-decl "pred[S]" restrict_order_props nil) (x!1 skolem-const-decl "(p!1)" restrict_order_props nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil restrict_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (well_founded_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].well_founded?)"))) (well_ordered_restrict 0 (well_ordered_restrict-1 nil 3249347110 ("" (grind :if-match nil) (("1" (inst -5 "p!1") (("1" (grind :if-match nil) (("1" (inst 1 "y!2") (("1" (skosimp) (("1" (inst -7 "x!1") nil nil)) nil)) nil) ("2" (inst 1 "y!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -5 "x!1" "y!1") (("2" (assert) nil nil)) nil) ("3" (inst -5 "x!1" "y!1" "z!1") (("3" (assert) nil nil)) nil) ("4" (inst -2 "x!1") nil nil)) nil) ((well_founded_restrict application-judgement "(well_founded?[S])" restrict_order_props nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (well_ordered? const-decl "bool" orders nil)) nil (well_ordered_restrict subtype "restrict[[restrict_order_props.T, restrict_order_props.T], [S, S], booleans.bool].restrict(restrict_order_props.R)" "(orders[S].well_ordered?)"))))(extend_order_props (irreflexive_extend 0 (irreflexive_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "irreflexive?" "extend") (("" (skolem!) (("" (prop) (("" (inst?) nil nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (irreflexive? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil extend_order_props nil) (S_pred const-decl "[T -> boolean]" extend_order_props nil) (T formal-type-decl nil extend_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (irreflexive_extend subtype "extend[[extend_order_props.T, extend_order_props.T], [S, S], booleans.bool, booleans.FALSE].extend(extend_order_props.R)" "(relations[extend_order_props.T].irreflexive?)"))) (symmetric_extend 0 (symmetric_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "symmetric?" "extend") (("" (skosimp) (("" (prop) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (symmetric? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil extend_order_props nil) (S_pred const-decl "[T -> boolean]" extend_order_props nil) (T formal-type-decl nil extend_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (symmetric_extend subtype "extend[[extend_order_props.T, extend_order_props.T], [S, S], booleans.bool, booleans.FALSE].extend(extend_order_props.R)" "(relations[extend_order_props.T].symmetric?)"))) (antisymmetric_extend 0 (antisymmetric_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "antisymmetric?" "extend") (("" (skosimp) (("" (prop) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (antisymmetric? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil extend_order_props nil) (S_pred const-decl "[T -> boolean]" extend_order_props nil) (T formal-type-decl nil extend_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (antisymmetric_extend subtype "extend[[extend_order_props.T, extend_order_props.T], [S, S], booleans.bool, booleans.FALSE].extend(extend_order_props.R)" "(relations[extend_order_props.T].antisymmetric?)"))) (transitive_extend 0 (transitive_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "transitive?" "extend") (("" (skosimp) (("" (prop) (("" (inst - "x!1" "y!1" "z!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (transitive? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (S formal-subtype-decl nil extend_order_props nil) (S_pred const-decl "[T -> boolean]" extend_order_props nil) (T formal-type-decl nil extend_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (transitive_extend subtype "extend[[extend_order_props.T, extend_order_props.T], [S, S], booleans.bool, booleans.FALSE].extend(extend_order_props.R)" "(relations[extend_order_props.T].transitive?)"))) (strict_order_extend 0 (strict_order_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand "strict_order?") (("" (flatten) (("" (use "irreflexive_extend") (("" (use "transitive_extend") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((antisymmetric_extend application-judgement "(antisymmetric?[T])" extend_order_props nil) (transitive_extend application-judgement "(transitive?[T])" extend_order_props nil) (irreflexive_extend application-judgement "(irreflexive?[T])" extend_order_props nil) (strict_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (S formal-subtype-decl nil extend_order_props nil) (S_pred const-decl "[T -> boolean]" extend_order_props nil) (T formal-type-decl nil extend_order_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (strict_order_extend subtype "extend[[extend_order_props.T, extend_order_props.T], [S, S], booleans.bool, booleans.FALSE].extend(extend_order_props.R)" "(orders[extend_order_props.T].strict_order?)"))))(wf_induction (wf_induction 0 (wf_induction-1 nil 3237052399 ("" (skosimp) (("" (skosimp) (("" (typepred "<") (("" (expand "well_founded?") (("" (inst -1 "{z:T|NOT p!1(z)}") (("" (assert) (("" (split) (("1" (skosimp) (("1" (inst -2 "y!1") (("1" (split) (("1" (typepred "y!1") (("1" (propax) nil nil)) nil) ("2" (skosimp) (("2" (inst -2 "y!2") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((y!2 skolem-const-decl "T" wf_induction nil) (p!1 skolem-const-decl "pred[T]" wf_induction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil wf_induction nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (< formal-const-decl "(well_founded?[T])" wf_induction nil)) nil)))(measure_induction (measure_induction 0 (measure_induction-1 nil 3237052399 ("" (lemma "wf_induction[T,(LAMBDA (x, y: T): m(x) < m(y))]") (("1" (skosimp*) (("1" (inst -1 "p!1") (("1" (split) (("1" (inst -1 "x!1") nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "well_founded?") (("2" (typepred "<") (("2" (expand "well_founded?") (("2" (skosimp*) (("2" (inst -1 "(LAMBDA (y:M): (exists (z:T): m(z) = y AND p!1(z)))") (("2" (split) (("1" (skosimp*) (("1" (typepred "y!2") (("1" (skosimp*) (("1" (inst 1 "z!1") (("1" (skosimp*) (("1" (inst -3 "m(x!1)") (("1" (assert) nil nil) ("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "y!1") (("2" (skosimp*) (("2" (inst 1 "m(y!1)") (("2" (inst 1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (p!1 skolem-const-decl "pred[T]" measure_induction nil) (z!1 skolem-const-decl "T" measure_induction nil) (x!1 skolem-const-decl "(p!1)" measure_induction nil) (y!1 skolem-const-decl "T" measure_induction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_induction formula-decl nil wf_induction nil) (T formal-type-decl nil measure_induction nil) (M formal-type-decl nil measure_induction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (< formal-const-decl "(well_founded?[M])" measure_induction nil) (m formal-const-decl "[T -> M]" measure_induction nil)) nil)))(epsilons)(decl_params)(sets (singleton_TCC1 0 (singleton_TCC1-1 nil 3237052399 ("" (skosimp) (("" (expand "singleton?") (("" (inst 1 "x!1") nil nil)) nil)) nil) ((singleton? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets nil)) nil (singleton subtype "{y | sets.y = sets.x}" "(sets.singleton?)"))) (add_TCC1 0 (add_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (add subtype "{y | booleans.OR(sets.x = sets.y, sets.member(sets.y, sets.a))}" "(sets.nonempty?)"))) (choose_TCC1 0 (choose_TCC1-2 "" 3458163628 ("" (inst 1 "lambda (p: (nonempty?)): epsilon(p)") (("1" (skolem-typepred) (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (epsilon_ax formula-decl nil epsilons nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets nil)) shostak (choose existence "" "[p: (sets.nonempty?) -> (p)]")) (choose_TCC1-1 nil 3237052399 ("" (skolem-typepred) (("" (grind) nil nil)) nil) nil nil (choose existence "" "[p: (sets.nonempty?) -> (p)]"))) (choose_is_epsilon_TCC1 0 (choose_is_epsilon_TCC1-1 nil 3471679708 ("" (existence-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak (choose_is_epsilon existence "" "sets.T"))) (the_TCC1 0 (the_TCC1-2 "" 3425349882 ("" (inst 1 "lambda (x: (singleton?)): epsilon(x)") (("1" (skolem-typepred) (("1" (expand "singleton?") (("1" (skolem-typepred) (("1" (use "epsilon_ax[T]") (("1" (split) (("1" (propax) nil nil) ("2" (inst?) nil nil)) nil) ("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "singleton?") (("2" (skolem-typepred) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets nil)) shostak (the existence "" "[p: (sets.singleton?) -> (p)]")) (the_TCC1-1 nil 3237052399 ("" (skolem-typepred) (("" (use "epsilon_ax[T]") (("" (assert) (("" (expand "singleton?") (("" (skosimp*) (("" (inst 1 "x!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (the existence "" "[p: (sets.singleton?) -> (p)]"))) (the_lem 0 (the_lem-2 "" 3737148469 ("" (skolem-typepred) (("" (expand "singleton?") (("" (skolem-typepred) (("" (typepred "the(p!1)") (("" (lemma "epsilon_ax[T]") (("1" (inst -1 "p!1") (("1" (split) (("1" (inst-cp -4 "the(p!1)") (("1" (inst -4 "epsilon(p!1)") (("1" (assert) nil nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil) ((the const-decl "(p)" sets nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (p!1 skolem-const-decl "(singleton?)" sets nil) (epsilon_ax formula-decl nil epsilons nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (the_lem-1 nil 3425282612 ("" (skolem-typepred) (("" (expand "singleton?") (("" (skolem-typepred) (("" (typepred "the(p!1)") (("" (lemma "epsilon_ax[T]") (("" (inst -1 "p!1") (("" (split) (("1" (inst-cp -4 "the(p!1)") (("1" (inst -4 "epsilon(p!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((the const-decl "(p)" sets nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (epsilon_ax formula-decl nil epsilons nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (the_prop 0 (the_prop-1 nil 3425283476 ("" (skolem-typepred) (("" (assert) nil nil)) nil) ((singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (singleton_elt_TCC1 0 (singleton_elt_TCC1-1 nil 3282864729 ("" (subtype-tcc) (("" (typepred "a!1") (("" (expand "singleton?") (("" (skosimp) (("" (inst-cp -1 "x!1") (("" (inst -1 "y!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak (singleton_elt subtype "LAMBDA x: sets.member(sets.x, sets.a)" "(sets.singleton?)"))) (is_singleton 0 (is_singleton-1 nil 3412877319 ("" (skosimp*) (("" (expand "singleton?") (("" (expand "nonempty?") (("" (expand "empty?") (("" (skosimp*) (("" (expand "member") (("" (inst 1 "x!1") (("" (skosimp*) (("" (inst? -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (T formal-type-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (a!1 skolem-const-decl "set" sets nil) (x!1 skolem-const-decl "T" sets nil) (nonempty? const-decl "bool" sets nil)) shostak)) (singleton_elt_lem 0 (singleton_elt_lem-3 "" 3737148573 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (skosimp*) (("" (rewrite "the_lem") (("1" (expand "member") (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "x!1") (("1" (assert) nil nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("2" (expand "member") (("2" (expand "singleton?") (("2" (inst 1 "x!2") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton_elt const-decl "T" sets nil) (x!1 skolem-const-decl "T" sets nil) (epsilon const-decl "T" epsilons nil) (a!1 skolem-const-decl "set" sets nil) (pred type-eq-decl nil defined_types nil) (epsilon_ax formula-decl nil epsilons nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets nil) (the_lem formula-decl nil sets nil) (singleton? const-decl "bool" sets nil)) shostak) (singleton_elt_lem-2 "" 3425350335 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (skosimp*) (("" (rewrite "the_lem") (("1" (expand "member") (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "singleton?") (("2" (inst 1 "x!2") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton_elt const-decl "T" sets nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (epsilon_ax formula-decl nil epsilons nil) (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets nil) (the_lem formula-decl nil sets nil) (singleton? const-decl "bool" sets nil)) shostak) (singleton_elt_lem-1 nil 3412877468 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (skosimp*) (("" (expand "the") (("" (expand "member") (("" (use "epsilon_ax[T]") (("" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (singleton_elt_def_TCC1 0 (singleton_elt_def_TCC1-1 nil 3412876783 ("" (subtype-tcc) nil nil) ((set type-eq-decl nil sets nil) (T formal-type-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) shostak (singleton_elt_def subtype "sets.a" "(sets.nonempty?)"))) (singleton_elt_def 0 (singleton_elt_def-3 "" 3737148743 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (rewrite "the_lem") (("1" (expand "member") (("1" (skosimp*) (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "choose(a!1)") (("1" (assert) nil nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil) ("2" (assert) (("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "singleton?") (("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton_elt const-decl "T" sets nil) (the_lem formula-decl nil sets nil) (T formal-type-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (epsilon const-decl "T" epsilons nil) (a!1 skolem-const-decl "set" sets nil) (pred type-eq-decl nil defined_types nil) (epsilon_ax formula-decl nil epsilons nil) (singleton? const-decl "bool" sets nil)) shostak) (singleton_elt_def-2 "" 3425350533 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (rewrite "the_lem") (("1" (expand "member") (("1" (skosimp*) (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "choose(a!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "singleton?") (("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton_elt const-decl "T" sets nil) (the_lem formula-decl nil sets nil) (T formal-type-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (epsilon_ax formula-decl nil epsilons nil) (TRUE const-decl "bool" booleans nil) (singleton? const-decl "bool" sets nil)) shostak) (singleton_elt_def-1 nil 3412877903 ("" (skosimp*) (("" (expand "singleton_elt") (("" (expand "singleton?") (("" (expand "the") (("" (expand "member") (("" (skosimp*) (("" (use "epsilon_ax[T]") (("" (prop) (("1" (inst-cp -2 "epsilon(LAMBDA x: a!1(x))") (("1" (inst -2 "choose(a!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (singleton_singleton 0 (singleton_singleton-1 nil 3458163659 ("" (skosimp) (("" (expand "singleton?") (("" (skolem-typepred) (("" (inst 1 "x!1") (("" (expand "singleton") (("" (apply-extensionality :hide? t) (("" (case "a!1(x!2)") (("1" (inst -3 "x!2") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((singleton? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (a!1 skolem-const-decl "set" sets nil) (x!2 skolem-const-decl "T" sets nil) (singleton const-decl "(singleton?)" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (singleton_rew 0 (singleton_rew-3 "" 3737176775 ("" (skosimp*) (("" (expand "singleton") (("" (expand "singleton_elt") (("" (rewrite "the_lem") (("1" (expand "member") (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst 1 "x!1") nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((singleton const-decl "(singleton?)" sets nil) (the_lem formula-decl nil sets nil) (T formal-type-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (singleton_elt const-decl "T" sets nil)) shostak) (singleton_rew-2 "" 3425350586 ("" (skosimp*) (("" (expand "singleton") (("" (expand "singleton_elt") (("" (rewrite "the_lem") (("1" (expand "member") (("1" (use "epsilon_ax[T]") (("1" (prop) (("1" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((singleton const-decl "(singleton?)" sets nil) (the_lem formula-decl nil sets nil) (T formal-type-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (singleton_elt const-decl "T" sets nil)) shostak) (singleton_rew-1 nil 3412878278 ("" (skosimp*) (("" (expand "singleton") (("" (expand "singleton_elt") (("" (expand "the") (("" (expand "member") (("" (use "epsilon_ax[T]") (("" (prop) (("" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (rest_TCC1 0 (rest_TCC1-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (expand "nonempty?") (("" (propax) nil nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil)) nil (rest subtype "sets.a" "(sets.nonempty?)"))) (nonempty_singleton 0 (nonempty_singleton-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (nonempty_singleton subtype "sets.x" "(sets.nonempty?)"))) (nonempty_union1 0 (nonempty_union1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (nonempty_union1 subtype "sets.union(sets.a, sets.b)" "(sets.nonempty?)"))) (nonempty_union2 0 (nonempty_union2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (nonempty_union2 subtype "sets.union(sets.a, sets.b)" "(sets.nonempty?)"))))(sets_lemmas (extensionality 0 (extensionality-1 nil 3237052399 ("" (skolem!) (("" (flatten) (("" (apply-extensionality) (("" (inst?) (("" (expand "member") (("" (iff) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (emptyset_is_empty? 0 (emptyset_is_empty?-1 nil 3237052399 ("" (skolem!) (("" (expand "empty?") (("" (expand "emptyset") (("" (expand "member") (("" (prop) (("1" (apply-extensionality) (("1" (inst?) nil nil)) nil) ("2" (skolem!) (("2" (replace -1) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (FALSE const-decl "bool" booleans nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (emptyset const-decl "set" sets nil)) nil)) (empty_no_members 0 (empty_no_members-1 nil 3237052399 ("" (grind) nil nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (emptyset_min 0 (emptyset_min-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (inst?) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (subset? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (nonempty_member 0 (nonempty_member-1 nil 3237052399 ("" (tcc) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil)) (fullset_member 0 (fullset_member-1 nil 3237052399 ("" (grind) nil nil) ((fullset const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (fullset_max 0 (fullset_max-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (inst?) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)) nil)) (fullset_is_full? 0 (fullset_is_full?-1 nil 3253512686 ("" (grind) (("" (apply-extensionality) (("" (inst?) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (fullset const-decl "set" sets nil) (full? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (nonempty_exists 0 (nonempty_exists-1 nil 3237052399 ("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (split) (("1" (skosimp*) (("1" (inst * "x!1") nil nil)) nil) ("2" (flatten) (("2" (skolem * "x!1") (("2" (inst * "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (a!1 skolem-const-decl "set[T]" sets_lemmas nil) (x!1 skolem-const-decl "T" sets_lemmas nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil)) (subset_emptyset 0 (subset_emptyset-1 nil 3237052399 ("" (grind) nil nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil)) (subset_fullset 0 (subset_fullset-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (fullset const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (subset_reflexive 0 (subset_reflexive-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil)) (subset_antisymmetric 0 (subset_antisymmetric-1 nil 3237052399 ("" (skosimp) (("" (expand "subset?") (("" (expand "member") (("" (apply-extensionality) (("" (inst?) (("" (inst?) (("" (prop) (("1" (iff) (("1" (prop) nil nil)) nil) ("2" (iff) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (subset_transitive 0 (subset_transitive-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil)) (subset_partial_order 0 (subset_partial_order-1 nil 3237052399 ("" (expand "partial_order?") (("" (expand "preorder?") (("" (expand "reflexive?") (("" (prop) (("1" (skosimp) (("1" (expand "subset?") (("1" (expand "member") (("1" (skosimp) nil nil)) nil)) nil)) nil) ("2" (expand "transitive?") (("2" (skosimp) (("2" (expand "subset?") (("2" (skosimp) (("2" (inst?) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "antisymmetric?") (("3" (skosimp) (("3" (expand "subset?") (("3" (apply-extensionality) (("3" (inst?) (("3" (inst?) (("3" (expand "member") (("3" (iff) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (T formal-type-decl nil sets_lemmas nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (antisymmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil)) nil)) (subset_is_partial_order 0 (subset_is_partial_order-1 nil 3253512252 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (partial_order? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil (subset_is_partial_order subtype "sets[sets_lemmas.T].subset?" "(orders[set[T]].partial_order?)"))) (strict_subset_irreflexive 0 (strict_subset_irreflexive-1 nil 3253512777 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (strict_subset? const-decl "bool" sets nil)) nil)) (strict_subset_transitive 0 (strict_subset_transitive-1 nil 3253512783 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (strict_subset? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (strict_subset_strict_order 0 (strict_subset_strict_order-1 nil 3253512806 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (strict_order? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (/= const-decl "boolean" notequal nil) (irreflexive? const-decl "bool" relations nil) (strict_subset? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (strict_subset_is_strict_order 0 (strict_subset_is_strict_order-1 nil 3253512252 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (strict_order? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (/= const-decl "boolean" notequal nil) (irreflexive? const-decl "bool" relations nil) (strict_subset? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil (strict_subset_is_strict_order subtype "sets[sets_lemmas.T].strict_subset?" "(orders[set[T]].strict_order?)"))) (union_idempotent 0 (union_idempotent-1 nil 3237052399 ("" (skosimp) (("" (expand "union") (("" (apply-extensionality) (("" (expand "member") (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (union_commutative 0 (union_commutative-1 nil 3237052399 ("" (skosimp) (("" (expand "union") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (union_associative 0 (union_associative-1 nil 3237052399 ("" (skosimp) (("" (expand "union") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (union_empty 0 (union_empty-1 nil 3237052399 ("" (skosimp) (("" (expand "union") (("" (apply-extensionality) (("" (expand "member") (("" (expand "emptyset") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (union_full 0 (union_full-1 nil 3237052399 ("" (skosimp) (("" (expand "fullset") (("" (expand "union") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((fullset const-decl "set" sets nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (union const-decl "set" sets nil)) nil)) (union_subset1 0 (union_subset1-1 nil 3237052399 ("" (skosimp) (("" (expand "subset?") (("" (expand "union") (("" (skosimp) (("" (expand "member") (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil)) nil)) (union_subset2 0 (union_subset2-1 nil 3237052399 ("" (skosimp) (("" (expand "subset?") (("" (expand "union") (("" (apply-extensionality) (("" (inst?) (("" (iff) (("" (expand "member") (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (union const-decl "set" sets nil)) nil)) (subset_union 0 (subset_union-1 nil 3471679976 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) shostak)) (union_upper_bound 0 (union_upper_bound-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)) nil)) (union_difference 0 (union_difference-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (difference const-decl "set" sets nil) (union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (union_diff_subset 0 (union_diff_subset-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (difference const-decl "set" sets nil) (union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (intersection_idempotent 0 (intersection_idempotent-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (apply-extensionality) (("" (expand "member") (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (intersection_commutative 0 (intersection_commutative-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (intersection_associative 0 (intersection_associative-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (intersection_empty 0 (intersection_empty-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "emptyset") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (FALSE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (emptyset const-decl "set" sets nil)) nil)) (intersection_full 0 (intersection_full-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "fullset") (("" (expand "member") (("" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (fullset const-decl "set" sets nil)) nil)) (intersection_subset1 0 (intersection_subset1-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "subset?") (("" (skosimp) (("" (expand "member") (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil)) (intersection_subset2 0 (intersection_subset2-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "subset?") (("" (apply-extensionality) (("" (expand "member") (("" (inst?) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (subset? const-decl "bool" sets nil)) nil)) (intersection_lower_bound 0 (intersection_lower_bound-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (intersection const-decl "set" sets nil)) nil)) (distribute_intersection_union 0 (distribute_intersection_union-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "union") (("" (expand "member") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil)) nil)) (distribute_union_intersection 0 (distribute_union_intersection-1 nil 3237052399 ("" (skosimp) (("" (expand "intersection") (("" (expand "union") (("" (expand "member") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil)) nil)) (complement_emptyset 0 (complement_emptyset-1 nil 3237052399 ("" (expand "complement") (("" (expand "emptyset") (("" (expand "fullset") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil) (complement const-decl "set" sets nil)) nil)) (complement_fullset 0 (complement_fullset-1 nil 3237052399 ("" (expand "complement") (("" (expand "emptyset") (("" (expand "fullset") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil) (complement const-decl "set" sets nil)) nil)) (complement_complement 0 (complement_complement-1 nil 3237052399 ("" (skosimp) (("" (expand "complement") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((complement const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (complement_equal 0 (complement_equal-1 nil 3253512934 ("" (grind) (("" (apply-extensionality) (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (complement const-decl "set" sets nil)) nil)) (subset_complement 0 (subset_complement-1 nil 3237052399 ("" (skosimp) (("" (expand "complement") (("" (expand "subset?") (("" (expand "member") (("" (prop) (("1" (skosimp) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil) ("2" (skosimp) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complement const-decl "set" sets nil) (member const-decl "bool" sets nil) (T formal-type-decl nil sets_lemmas nil) (subset? const-decl "bool" sets nil)) nil)) (demorgan1 0 (demorgan1-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (iff) (("" (grind) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (intersection const-decl "set" sets nil) (union const-decl "set" sets nil) (complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (demorgan2 0 (demorgan2-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (iff) (("" (grind) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil) (intersection const-decl "set" sets nil) (complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (difference_emptyset1 0 (difference_emptyset1-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "emptyset") (("" (expand "member") (("" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (emptyset const-decl "set" sets nil)) nil)) (difference_emptyset2 0 (difference_emptyset2-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "emptyset") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)) nil)) (difference_fullset1 0 (difference_fullset1-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "emptyset") (("" (expand "fullset") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)) nil)) (difference_fullset2 0 (difference_fullset2-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "fullset") (("" (expand "complement") (("" (apply-extensionality) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (complement const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (fullset const-decl "set" sets nil)) nil)) (difference_intersection 0 (difference_intersection-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "intersection") (("" (expand "complement") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (complement const-decl "set" sets nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil)) nil)) (difference_difference1 0 (difference_difference1-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "member") (("" (expand "union") (("" (expand "member") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (union const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (difference_difference2 0 (difference_difference2-1 nil 3237052399 ("" (skosimp) (("" (expand "difference") (("" (expand "union") (("" (expand "intersection") (("" (expand "member") (("" (apply-extensionality) (("" (iff) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((difference const-decl "set" sets nil) (intersection const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil)) nil)) (difference_subset 0 (difference_subset-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (difference const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (difference_subset2 0 (difference_subset2-1 nil 3253513129 ("" (grind) (("" (apply-extensionality) (("" (flatten) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (difference const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (difference_disjoint 0 (difference_disjoint-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (difference const-decl "set" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)) nil)) (difference_disjoint2 0 (difference_disjoint2-1 nil 3253513146 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (difference const-decl "set" sets nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (diff_union_inter 0 (diff_union_inter-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (intersection const-decl "set" sets nil) (union const-decl "set" sets nil) (difference const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (nonempty_add 0 (nonempty_add-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (empty? const-decl "bool" sets nil)) nil)) (member_add 0 (member_add-1 nil 3237052399 ("" (skosimp*) (("" (expand "add") (("" (apply-extensionality) (("" (hide 2) (("" (iff) (("" (expand "member") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add const-decl "(nonempty?)" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (member_add_reduce 0 (member_add_reduce-1 nil 3471679996 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil)) shostak)) (member_remove 0 (member_remove-1 nil 3237052399 ("" (skosimp*) (("" (apply-extensionality) (("" (hide 3) (("" (expand "remove") (("" (expand "member") (("" (iff) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (add_remove_member 0 (add_remove_member-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil)) nil)) (remove_add_member 0 (remove_add_member-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil)) nil)) (subset_add 0 (subset_add-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil)) nil)) (add_as_union 0 (add_as_union-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (union const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil)) nil)) (singleton_as_add 0 (singleton_as_add-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil)) (subset_remove 0 (subset_remove-1 nil 3237052399 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (remove_as_difference 0 (remove_as_difference-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (difference const-decl "set" sets nil) (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil)) nil)) (remove_member_singleton 0 (remove_member_singleton-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil)) nil)) (choose_rest_TCC1 0 (choose_rest_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (choose_rest subtype "sets_lemmas.a" "(sets[sets_lemmas.T].nonempty?)"))) (choose_rest 0 (choose_rest-1 nil 3237052399 ("" (skosimp*) (("" (apply-extensionality) (("1" (hide 3) (("1" (expand "add") (("1" (hide 2) (("1" (iff) (("1" (split) (("1" (flatten) (("1" (expand "member") (("1" (split) (("1" (assert) nil nil) ("2" (expand "rest") (("2" (expand "remove") (("2" (flatten) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member") (("2" (expand "rest") (("2" (expand "remove") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (propax) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (rest const-decl "set" sets nil) (choose const-decl "(p)" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (choose_member 0 (choose_member-1 nil 3237052399 ("" (grind) (("" (rewrite "epsilon_ax[T]") (("1" (inst?) nil nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil)) (choose_not_member 0 (choose_not_member-1 nil 3237052399 ("" (skosimp*) (("" (expand "member") (("" (expand "rest") (("" (assert) (("" (expand "remove") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (rest const-decl "set" sets nil)) nil)) (rest_not_equal 0 (rest_not_equal-1 nil 3237052399 ("" (skosimp) (("" (expand "rest") (("" (replace 1) (("" (expand "remove") (("" (expand "empty?") (("" (skosimp) (("" (expand "member") (("" (typepred "choose(a!1)") (("1" (replace -3 -1 :dir rl) (("1" (beta) (("1" (flatten) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (remove const-decl "set" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil)) (rest_member 0 (rest_member-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil)) nil)) (rest_subset 0 (rest_subset-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (choose_add 0 (choose_add-1 nil 3237052399 ("" (grind) (("" (typepred " choose(add(x!1, a!1))") (("" (expand "add" -1 1) (("" (expand "member") (("" (expand "choose") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((choose const-decl "(p)" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil)) nil)) (choose_rest_or_TCC1 0 (choose_rest_or_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil) (nonempty? const-decl "bool" sets nil)) nil (choose_rest_or subtype "sets_lemmas.a" "(sets[sets_lemmas.T].nonempty?)"))) (choose_rest_or 0 (choose_rest_or-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil)) nil)) (choose_singleton 0 (choose_singleton-1 nil 3237052399 ("" (skosimp*) (("" (typepred "choose(singleton(x!1))") (("1" (expand "singleton") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ((choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (rest_singleton 0 (rest_singleton-1 nil 3237052399 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (expand "rest") (("" (expand "singleton") (("" (expand "remove") (("" (lift-if) (("" (expand "emptyset") (("" (prop) (("1" (expand "empty?") (("1" (inst -1 "x!1") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "member") (("2" (expand "choose") (("2" (use "epsilon_ax[T]") (("1" (assert) nil nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (epsilon_ax formula-decl nil epsilons nil) (TRUE const-decl "bool" booleans nil) (remove const-decl "set" sets nil)) nil)) (singleton_subset 0 (singleton_subset-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (subset? const-decl "bool" sets nil)) nil)) (rest_empty_lem 0 (rest_empty_lem-1 nil 3237052399 ("" (skosimp*) (("" (expand "extend") (("" (apply-extensionality) (("1" (hide 3) (("1" (lift-if) (("1" (expand "singleton") (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "member") (("1" (split) (("1" (flatten) (("1" (typepred "choose(a!1)") (("1" (inst -4 "x!1") (("1" (expand "rest") (("1" (expand "remove") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "nonempty?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (NOT const-decl "[bool -> bool]" booleans nil) (rest const-decl "set" sets nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (a!1 skolem-const-decl "set[T]" sets_lemmas nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (choose const-decl "(p)" sets nil) (FALSE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (singleton_disjoint 0 (singleton_disjoint-1 nil 3237052399 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)) nil)) (disjoint_remove_left 0 (disjoint_remove_left-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil)) nil)) (disjoint_remove_right 0 (disjoint_remove_right-1 nil 3237052399 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil)) nil)) (union_disj_remove_left 0 (union_disj_remove_left-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (remove const-decl "set" sets nil) (union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (T formal-type-decl nil sets_lemmas nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (union_disj_remove_right 0 (union_disj_remove_right-1 nil 3237052399 ("" (grind) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (remove const-decl "set" sets nil) (union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (T formal-type-decl nil sets_lemmas nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil)) nil)) (subset_powerset 0 (subset_powerset-1 nil 3237053513 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil)) shostak)) (empty_powerset 0 (empty_powerset-1 nil 3237053527 ("" (grind :if-match nil) (("1" (inst 1 "emptyset") (("1" (skolem-typepred) (("1" (grind :if-match nil) (("1" (apply-extensionality) (("1" (inst -2 "x!1") (("1" (inst -3 "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (inst-cp -3 "emptyset") (("1" (inst -3 "a!1") (("1" (replace -3 :hide? t) (("1" (decompose-equality) (("1" (hide -2) (("1" (inst -1 "x!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (emptyset const-decl "set" sets nil) (a!1 skolem-const-decl "set[T]" sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (singleton? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak)) (powerset_emptyset 0 (powerset_emptyset-1 nil 3253513380 ("" (grind) nil nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil)) nil)) (nonempty_powerset 0 (nonempty_powerset-1 nil 3237054070 ("" (grind :if-match nil) (("" (inst -1 "emptyset") (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak (nonempty_powerset subtype "sets[sets_lemmas.T].powerset(sets_lemmas.a)" "(sets[set[T]].nonempty?)"))) (powerset_union 0 (powerset_union-1 nil 3253513413 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (powerset const-decl "setofsets" sets nil) (Union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (a!1 skolem-const-decl "set[T]" sets_lemmas nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil)) nil)) (powerset_intersection 0 (powerset_intersection-2 "" 3342855850 ("" (grind :if-match nil) (("" (inst -1 "emptyset") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ((subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (a!1 skolem-const-decl "set[T]" sets_lemmas nil) (emptyset const-decl "set" sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (subset? const-decl "bool" sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Intersection const-decl "set" sets nil)) shostak) (powerset_intersection-1 nil 3253513443 ("" (grind) (("" (inst -1 "emptyset") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) nil nil)) (powerset_subset 0 (powerset_subset-1 nil 3253513517 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil)) nil)) (Union_empty 0 (Union_empty-1 nil 3253513523 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Union const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (every const-decl "bool" sets nil)) nil)) (Union_full 0 (Union_full-1 nil 3253513528 ("" (grind) nil nil) ((Union const-decl "set" sets nil) (member const-decl "bool" sets nil) (full? const-decl "bool" sets nil)) nil)) (Union_member 0 (Union_member-1 nil 3397714990 ("" (grind) nil nil) ((Union const-decl "set" sets nil) (member const-decl "bool" sets nil)) shostak)) (Union_subset 0 (Union_subset-1 nil 3253513533 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (Union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (Union_surjective 0 (Union_surjective-1 nil 3253512260 ("" (grind) (("" (inst 1 "powerset(y!1)") (("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (Union const-decl "set" sets nil) (y!1 skolem-const-decl "set[T]" sets_lemmas nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (surjective? const-decl "bool" functions nil)) nil (Union_surjective subtype "sets[sets_lemmas.T].Union" "(functions[setofsets[T], set[T]].surjective?)"))) (Union_emptyset_rew 0 (Union_emptyset_rew-1 nil 3397715037 ("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (Union const-decl "set" sets nil) (emptyset const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) shostak)) (Union_union_rew 0 (Union_union_rew-1 nil 3397715067 ("" (skosimp) (("" (apply-extensionality :hide? t) (("" (case "add(choose(A!1), rest(A!1)) = A!1") (("1" (expand "union") (("1" (expand "member") (("1" (iff) (("1" (decompose-equality) (("1" (prop) (("1" (expand "Union" -1) (("1" (skosimp) (("1" (inst -2 "a!1") (("1" (expand "add") (("1" (expand "member") (("1" (prop) (("1" (assert) nil nil) ("2" (expand "Union" 2) (("2" (inst 2 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Union" 1) (("2" (inst 1 "choose(A!1)") nil nil)) nil) ("3" (expand "Union" 1) (("3" (expand "Union") (("3" (skosimp) (("3" (inst 1 "a!1") (("3" (typepred "a!1") (("3" (expand "rest" -1) (("3" (expand "nonempty?") (("3" (assert) (("3" (expand "remove") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "add") (("2" (apply-extensionality :hide? t) (("2" (iff) (("2" (expand "member") (("2" (prop) (("1" (assert) nil nil) ("2" (expand "rest") (("2" (expand "nonempty?") (("2" (assert) (("2" (expand "remove") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "rest") (("3" (expand "nonempty?") (("3" (assert) (("3" (expand "remove") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (rest const-decl "set" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (union const-decl "set" sets nil) (Union const-decl "set" sets nil) (set type-eq-decl nil sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (a!1 skolem-const-decl "(A!1)" sets_lemmas nil) (a!1 skolem-const-decl "(rest(A!1))" sets_lemmas nil) (remove const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (Intersection_empty 0 (Intersection_empty-1 nil 3253513663 ("" (grind) nil nil) ((T formal-type-decl nil sets_lemmas nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil)) (Intersection_full 0 (Intersection_full-1 nil 3253513669 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (full? const-decl "bool" sets nil) (every const-decl "bool" sets nil)) nil)) (Intersection_member 0 (Intersection_member-1 nil 3397715800 ("" (skosimp) (("" (expand "member") (("" (expand "Intersection") (("" (propax) nil nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (Intersection const-decl "set" sets nil)) shostak)) (Intersection_empty_full 0 (Intersection_empty_full-1 nil 3253513675 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil) (Intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (full? const-decl "bool" sets nil)) nil)) (Intersection_surjective 0 (Intersection_surjective-1 nil 3253512260 ("" (grind) (("" (inst 1 "singleton(y!1)") (("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (Intersection const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil)) nil (Intersection_surjective subtype "sets[sets_lemmas.T].Intersection" "(functions[setofsets[T], set[T]].surjective?)"))) (Intersection_intersection_rew 0 (Intersection_intersection_rew-1 nil 3397617277 ("" (skosimp) (("" (case "add(choose(A!1), rest(A!1)) = A!1") (("1" (expand "add") (("1" (expand "member") (("1" (decompose-equality) (("1" (expand "intersection") (("1" (apply-extensionality :hide? t) (("1" (expand "member") (("1" (expand "Intersection" 1 1) (("1" (iff) (("1" (prop) (("1" (inst -1 "choose(A!1)") nil nil) ("2" (expand "Intersection") (("2" (skosimp) (("2" (inst -1 "a!1") (("2" (typepred "a!1") (("2" (expand "rest" -1) (("2" (expand "nonempty?") (("2" (assert) (("2" (expand "remove") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Intersection" -2) (("3" (skosimp) (("3" (inst -3 "a!1") (("3" (assert) (("3" (inst -2 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "add") (("2" (iff) (("2" (prop) (("1" (expand "choose") (("1" (use "epsilon_ax[setof[T]]") (("1" (prop) (("1" (assert) nil nil) ("2" (reveal -3) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skosimp) (("2" (expand "member") (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "rest") (("2" (assert) (("2" (reveal -2) (("2" (expand "nonempty?") (("2" (assert) (("2" (expand "remove") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "member") (("3" (expand "rest") (("3" (assert) (("3" (prop) (("3" (expand "remove") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (choose const-decl "(p)" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (a!1 skolem-const-decl "(rest(A!1))" sets_lemmas nil) (remove const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Intersection const-decl "set" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (empty? const-decl "bool" sets nil)) shostak)) (Complement_empty 0 (Complement_empty-1 nil 3253513724 ("" (grind :if-match nil) (("1" (inst -1 "complement(x!1)") (("1" (inst 1 "x!1") nil nil)) nil) ("2" (inst -3 "b!1") nil nil)) nil) ((complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Complement const-decl "setofsets[T]" sets_lemmas nil)) nil)) (Complement_full 0 (Complement_full-1 nil 3253514020 ("" (grind :if-match nil) (("1" (inst - "complement(x!1)") (("1" (skolem!) (("1" (rewrite "complement_equal") nil nil)) nil)) nil) ("2" (inst - "complement(x!1)") (("2" (inst + "complement(x!1)") (("2" (use "complement_complement[T]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((complement_complement formula-decl nil sets_lemmas nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (x!1 skolem-const-decl "setof[T]" sets_lemmas nil) (T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil) (complement const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (complement_equal formula-decl nil sets_lemmas nil) (full? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Complement const-decl "setofsets[T]" sets_lemmas nil)) nil)) (Complement_Complement 0 (Complement_Complement-1 nil 3253514589 ("" (skolem!) (("" (expand "Complement") (("" (apply-extensionality :hide? t) (("" (smash) (("1" (skosimp* :preds? t) (("1" (use "complement_complement[T]") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "complement(x!1)") (("1" (use "complement_complement[T]") (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((Complement const-decl "setofsets[T]" sets_lemmas nil) (complement_complement formula-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (x!1 skolem-const-decl "[T -> boolean]" sets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (complement const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil)) nil)) (subset_Complement 0 (subset_Complement-1 nil 3253515065 ("" (grind :if-match nil) (("1" (inst - "complement(x!1)") (("1" (split) (("1" (skolem!) (("1" (rewrite "complement_equal") nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("2" (inst - "b!1") (("2" (assert) (("2" (inst + "b!1") nil nil)) nil)) nil)) nil) ((complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (complement_equal formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Complement const-decl "setofsets[T]" sets_lemmas nil)) nil)) (Complement_bijective 0 (Complement_bijective-1 nil 3253512260 ("" (expand* "bijective?" "injective?" "surjective?") (("" (split) (("1" (skosimp) (("1" (lemma "Complement_Complement") (("1" (inst-cp - "x2!1") (("1" (inst - "x1!1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst + "Complement(y!1)") (("2" (use "Complement_Complement") nil nil)) nil)) nil)) nil)) nil) ((Complement_Complement formula-decl nil sets_lemmas nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sets_lemmas nil) (Complement const-decl "setofsets[T]" sets_lemmas nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil)) nil (Complement_bijective subtype "sets_lemmas.Complement" "(functions[setofsets[T], setofsets[T]].bijective?)"))) (Demorgan1 0 (Demorgan1-1 nil 3253515330 ("" (skolem!) (("" (apply-extensionality :hide? t) (("" (grind :if-match nil) (("1" (inst?) nil nil) ("2" (inst - "complement(a!1)") (("1" (expand* "complement" "member") nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (Complement const-decl "setofsets[T]" sets_lemmas nil) (Intersection const-decl "set" sets nil) (Union const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (Complement_bijective name-judgement "(bijective?[setofsets[T], setofsets[T]])" sets_lemmas nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (a!1 skolem-const-decl "(A!1)" sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil)) nil)) (Demorgan2 0 (Demorgan2-1 nil 3253515430 ("" (skolem!) (("" (apply-extensionality :hide? t) (("" (grind :if-match nil) (("1" (inst + "complement(a!1)") (("1" (expand* "complement" "member") nil nil) ("2" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (Complement const-decl "setofsets[T]" sets_lemmas nil) (Union const-decl "set" sets nil) (Intersection const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (Complement_bijective name-judgement "(bijective?[setofsets[T], setofsets[T]])" sets_lemmas nil) (A!1 skolem-const-decl "setofsets[T]" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (a!1 skolem-const-decl "(A!1)" sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil)) nil)))(function_inverse_def (left_inverse_is_inverse 0 (left_inverse_is_inverse-1 nil 3252428734 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (left_inverse? const-decl "bool" function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (left_inj_surj 0 (left_inj_surj-1 nil 3252428739 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (left_inverse? const-decl "bool" function_inverse_def nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil)) shostak)) (inj_left_alt 0 (inj_left_alt-1 nil 3253554040 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (injective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil) (left_inverse? const-decl "bool" function_inverse_def nil)) shostak)) (surj_inv_alt 0 (surj_inv_alt-1 nil 3253554148 ("" (skolem!) (("" (use "inj_left_alt") (("" (use "left_inj_surj") (("" (flatten) nil nil)) nil)) nil)) nil) ((inj_left_alt formula-decl nil function_inverse_def nil) (injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil) (g!1 skolem-const-decl "(LAMBDA (g): inverse?(g, f!1))" function_inverse_def nil) (f!1 skolem-const-decl "(injective?[D, R])" function_inverse_def nil) (left_inverse? const-decl "bool" function_inverse_def nil) (left_inj_surj formula-decl nil function_inverse_def nil)) shostak)) (injective_inverse_alt 0 (injective_inverse_alt-1 nil 3253554196 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (injective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (comp_inverse_left_inj_alt 0 (comp_inverse_left_inj_alt-1 nil 3253554225 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (injective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (noninjective_inverse_exists 0 (noninjective_inverse_exists-1 nil 3252428875 ("" (skosimp) (("" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (expand "injective?") (("2" (skosimp) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon_ax formula-decl nil epsilons nil) (inverse? const-decl "bool" function_inverse_def nil) (injective? const-decl "bool" functions nil)) shostak)) (right_inverse_is_inverse 0 (right_inverse_is_inverse-1 nil 3252429153 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (right_inverse? const-decl "bool" function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (right_surj_inj 0 (right_surj_inj-1 nil 3252429158 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (right_inverse? const-decl "bool" function_inverse_def nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil)) shostak)) (surj_right_alt 0 (surj_right_alt-1 nil 3253554259 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil) (right_inverse? const-decl "bool" function_inverse_def nil)) shostak)) (inj_inv_alt 0 (inj_inv_alt-1 nil 3253554287 ("" (skolem!) (("" (use "surj_right_alt") (("" (use "right_surj_inj") (("" (flatten) nil nil)) nil)) nil)) nil) ((surj_right_alt formula-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil) (g!1 skolem-const-decl "(LAMBDA (g): inverse?(g, f!1))" function_inverse_def nil) (f!1 skolem-const-decl "(surjective?[D, R])" function_inverse_def nil) (right_inverse? const-decl "bool" function_inverse_def nil) (right_surj_inj formula-decl nil function_inverse_def nil)) shostak)) (surjective_inverse_alt 0 (surjective_inverse_alt-1 nil 3253555867 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (comp_inverse_right_surj_alt 0 (comp_inverse_right_surj_alt-1 nil 3253554365 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil)) shostak)) (surjective_inverse_exists 0 (surjective_inverse_exists-1 nil 3252429210 ("" (skolem-typepred) (("" (expand "surjective?") (("" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst - "r!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse? const-decl "bool" function_inverse_def nil) (epsilon_ax formula-decl nil epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (TRUE const-decl "bool" booleans nil) (surjective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (left_right_bij 0 (left_right_bij-1 nil 3252429300 ("" (skosimp) (("" (use "left_inj_surj") (("" (use "right_surj_inj") (("" (expand "bijective?") (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((left_inj_surj formula-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (left_inverse? const-decl "bool" function_inverse_def nil) (g!1 skolem-const-decl "[R -> D]" function_inverse_def nil) (f!1 skolem-const-decl "[D -> R]" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (right_inverse? const-decl "bool" function_inverse_def nil) (right_surj_inj formula-decl nil function_inverse_def nil)) shostak)) (bij_left_right 0 (bij_left_right-1 nil 3252429361 ("" (skolem!) (("" (use "inj_left_alt") (("" (use "surj_right_alt") (("" (assert) nil nil)) nil)) nil)) nil) ((inj_left_alt formula-decl nil function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (surj_right_alt formula-decl nil function_inverse_def nil)) shostak)) (bij_inv_is_bij_alt 0 (bij_inv_is_bij_alt-1 nil 3253554448 ("" (skolem!) (("" (use "surj_inv_alt") (("" (use "inj_inv_alt") (("" (expand "bijective?") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((surj_inv_alt formula-decl nil function_inverse_def nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil) (surjective? const-decl "bool" functions nil) (inj_inv_alt formula-decl nil function_inverse_def nil)) shostak)) (bijective_inverse_alt 0 (bijective_inverse_alt-1 nil 3253554490 ("" (skolem!) (("" (use "injective_inverse_alt") (("" (use "surjective_inverse_alt") (("" (prop) nil nil)) nil)) nil)) nil) ((injective_inverse_alt formula-decl nil function_inverse_def nil) (inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil) (surjective_inverse_alt formula-decl nil function_inverse_def nil)) shostak)) (comp_inverse_right_alt 0 (comp_inverse_right_alt-1 nil 3253556090 ("" (skolem!) (("" (use "comp_inverse_right_surj_alt") nil nil)) nil) ((inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (comp_inverse_right_surj_alt formula-decl nil function_inverse_def nil)) shostak)) (comp_inverse_left_alt 0 (comp_inverse_left_alt-1 nil 3253556119 ("" (skolem!) (("" (use "comp_inverse_left_inj_alt") nil nil)) nil) ((inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (comp_inverse_left_inj_alt formula-decl nil function_inverse_def nil)) shostak)) (bijective_inverse_exists 0 (bijective_inverse_exists-1 nil 3252429536 ("" (skolem-typepred) (("" (expand "exists1") (("" (split) (("1" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (expand* "bijective?" "surjective?") (("2" (skosimp) (("2" (inst - "r!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "unique?") (("2" (skosimp) (("2" (apply-extensionality :hide? t) (("2" (grind :if-match nil) (("2" (inst - "x!2") (("2" (inst - "x!2") (("2" (inst - "x!2") (("2" (skolem!) (("2" (smash) (("1" (inst - "x!1(x!2)" "y!1(x!2)") (("1" (assert) nil nil)) nil) ("2" (inst? +) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exists1 const-decl "bool" exists1 nil) (unique? const-decl "bool" exists1 nil) (injective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon_ax formula-decl nil epsilons nil) (inverse? const-decl "bool" function_inverse_def nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (exists_inv1 0 (exists_inv1-1 nil 3253986702 ("" (prop) (("1" (skosimp*) (("1" (inst 1 "g!1(r!1)") nil nil)) nil) ("2" (skosimp*) (("2" (inst 1 "LAMBDA r: epsilon! d: TRUE") (("2" (skosimp*) (("2" (inst 1 "d!1") nil nil)) nil)) nil)) nil) ("3" (inst 1 "LAMBDA r: epsilon! d: TRUE") (("3" (skosimp*) (("3" (inst -1 "r!1") nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse_def nil) (D formal-type-decl nil function_inverse_def nil)) shostak)) (exists_inv2 0 (exists_inv2-1 nil 3253986940 ("" (prop) (("" (skosimp*) (("" (typepred "f!1") (("" (expand "surjective?") (("" (inst -1 "r!1") (("" (skosimp*) (("" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_def nil) (R formal-type-decl nil function_inverse_def nil) (surjective? const-decl "bool" functions nil)) shostak)) (exists_inv3 0 (exists_inv3-1 nil 3253986970 ("" (prop) (("" (skosimp*) (("" (expand "injective?") (("" (skosimp*) (("" (inst 2 "x1!1") nil nil)) nil)) nil)) nil)) nil) ((D formal-type-decl nil function_inverse_def nil) (injective? const-decl "bool" functions nil)) nil)))(function_inverse (unique_bijective_inverse 0 (unique_bijective_inverse-1 nil 3237052399 ("" (skolem-typepred) (("" (grind :if-match nil) (("" (inst? -2) (("" (skosimp) (("" (replace -2 :dir rl) (("" (use "epsilon_ax[D]") (("" (split) (("1" (propax) nil nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse const-decl "D" function_inverse nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (unique_bijective_inverse subtype "function_inverse.inverse(function_inverse.f)(function_inverse.y)" "{x: function_inverse.D | function_inverse.f(x) = function_inverse.y}"))) (bijective_inverse_is_bijective 0 (bijective_inverse_is_bijective-1 nil 3237052399 ("" (skolem-typepred) (("" (grind :if-match nil) (("1" (inst 1 "f!1(y!1)") (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (split) (("1" (inst? -2) (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (use "epsilon_ax[D]") (("2" (split) (("1" (lemma "epsilon_ax[D]") (("1" (inst -1 "lambda (x: D): f!1(x) = x2!1") (("1" (split) (("1" (assert) nil nil) ("2" (inst -3 "x2!1") nil nil)) nil)) nil)) nil) ("2" (inst -2 "x1!1") nil nil)) nil)) nil)) nil)) nil) ((inverse const-decl "D" function_inverse nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (bijective_inverse_is_bijective subtype "function_inverse.inverse(function_inverse.f)" "(functions[function_inverse.R, function_inverse.D].bijective?)"))) (surjective_inverse 0 (surjective_inverse-1 nil 3253556988 ("" (skosimp) (("" (expand "inverse") (("" (lemma "epsilon_ax[D]") (("" (inst -1 "LAMBDA (x:D): f!1(x) = y!1") (("" (prop) (("1" (replace -2) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "f!1") (("2" (expand "surjective?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse const-decl "D" function_inverse nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (R formal-type-decl nil function_inverse nil) (= const-decl "[T, T -> boolean]" equalities nil) (surjective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (epsilon_ax formula-decl nil epsilons nil) (D formal-nonempty-type-decl nil function_inverse nil)) shostak)) (inverse_surjective 0 (inverse_surjective-1 nil 3299953777 ("" (skosimp) (("" (use "surjective_inverse") (("" (assert) nil nil)) nil)) nil) ((surjective_inverse formula-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (inverse const-decl "D" function_inverse nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil)) shostak)) (injective_inverse 0 (injective_inverse-1 nil 3237052399 ("" (skosimp) (("" (expand "inverse") (("" (typepred "f!1") (("" (expand "injective?") (("" (lemma "epsilon_ax[D]") (("" (inst -1 "LAMBDA (x:D): f!1(x) = y!1") (("" (prop) (("1" (replace -3) (("1" (inst?) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst?) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse const-decl "D" function_inverse nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (epsilon_ax formula-decl nil epsilons nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (injective? const-decl "bool" functions nil)) nil)) (inverse_injective 0 (inverse_injective-1 nil 3299953859 ("" (skosimp) (("" (use "injective_inverse") nil nil)) nil) ((injective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (injective_inverse formula-decl nil function_inverse nil)) shostak)) (bijective_inverse 0 (bijective_inverse-1 nil 3237052399 ("" (skosimp) (("" (split) (("1" (rewrite "surjective_inverse") (("1" (typepred "f!1") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "injective_inverse") (("2" (typepred "f!1") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (surjective_inverse formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (injective_inverse formula-decl nil function_inverse nil)) nil)) (bij_inv_is_bij 0 (bij_inv_is_bij-1 nil 3237052399 ("" (skosimp*) (("" (expand "bijective?") (("" (expand "injective?") (("" (expand "surjective?") (("" (flatten) (("" (split) (("1" (skosimp*) (("1" (lemma "bijective_inverse") (("1" (inst?) (("1" (assert) (("1" (expand "inverse" -1) (("1" (lemma "epsilon_ax[D]") (("1" (inst?) (("1" (split) (("1" (assert) nil nil) ("2" (inst -4 "x2!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (expand "injective?") (("2" (assert) (("2" (replace -2) (("2" (expand "surjective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "f!1(y!1)") (("2" (rewrite "injective_inverse") (("2" (expand "injective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective_inverse formula-decl nil function_inverse nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (inverse const-decl "D" function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (f!1 skolem-const-decl "[D -> R]" function_inverse nil) (injective_inverse formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil)) nil)) (surj_right 0 (surj_right-1 nil 3237052399 ("" (grind) (("" (lemma "epsilon_ax[D]") (("" (inst?) (("" (split) (("1" (propax) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((epsilon_ax formula-decl nil epsilons nil) (R formal-type-decl nil function_inverse nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (right_inverse? const-decl "bool" function_inverse_def nil) (inverse const-decl "D" function_inverse nil) (surjective? const-decl "bool" functions nil)) nil)) (inj_left 0 (inj_left-1 nil 3237052399 ("" (skosimp) (("" (prop) (("1" (grind) (("1" (lemma "epsilon_ax[D]") (("1" (inst?) (("1" (assert) (("1" (inst 1 "d!1") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "left_inverse?") (("2" (expand "inverse") (("2" (expand "injective?") (("2" (skosimp) (("2" (inst-cp -1 "x1!1") (("2" (inst -1 "x2!1") (("2" (assert) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((epsilon_ax formula-decl nil epsilons nil) (D formal-nonempty-type-decl nil function_inverse nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (R formal-type-decl nil function_inverse nil) (= const-decl "[T, T -> boolean]" equalities nil) (left_inverse? const-decl "bool" function_inverse_def nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil)) nil)) (inj_inv 0 (inj_inv-1 nil 3237052399 ("" (skosimp) (("" (expand "surjective?") (("" (expand "injective?") (("" (expand "inverse") (("" (skosimp) (("" (inst-cp -1 "x1!1") (("" (inst -1 "x2!1") (("" (skosimp) (("" (skosimp) (("" (lemma "epsilon_ax[D]") (("" (inst-cp -1 "LAMBDA (x:D): f!1(x)=x1!1") (("" (inst -1 "LAMBDA (x:D): f!1(x)=x2!1") (("" (prop) (("1" (replace -5) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst?) nil nil) ("3" (inst?) nil nil) ("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil) (R formal-type-decl nil function_inverse nil) (epsilon_ax formula-decl nil epsilons nil) (D formal-nonempty-type-decl nil function_inverse nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil)) nil)) (surj_inv 0 (surj_inv-1 nil 3237052399 ("" (skosimp) (("" (expand "surjective?") (("" (expand "injective?") (("" (skosimp) (("" (expand "inverse") (("" (inst -1 "y!1" _) (("" (inst 1 "f!1(y!1)") (("" (inst -1 "(epsilon ! (x_5: D): f!1(x_5) = f!1(y!1))") (("" (prop) (("1" (replace -1) (("1" (replace -1 :dir rl) (("1" (replace -1 :dir rl) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "epsilon_ax[D]") (("2" (inst?) (("2" (prop) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (inst 1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective? const-decl "bool" functions nil) (D formal-nonempty-type-decl nil function_inverse nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon_ax formula-decl nil epsilons nil) (R formal-type-decl nil function_inverse nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil)) nil)) (inv_inj_is_surj 0 (inv_inj_is_surj-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "f!1(y!1)") (("" (inst? -1) (("" (assert) (("" (lemma "epsilon_ax[D]") (("" (inst?) (("" (assert) (("" (inst 1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((epsilon_ax formula-decl nil epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil)) nil (inv_inj_is_surj subtype "function_inverse.inverse(function_inverse.f)" "(functions[function_inverse.R, function_inverse.D].surjective?)"))) (inv_surj_is_inj 0 (inv_surj_is_inj-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst-cp -1 "x1!1") (("" (inst -1 "x2!1") (("" (skosimp*) (("" (lemma "epsilon_ax[D]") (("" (lemma "epsilon_ax[D]") (("" (inst?) (("" (inst -2 "LAMBDA (x: D): f!1(x) = x2!1") (("" (assert) (("" (prop) (("1" (assert) nil nil) ("2" (inst 1 "x!1") nil nil) ("3" (inst 1 "x!2") nil nil) ("4" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon_ax formula-decl nil epsilons nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil)) nil (inv_surj_is_inj subtype "function_inverse.inverse(function_inverse.f)" "(functions[function_inverse.R, function_inverse.D].injective?)"))) (comp_inverse_right_surj 0 (comp_inverse_right_surj-1 nil 3237052399 ("" (grind :if-match nil) (("" (use "epsilon_ax[D]") (("" (assert) (("" (inst? -1) nil nil)) nil)) nil)) nil) ((epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil)) nil)) (comp_inverse_left_inj 0 (comp_inverse_left_inj-1 nil 3237052399 ("" (grind :if-match nil) (("" (use "epsilon_ax[D]") (("" (split) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ((epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-nonempty-type-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil)) nil)) (comp_inverse_right 0 (comp_inverse_right-1 nil 3237052399 ("" (skosimp) (("" (lemma "comp_inverse_right_surj") (("" (inst?) (("" (typepred "f!1") (("" (expand "bijective?") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((comp_inverse_right_surj formula-decl nil function_inverse nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) nil)) (comp_inverse_left 0 (comp_inverse_left-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "bijective?") (("" (lemma "comp_inverse_left_inj") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (comp_inverse_left_inj formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse nil) (D formal-nonempty-type-decl nil function_inverse nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)))(function_inverse_alt (inverses_TCC1 0 (inverses_TCC1-1 nil 3252433331 ("" (skolem!) (("" (lemma "inverse_types") (("" (split) (("1" (skolem!) (("1" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst + "d!1") nil nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (r: R): epsilon[D](LAMBDA (d: D): TRUE)") (("1" (grind) nil nil) ("2" (skolem!) (("2" (inst -1 "r!1") nil nil)) nil)) nil) ("3" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "g!1(r!1)") nil nil)) nil)) nil) ("4" (skolem-typepred) (("4" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skolem!) (("2" (inst - "r!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "injective?") (("5" (skosimp*) (("5" (inst + "LAMBDA r: (epsilon! d: f!1(d) = r)") (("1" (expand "inverse?") (("1" (skosimp*) (("1" (use "epsilon_ax[D]") (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse_types formula-decl nil function_inverse_alt nil) (epsilon_ax formula-decl nil epsilons nil) (f!1 skolem-const-decl "[D -> R]" function_inverse_alt nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (inverse? const-decl "bool" function_inverse_def nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_inverse_alt nil) (R formal-type-decl nil function_inverse_alt nil)) shostak (inverses existence "" "{g | function_inverse_def[function_inverse_alt.D, function_inverse_alt.R].inverse?(g, function_inverse_alt.f)}"))) (inverse_alt_TCC1 0 (inverse_alt_TCC1-1 nil 3252433785 ("" (grind) nil nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) shostak (inverse_alt subtype "{g: function_inverse_alt.inverses(function_inverse_alt.f) | booleans.TRUE}" "(sets[function_inverse_alt.inverses(function_inverse_alt.f)].nonempty?)"))) (bijective_inverse_is_inverse_alt 0 (bijective_inverse_is_inverse_alt-1 nil 3252433810 ("" (skolem!) (("" (typepred "inverse_alt(f!1)") (("" (expand "inverse?") (("" (typepred "g!1") (("" (expand "inverse?") (("" (apply-extensionality :hide? t) (("" (inst -1 "x!1") (("" (inst -2 "x!1") (("" (typepred "f!1") (("" (prop) (("1" (expand "bijective?") (("1" (flatten) (("1" (expand "injective?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "g!1(x!1)") nil nil) ("3" (inst 1 "inverse_alt(f!1)(x!1)") nil nil) ("4" (expand "bijective?") (("4" (flatten) (("4" (expand "surjective?") (("4" (inst -2 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (inverse_alt const-decl "inverses(f)" function_inverse_alt nil) (inverses nonempty-type-eq-decl nil function_inverse_alt nil) (inverse? const-decl "bool" function_inverse_def nil) (D formal-type-decl nil function_inverse_alt nil) (R formal-type-decl nil function_inverse_alt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil)) shostak)) (unique_bijective_inverse_alt 0 (unique_bijective_inverse_alt-1 nil 3252311738 ("" (skolem-typepred) (("" (typepred "inverse_alt(f!1)") (("" (expand* "inverse?" "bijective?" "surjective?") (("" (inst - "r!1") (("" (smash) (("" (inst - "r!1") nil nil)) nil)) nil)) nil)) nil)) nil) ((inverse_alt const-decl "inverses(f)" function_inverse_alt nil) (inverses nonempty-type-eq-decl nil function_inverse_alt nil) (inverse? const-decl "bool" function_inverse_def nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse_alt nil) (D formal-type-decl nil function_inverse_alt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (unique_bijective_inverse_alt subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)(function_inverse_alt.r)" "{d | function_inverse_alt.f(function_inverse_alt.d) = function_inverse_alt.r}"))) (bijective_inverse_alt_is_bijective 0 (bijective_inverse_alt_is_bijective-1 nil 3252311739 ("" (skolem-typepred) (("" (typepred "inverse_alt(f!1)") (("" (expand* "inverse?" "bijective?" "surjective?" "injective?") (("" (prop) (("1" (skosimp) (("1" (inst-cp - "x2!1") (("1" (inst - "x1!1") (("1" (smash) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst + "f!1(y!1)") (("2" (inst - "f!1(y!1)") (("2" (prop) (("1" (inst - "inverse_alt(f!1)(f!1(y!1))" "y!1") (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse_alt const-decl "inverses(f)" function_inverse_alt nil) (inverses nonempty-type-eq-decl nil function_inverse_alt nil) (inverse? const-decl "bool" function_inverse_def nil) (unique_bijective_inverse_alt application-judgement "{d | f(d) = r}" function_inverse_alt nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (R formal-type-decl nil function_inverse_alt nil) (D formal-type-decl nil function_inverse_alt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (bijective_inverse_alt_is_bijective subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)" "(functions[function_inverse_alt.R, function_inverse_alt.D].bijective?)"))) (inv_inj_is_surj_alt 0 (inv_inj_is_surj_alt-2 "" 3458163851 ("" (grind :if-match nil) (("" (inst 1 "f!1(y!1)") (("" (name-replace "gg" "choose({g: inverses(f!1) | TRUE})") (("" (typepred "gg") (("" (expand "inverse?") (("" (inst -1 "f!1(y!1)") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst 1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (choose const-decl "(p)" sets nil) (set type-eq-decl nil sets nil) (inverses nonempty-type-eq-decl nil function_inverse_alt nil) (inverse? const-decl "bool" function_inverse_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_alt nil) (R formal-type-decl nil function_inverse_alt nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inverse_alt const-decl "inverses(f)" function_inverse_alt nil)) shostak (inv_inj_is_surj_alt subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)" "(functions[function_inverse_alt.R, function_inverse_alt.D].surjective?)")) (inv_inj_is_surj_alt-1 nil 3252311739 ("" (grind :if-match nil) (("" (inst 1 "f!1(y!1)") (("" (name-replace "gg" "epsilon({g: inverses(f!1) | TRUE})") (("" (typepred "gg") (("" (expand "inverse?") (("" (inst -1 "f!1(y!1)") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst 1 "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (inv_inj_is_surj_alt subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)" "(functions[function_inverse_alt.R, function_inverse_alt.D].surjective?)"))) (inv_surj_is_inj_alt 0 (inv_surj_is_inj_alt-2 "" 3458163883 ("" (grind :if-match nil) (("" (name-replace "gg" "choose({g: inverses(f!1) | TRUE})") (("" (typepred "gg") (("" (expand "inverse?") (("" (assert) (("" (inst-cp -2 "x1!1") (("" (inst -2 "x2!1") (("" (inst-cp -1 "x1!1") (("" (inst -1 "x2!1") (("" (assert) (("" (replace -3) (("" (replace -4) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (inverse? const-decl "bool" function_inverse_def nil) (inverses nonempty-type-eq-decl nil function_inverse_alt nil) (set type-eq-decl nil sets nil) (choose const-decl "(p)" sets nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_inverse_alt nil) (R formal-type-decl nil function_inverse_alt nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (inverse_alt const-decl "inverses(f)" function_inverse_alt nil)) shostak (inv_surj_is_inj_alt subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)" "(functions[function_inverse_alt.R, function_inverse_alt.D].injective?)")) (inv_surj_is_inj_alt-1 nil 3252311739 ("" (grind :if-match nil) (("" (name-replace "gg" "epsilon({g: inverses(f!1) | TRUE})") (("" (typepred "gg") (("" (expand "inverse?") (("" (assert) (("" (inst-cp -2 "x1!1") (("" (inst -2 "x2!1") (("" (inst-cp -1 "x1!1") (("" (inst -1 "x2!1") (("" (assert) (("" (replace -3) (("" (replace -4) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (inv_surj_is_inj_alt subtype "function_inverse_alt.inverse_alt(function_inverse_alt.f)" "(functions[function_inverse_alt.R, function_inverse_alt.D].injective?)"))))(function_image (fun_exists 0 (fun_exists-1 nil 3237052399 ("" (flatten) (("" (split) (("1" (skosimp) (("1" (inst 1 "LAMBDA (x:D): y!1") nil nil)) nil) ("2" (inst 2 "LAMBDA (x:D): epsilon! (y:R): TRUE") (("2" (skolem-typepred) (("2" (inst 2 "x!1") nil nil)) nil)) nil)) nil)) nil) ((D formal-type-decl nil function_image nil) (R formal-type-decl nil function_image nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (image_inverse_image 0 (image_inverse_image-1 nil 3237052399 ("" (grind) nil nil) ((inverse_image const-decl "set[D]" function_image nil) (set type-eq-decl nil sets nil) (R formal-type-decl nil function_image nil) (D formal-type-decl nil function_image nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (image const-decl "set[R]" function_image nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil)) (inverse_image_image 0 (inverse_image_image-1 nil 3237052399 ("" (grind) nil nil) ((D formal-type-decl nil function_image nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (image const-decl "set[R]" function_image nil) (inverse_image const-decl "set[D]" function_image nil) (subset? const-decl "bool" sets nil)) nil)) (image_subset 0 (image_subset-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (D formal-type-decl nil function_image nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (image const-decl "set[R]" function_image nil)) nil)) (inverse_image_subset 0 (inverse_image_subset-1 nil 3237052399 ("" (grind) nil nil) ((D formal-type-decl nil function_image nil) (R formal-type-decl nil function_image nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (inverse_image const-decl "set[D]" function_image nil)) nil)) (image_union 0 (image_union-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (iff) (("" (grind) nil nil)) nil)) nil)) nil) ((R formal-type-decl nil function_image nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil) (image const-decl "set[R]" function_image nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (D formal-type-decl nil function_image nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!2 skolem-const-decl "(union(X1!1, X2!1))" function_image nil) (X2!1 skolem-const-decl "set[D]" function_image nil) (X1!1 skolem-const-decl "set[D]" function_image nil)) nil)) (image_intersection 0 (image_intersection-1 nil 3237052399 ("" (grind) nil nil) ((X2!1 skolem-const-decl "set[D]" function_image nil) (X1!1 skolem-const-decl "set[D]" function_image nil) (x!2 skolem-const-decl "(intersection(X1!1, X2!1))" function_image nil) (set type-eq-decl nil sets nil) (D formal-type-decl nil function_image nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (image const-decl "set[R]" function_image nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil)) (inverse_image_union 0 (inverse_image_union-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_image nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (inverse_image const-decl "set[D]" function_image nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (R formal-type-decl nil function_image nil)) nil)) (inverse_image_intersection 0 (inverse_image_intersection-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_image nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (inverse_image const-decl "set[D]" function_image nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (R formal-type-decl nil function_image nil)) nil)) (inverse_image_complement 0 (inverse_image_complement-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (D formal-type-decl nil function_image nil) (member const-decl "bool" sets nil) (complement const-decl "set" sets nil) (inverse_image const-decl "set[D]" function_image nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (R formal-type-decl nil function_image nil)) nil)))(function_props (composition_injective 0 (composition_injective-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil function_props nil) (T2 formal-type-decl nil function_props nil) (T3 formal-type-decl nil function_props nil) (O const-decl "T3" function_props nil) (injective? const-decl "bool" functions nil)) nil (composition_injective subtype "function_props.o(function_props.f2, function_props.f1)" "(functions[function_props.T1, function_props.T3].injective?)"))) (composition_surjective 0 (composition_surjective-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil function_props nil) (T2 formal-type-decl nil function_props nil) (T3 formal-type-decl nil function_props nil) (O const-decl "T3" function_props nil) (surjective? const-decl "bool" functions nil)) nil (composition_surjective subtype "function_props.o(function_props.f2, function_props.f1)" "(functions[function_props.T1, function_props.T3].surjective?)"))) (composition_bijective 0 (composition_bijective-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((composition_surjective application-judgement "(surjective?[T1, T3])" function_props nil) (composition_injective application-judgement "(injective?[T1, T3])" function_props nil) (bijective? const-decl "bool" functions nil)) nil (composition_bijective subtype "function_props.o(function_props.f2, function_props.f1)" "(functions[function_props.T1, function_props.T3].bijective?)"))) (image_composition 0 (image_composition-1 nil 3237052399 ("" (grind) (("" (apply-extensionality) (("" (grind) nil nil)) nil)) nil) ((T3 formal-type-decl nil function_props nil) (boolean nonempty-type-decl nil booleans nil) (O const-decl "T3" function_props nil) (T1 formal-type-decl nil function_props nil) (image const-decl "set[R]" function_image nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (T2 formal-type-decl nil function_props nil) (x!2 skolem-const-decl "(X!1)" function_props nil) (f1!1 skolem-const-decl "[T1 -> T2]" function_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (X!1 skolem-const-decl "set[T1]" function_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (preserves_composition 0 (preserves_composition-1 nil 3237052399 ("" (grind) nil nil) ((T1 formal-type-decl nil function_props nil) (T2 formal-type-decl nil function_props nil) (preserves const-decl "bool" functions nil) (O const-decl "T3" function_props nil)) nil)) (inverts_composition1 0 (inverts_composition1-1 nil 3237052399 ("" (grind) nil nil) ((T1 formal-type-decl nil function_props nil) (T2 formal-type-decl nil function_props nil) (preserves const-decl "bool" functions nil) (inverts const-decl "bool" functions nil) (O const-decl "T3" function_props nil)) nil)) (inverts_composition2 0 (inverts_composition2-1 nil 3237052399 ("" (grind) nil nil) ((T1 formal-type-decl nil function_props nil) (T2 formal-type-decl nil function_props nil) (inverts const-decl "bool" functions nil) (preserves const-decl "bool" functions nil) (O const-decl "T3" function_props nil)) nil)))(function_props_alt (composition_preserves 0 (composition_preserves-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil function_props_alt nil) (T2 formal-type-decl nil function_props_alt nil) (PRED type-eq-decl nil defined_types nil) (R1 formal-const-decl "PRED[[T1, T1]]" function_props_alt nil) (R2 formal-const-decl "PRED[[T2, T2]]" function_props_alt nil) (T3 formal-type-decl nil function_props_alt nil) (R3 formal-const-decl "PRED[[T3, T3]]" function_props_alt nil) (preserves const-decl "[[D -> R] -> bool]" functions_alt nil) (O const-decl "T3" function_props nil) (preserves const-decl "bool" functions nil) (preserves const-decl "bool" functions nil)) nil (composition_preserves subtype "function_props[function_props_alt.T1, function_props_alt.T2, function_props_alt.T3].o(function_props_alt.f2, function_props_alt.f1)" "(functions_alt[function_props_alt.T1, function_props_alt.T3, function_props_alt.R1, function_props_alt.R3].preserves)"))) (composition_inverts1 0 (composition_inverts1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil function_props_alt nil) (T2 formal-type-decl nil function_props_alt nil) (PRED type-eq-decl nil defined_types nil) (R1 formal-const-decl "PRED[[T1, T1]]" function_props_alt nil) (R2 formal-const-decl "PRED[[T2, T2]]" function_props_alt nil) (T3 formal-type-decl nil function_props_alt nil) (R3 formal-const-decl "PRED[[T3, T3]]" function_props_alt nil) (preserves const-decl "[[D -> R] -> bool]" functions_alt nil) (preserves const-decl "bool" functions nil) (preserves const-decl "bool" functions nil) (inverts const-decl "[[D -> R] -> bool]" functions_alt nil) (O const-decl "T3" function_props nil) (inverts const-decl "bool" functions nil) (inverts const-decl "bool" functions nil)) nil (composition_inverts1 subtype "function_props[function_props_alt.T1, function_props_alt.T2, function_props_alt.T3].o(function_props_alt.f2, function_props_alt.f1)" "(functions_alt[function_props_alt.T1, function_props_alt.T3, function_props_alt.R1, function_props_alt.R3].inverts)"))) (composition_inverts2 0 (composition_inverts2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil function_props_alt nil) (T2 formal-type-decl nil function_props_alt nil) (PRED type-eq-decl nil defined_types nil) (R1 formal-const-decl "PRED[[T1, T1]]" function_props_alt nil) (R2 formal-const-decl "PRED[[T2, T2]]" function_props_alt nil) (preserves const-decl "[[D -> R] -> bool]" functions_alt nil) (T3 formal-type-decl nil function_props_alt nil) (R3 formal-const-decl "PRED[[T3, T3]]" function_props_alt nil) (preserves const-decl "bool" functions nil) (preserves const-decl "bool" functions nil) (inverts const-decl "[[D -> R] -> bool]" functions_alt nil) (O const-decl "T3" function_props nil) (inverts const-decl "bool" functions nil) (inverts const-decl "bool" functions nil)) nil (composition_inverts2 subtype "function_props[function_props_alt.T1, function_props_alt.T2, function_props_alt.T3].o(function_props_alt.f2, function_props_alt.f1)" "(functions_alt[function_props_alt.T1, function_props_alt.T3, function_props_alt.R1, function_props_alt.R3].inverts)"))))(function_props2 (assoc 0 (assoc-1 nil 3237052399 ("" (skolem 1 ("f!1" "g!1" "h!1")) (("" (expand "o") (("" (propax) nil nil)) nil)) nil) ((O const-decl "T3" function_props nil)) nil)))(relation_defs)(relation_props (total_composition 0 (total_composition-1 nil 3237052399 ("" (grind) nil nil) ((T2 formal-type-decl nil relation_props nil) (T3 formal-type-decl nil relation_props nil) (T1 formal-type-decl nil relation_props nil) (total? const-decl "bool" relation_defs nil) (O const-decl "bool" relation_props nil)) nil)) (onto_composition 0 (onto_composition-1 nil 3237052399 ("" (grind) nil nil) ((T2 formal-type-decl nil relation_props nil) (T1 formal-type-decl nil relation_props nil) (T3 formal-type-decl nil relation_props nil) (onto? const-decl "bool" relation_defs nil) (O const-decl "bool" relation_props nil)) nil)) (composition_total 0 (composition_total-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil relation_props nil) (T2 formal-type-decl nil relation_props nil) (pred type-eq-decl nil defined_types nil) (T3 formal-type-decl nil relation_props nil) (O const-decl "bool" relation_props nil) (total? const-decl "bool" relation_defs nil)) nil (composition_total subtype "relation_props.o(relation_props.R1, relation_props.R2)" "(relation_defs[relation_props.T1, relation_props.T3].total?)"))) (composition_onto 0 (composition_onto-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-type-decl nil relation_props nil) (T2 formal-type-decl nil relation_props nil) (pred type-eq-decl nil defined_types nil) (T3 formal-type-decl nil relation_props nil) (O const-decl "bool" relation_props nil) (onto? const-decl "bool" relation_defs nil)) nil (composition_onto subtype "relation_props.o(relation_props.R1, relation_props.R2)" "(relation_defs[relation_props.T1, relation_props.T3].onto?)"))))(relation_props2 (assoc 0 (assoc-1 nil 3237052399 ("" (skosimp) (("" (apply-extensionality) (("" (hide 2) (("" (expand "o") (("" (iff) (("" (prop) (("1" (skosimp) (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T1 formal-type-decl nil relation_props2 nil) (T4 formal-type-decl nil relation_props2 nil) (boolean nonempty-type-decl nil booleans nil) (T2 formal-type-decl nil relation_props2 nil) (O const-decl "bool" relation_props nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (T3 formal-type-decl nil relation_props2 nil)) nil)))(relation_converse_props (reflexive_converse 0 (reflexive_converse-1 nil 3249387244 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (PRED type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (reflexive? const-decl "bool" relations nil)) shostak (reflexive_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].reflexive?)"))) (irreflexive_converse 0 (irreflexive_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (PRED type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (irreflexive? const-decl "bool" relations nil)) shostak (irreflexive_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].irreflexive?)"))) (symmetric_converse 0 (symmetric_converse-1 nil 3249387255 ("" (skolem-typepred) (("" (expand* "converse" "symmetric?") (("" (skosimp) (("" (inst - "y!1" "x!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((converse const-decl "pred[[T2, T1]]" relation_defs nil) (symmetric? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil relation_converse_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (symmetric_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].symmetric?)"))) (antisymmetric_converse 0 (antisymmetric_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (PRED type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (antisymmetric? const-decl "bool" relations nil)) shostak (antisymmetric_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].antisymmetric?)"))) (connected_converse 0 (connected_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (PRED type-eq-decl nil defined_types nil) (/= const-decl "boolean" notequal nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (connected? const-decl "bool" relations nil)) shostak (connected_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].connected?)"))) (transitive_converse 0 (transitive_converse-1 nil 3249387255 ("" (skolem-typepred) (("" (expand* "converse" "transitive?") (("" (skosimp) (("" (inst - "z!1" "y!1" "x!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((converse const-decl "pred[[T2, T1]]" relation_defs nil) (transitive? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil relation_converse_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (transitive_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].transitive?)"))) (equivalence_converse 0 (equivalence_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((symmetric_converse application-judgement "(symmetric?[T])" relation_converse_props nil) (transitive_converse application-judgement "(transitive?[T])" relation_converse_props nil) (reflexive_converse application-judgement "(reflexive?[T])" relation_converse_props nil) (equivalence? const-decl "bool" relations nil)) shostak (equivalence_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(relations[relation_converse_props.T].equivalence?)"))) (preorder_converse 0 (preorder_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((transitive_converse application-judgement "(transitive?[T])" relation_converse_props nil) (reflexive_converse application-judgement "(reflexive?[T])" relation_converse_props nil) (preorder? const-decl "bool" orders nil)) shostak (preorder_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].preorder?)"))) (partial_order_converse 0 (partial_order_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((preorder_converse application-judgement "(preorder?[T])" relation_converse_props nil) (antisymmetric_converse application-judgement "(antisymmetric?[T])" relation_converse_props nil) (partial_order? const-decl "bool" orders nil)) shostak (partial_order_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].partial_order?)"))) (strict_order_converse 0 (strict_order_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((antisymmetric_converse application-judgement "(antisymmetric?[T])" relation_converse_props nil) (transitive_converse application-judgement "(transitive?[T])" relation_converse_props nil) (irreflexive_converse application-judgement "(irreflexive?[T])" relation_converse_props nil) (strict_order? const-decl "bool" orders nil)) shostak (strict_order_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].strict_order?)"))) (dichotomous_converse 0 (dichotomous_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (dichotomous? const-decl "bool" orders nil)) shostak (dichotomous_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].dichotomous?)"))) (total_order_converse 0 (total_order_converse-1 nil 3249387255 ("" (subtype-tcc) nil nil) ((dichotomous_converse application-judgement "(dichotomous?[T])" relation_converse_props nil) (partial_order_converse application-judgement "(partial_order?[T])" relation_converse_props nil) (total_order? const-decl "bool" orders nil)) shostak (total_order_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].total_order?)"))) (trichotomous_converse 0 (trichotomous_converse-1 nil 3249387256 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil relation_converse_props nil) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (trichotomous? const-decl "bool" orders nil)) shostak (trichotomous_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].trichotomous?)"))) (strict_total_order_converse 0 (strict_total_order_converse-1 nil 3249387256 ("" (subtype-tcc) nil nil) ((trichotomous_converse application-judgement "(trichotomous?[T])" relation_converse_props nil) (strict_order_converse application-judgement "(strict_order?[T])" relation_converse_props nil) (strict_total_order? const-decl "bool" orders nil)) shostak (strict_total_order_converse subtype "relation_defs[relation_converse_props.T, relation_converse_props.T].converse(relation_converse_props.R)" "(orders[relation_converse_props.T].strict_total_order?)"))))(indexed_sets (IUnion_Union 0 (IUnion_Union-1 nil 3237054186 ("" (grind) (("" (apply-extensionality :hide? t) (("" (iff) (("" (prop) (("1" (skolem-typepred) (("1" (inst 1 "A!1(i!1)") (("1" (inst 1 "i!1") nil nil)) nil)) nil) ("2" (skolem-typepred) (("2" (grind :if-match nil) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (fullset const-decl "set" sets nil) (image const-decl "set[R]" function_image nil) (Union const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (IUnion const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (A!1 skolem-const-decl "[index -> set[T]]" indexed_sets nil) (i!1 skolem-const-decl "index" indexed_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (image const-decl "set[R]" function_image nil)) shostak)) (IIntersection_Intersection 0 (IIntersection_Intersection-1 nil 3237054338 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) (("" (iff) (("" (prop) (("1" (skolem-typepred) (("1" (grind :if-match nil) (("1" (inst - "x!2") nil nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -1 "A!1(i!1)") (("2" (inst 1 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (fullset const-decl "set" sets nil) (image const-decl "set[R]" function_image nil) (Intersection const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (IIntersection const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (A!1 skolem-const-decl "[index -> set[T]]" indexed_sets nil) (i!1 skolem-const-decl "index" indexed_sets nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (image const-decl "set[R]" function_image nil)) shostak)) (IUnion_union 0 (IUnion_union-1 nil 3237054431 ("" (skolem-typepred) (("" (apply-extensionality :hide? t) (("" (iff) (("" (grind :if-match nil) (("1" (inst 1 "i!1") nil nil) ("2" (inst 2 "i!1") nil nil) ("3" (inst 1 "i!1") (("3" (assert) nil nil)) nil) ("4" (inst 1 "i!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (member const-decl "bool" sets nil)) shostak)) (IIntersection_intersection 0 (IIntersection_intersection-1 nil 3237054514 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) (("" (grind :if-match nil) (("1" (inst -1 "i!1") (("1" (assert) nil nil)) nil) ("2" (inst -1 "i!1") (("2" (assert) nil nil)) nil) ("3" (inst -2 "i!1") nil nil) ("4" (inst -1 "i!1") nil nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (intersection const-decl "set" sets nil) (IIntersection const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (member const-decl "bool" sets nil)) shostak)) (IUnion_intersection 0 (IUnion_intersection-1 nil 3237054595 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) (("" (grind :if-match nil) (("" (inst 1 "i!1") nil nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (intersection const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (member const-decl "bool" sets nil)) shostak)) (IIntersection_union 0 (IIntersection_union-1 nil 3237054623 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) (("" (grind :if-match nil) (("" (inst?) nil nil)) nil)) nil)) nil) ((T formal-type-decl nil indexed_sets nil) (boolean nonempty-type-decl nil booleans nil) (union const-decl "set" sets nil) (IIntersection const-decl "set[T]" indexed_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (index formal-type-decl nil indexed_sets nil) (member const-decl "bool" sets nil)) shostak)))(operator_defs)(numbers)(number_fields (commutative_add 0 (commutative_add-1 nil 3242535784 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)) (associative_add 0 (associative_add-1 nil 3242535799 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)) (identity_add 0 (identity_add-1 nil 3242535806 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)) (inverse_add 0 (inverse_add-1 nil 3242535812 ("" (skosimp) (("" (assert) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak)) (minus_add 0 (minus_add-1 nil 3242537058 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (commutative_mult 0 (commutative_mult-1 nil 3242536887 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (associative_mult 0 (associative_mult-1 nil 3242536707 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (identity_mult 0 (identity_mult-1 nil 3242537143 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (inverse_mult 0 (inverse_mult-1 nil 3242537160 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (div_def 0 (div_def-1 nil 3242537180 ("" (skosimp) (("" (assert) (("" (postpone) nil nil)) nil)) nil) nil shostak)) (distributive 0 (distributive-1 nil 3242537198 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)))(reals (real_plus_real_is_real 0 (real_plus_real_is_real-1 nil 3242538128 ("" (lemma "closed_plus") (("" (propax) nil nil)) nil) ((closed_plus formula-decl nil reals nil)) shostak (real_plus_real_is_real subtype "(number_fields.+)(reals.x, reals.y)" "real"))) (real_minus_real_is_real 0 (real_minus_real_is_real-1 nil 3242538153 ("" (lemma "closed_minus") (("" (propax) nil nil)) nil) ((closed_minus formula-decl nil reals nil)) shostak (real_minus_real_is_real subtype "(number_fields.-)(reals.x, reals.y)" "real"))) (real_times_real_is_real 0 (real_times_real_is_real-1 nil 3242538163 ("" (lemma "closed_times") (("" (propax) nil nil)) nil) ((closed_times formula-decl nil reals nil)) shostak (real_times_real_is_real subtype "number_fields.*(reals.x, reals.y)" "real"))) (real_div_nzreal_is_real 0 (real_div_nzreal_is_real-1 nil 3242538175 ("" (lemma "closed_divides") (("" (propax) nil nil)) nil) ((closed_divides formula-decl nil reals nil)) shostak (real_div_nzreal_is_real subtype "number_fields./(reals.x, reals.n0z)" "real"))) (minus_real_is_real 0 (minus_real_is_real-1 nil 3242538196 ("" (lemma "closed_neg") (("" (propax) nil nil)) nil) ((closed_neg formula-decl nil reals nil)) shostak (minus_real_is_real subtype "(number_fields.-)(reals.x)" "real"))) (reals_totally_ordered 0 (reals_totally_ordered-1 nil 3237052399 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (trichotomous? const-decl "bool" orders nil) (strict_total_order? const-decl "bool" orders nil)) nil)))(real_axioms (posreal_add_closed 0 (posreal_add_closed-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (posreal_neg 0 (posreal_neg-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (trichotomy 0 (trichotomy-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)))(bounded_real_defs (real_lower_complete 0 (real_lower_complete-1 nil 3237052399 ("" (lemma "real_complete") (("" (skosimp) (("" (inst -1 "{x: real | S!1(-x)}") (("1" (skosimp) (("1" (split) (("1" (skosimp) (("1" (expand "least_upper_bound?") (("1" (inst 1 "-y!2") (("1" (expand "greatest_lower_bound?") (("1" (hide -2) (("1" (prop) (("1" (expand "upper_bound?") (("1" (expand "lower_bound?") (("1" (skosimp) (("1" (inst -1 "-s!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 "-y!3") (("2" (hide -2) (("2" (expand "lower_bound?") (("2" (expand "upper_bound?") (("2" (split) (("1" (assert) nil nil) ("2" (skosimp) (("2" (inst -1 "-s!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst 1 "-y!1") (("2" (expand "upper_bound?") (("2" (skosimp) (("2" (expand "lower_bound?") (("2" (inst -1 "-s!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "S!1") (("2" (hide -2 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skosimp) (("2" (expand "member") (("2" (inst -2 "-x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (lower_bound? const-decl "bool" bounded_real_defs nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (S!1 skolem-const-decl "(nonempty?[real])" bounded_real_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (real_complete formula-decl nil bounded_real_defs nil)) nil)) (lub_exists 0 (lub_exists-1 nil 3237052399 ("" (skolem-typepred) (("" (use "real_complete") (("" (assert) (("" (replace 1) (("" (assert) (("" (expand "bounded_above?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_complete formula-decl nil bounded_real_defs nil) (bounded_above? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (lub_TCC1 0 (lub_TCC1-1 nil 3237052399 ("" (use "real_complete") (("" (inst 1 "LAMBDA (S:(bounded_above?)): epsilon! (x:real): least_upper_bound?(x, S)") (("" (skosimp) (("" (use "epsilon_ax[real]") (("" (assert) (("" (inst? -1) (("" (typepred "S!1") (("" (split) (("1" (propax) nil nil) ("2" (expand "bounded_above?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (bounded_above? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (epsilon_ax formula-decl nil epsilons nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_complete formula-decl nil bounded_real_defs nil)) nil (lub existence "" "[SA: (bounded_real_defs.bounded_above?) -> {x | bounded_real_defs.least_upper_bound?(bounded_real_defs.x, SA)}]"))) (lub_lem 0 (lub_lem-1 nil 3237052399 ("" (skosimp) (("" (typepred "lub(SA!1)") (("" (assert) (("" (prop) (("1" (assert) nil nil) ("2" (grind :if-match nil) (("2" (inst -2 "lub(SA!1)") (("2" (inst -4 "x!1") (("2" (replace -1) (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lub const-decl "{x | least_upper_bound?(x, SA)}" bounded_real_defs nil) (bounded_above? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (upper_bound? const-decl "bool" bounded_real_defs nil)) nil)) (glb_exists 0 (glb_exists-1 nil 3237052399 ("" (skosimp) (("" (use "real_lower_complete") (("" (assert) (("" (split) (("1" (propax) nil nil) ("2" (typepred "SB!1") (("2" (expand "bounded_below?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lower_complete formula-decl nil bounded_real_defs nil) (bounded_below? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (glb_TCC1 0 (glb_TCC1-3 "" 3658944916 ("" (inst 1 "LAMBDA (S:(bounded_below?)): epsilon! (x:real): greatest_lower_bound?(x, S)") (("" (skolem-typepred) (("" (use "epsilon_ax[real]") (("" (assert) (("" (expand "bounded_below?") (("" (use "real_lower_complete") (("" (assert) (("" (replace 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lower_complete formula-decl nil bounded_real_defs nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (bounded_below? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (glb existence "" "[SB: (bounded_real_defs.bounded_below?) -> {x | bounded_real_defs.greatest_lower_bound?(bounded_real_defs.x, SB)}]")) (glb_TCC1-2 "" 3590856346 ("" (inst 1 "LAMBDA (S:(bounded_below?)): epsilon! (x:real): greatest_lower_bound?(x, S)") (("" (skolem-typepred) (("" (use "epsilon_ax[real]") (("" (assert) (("" (expand "bounded_below?") (("" (use "real_lower_complete") (("" (assert) (("" (replace -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lower_complete formula-decl nil bounded_real_defs nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bounded_below? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (glb existence "" "[SB: (bounded_real_defs.bounded_below?) -> {x | bounded_real_defs.greatest_lower_bound?(bounded_real_defs.x, SB)}]")) (glb_TCC1-1 nil 3237052399 ("" (inst 1 "LAMBDA (S:(bounded_below?)): epsilon! (x:real): greatest_lower_bound?(x, S)") (("" (skolem-typepred) (("" (use "epsilon_ax[real]") (("" (assert) (("" (expand "bounded_below?") (("" (use "real_lower_complete") (("" (assert) (("" (replace -3) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lower_complete formula-decl nil bounded_real_defs nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bounded_below? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (glb existence "" "[SB: (bounded_real_defs.bounded_below?) -> {x | bounded_real_defs.greatest_lower_bound?(bounded_real_defs.x, SB)}]"))) (glb_lem 0 (glb_lem-1 nil 3237052399 ("" (skosimp) (("" (typepred "glb(SB!1)") (("" (prop) (("1" (assert) nil nil) ("2" (grind :if-match nil) (("2" (inst -2 "glb(SB!1)") (("2" (inst -4 "x!1") (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((glb const-decl "{x | greatest_lower_bound?(x, SB)}" bounded_real_defs nil) (bounded_below? const-decl "bool" bounded_real_defs nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lower_bound? const-decl "bool" bounded_real_defs nil)) nil)))(bounded_real_defs_alt (lub_is_upper_bound 0 (lub_is_upper_bound-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (least_upper_bound? const-decl "[real -> bool]" bounded_real_defs_alt nil) (S formal-const-decl "(nonempty?[real])" bounded_real_defs_alt nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (upper_bound? const-decl "[real -> bool]" bounded_real_defs_alt nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (upper_bound? const-decl "bool" bounded_real_defs nil)) nil (lub_is_upper_bound subtype "bounded_real_defs_alt.x" "(bounded_real_defs_alt.upper_bound?)"))) (glb_is_lower_bound 0 (glb_is_lower_bound-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (greatest_lower_bound? const-decl "[real -> bool]" bounded_real_defs_alt nil) (S formal-const-decl "(nonempty?[real])" bounded_real_defs_alt nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (lower_bound? const-decl "[real -> bool]" bounded_real_defs_alt nil) (lower_bound? const-decl "bool" bounded_real_defs nil) (lower_bound? const-decl "bool" bounded_real_defs nil)) nil (glb_is_lower_bound subtype "bounded_real_defs_alt.x" "(bounded_real_defs_alt.lower_bound?)"))))(real_types (posreal_is_nzreal 0 (posreal_is_nzreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posreal_is_nzreal subtype "real_types.x" "nzreal"))) (negreal_is_nzreal 0 (negreal_is_nzreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negreal_is_nzreal subtype "real_types.x" "nzreal"))) (nonneg_real_add_closed 0 (nonneg_real_add_closed-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (nonpos_real_add_closed 0 (nonpos_real_add_closed-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (negreal_add_closed 0 (negreal_add_closed-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (nonneg_real_mult_closed 0 (nonneg_real_mult_closed-1 nil 3237052399 ("" (grind) (("" (case "nnx!1 = 0") (("1" (assert) nil nil) ("2" (case "nny!1 = 0") (("1" (assert) nil nil) ("2" (lemma "posreal_mult_closed") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (posreal_mult_closed formula-decl nil real_axioms nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) nil)) (nzreal_times_nzreal_is_nzreal 0 (nzreal_times_nzreal_is_nzreal-1 nil 3237052399 ("" (lemma "posreal_mult_closed") (("" (skosimp) (("" (case "nzx!1 > 0") (("1" (case "nzy!1 > 0") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst -2 "nzx!1" "-nzy!1") (("2" (assert) nil nil)) nil)) nil) ("2" (case "nzy!1 > 0") (("1" (inst -2 "-nzx!1" "nzy!1") (("1" (assert) nil nil)) nil) ("2" (inst -1 "-nzx!1" "-nzy!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (posreal_mult_closed formula-decl nil real_axioms nil)) nil (nzreal_times_nzreal_is_nzreal subtype "number_fields.*(real_types.nzx, real_types.nzy)" "nzreal"))) (nzreal_div_nzreal_is_nzreal 0 (nzreal_div_nzreal_is_nzreal-1 nil 3237052399 ("" (lemma "nzreal_times_nzreal_is_nzreal") (("" (skosimp) (("" (inst -1 "nzx!1" "1/nzy!1") (("" (assert) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal judgement-tcc nil real_types nil)) nil (nzreal_div_nzreal_is_nzreal subtype "number_fields./(real_types.nzx, real_types.nzy)" "nzreal"))) (minus_nzreal_is_nzreal 0 (minus_nzreal_is_nzreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (minus_nzreal_is_nzreal subtype "(number_fields.-)(real_types.nzx)" "nzreal"))) (nnreal_plus_nnreal_is_nnreal 0 (nnreal_plus_nnreal_is_nnreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnreal_plus_nnreal_is_nnreal subtype "(number_fields.+)(real_types.nnx, real_types.nny)" "nnreal"))) (nnreal_times_nnreal_is_nnreal 0 (nnreal_times_nnreal_is_nnreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "posreal_mult_closed") (("" (case "nnx!1 = 0") (("1" (assert) nil nil) ("2" (case "nny!1 = 0") (("1" (assert) nil nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) nil (nnreal_times_nnreal_is_nnreal subtype "number_fields.*(real_types.nnx, real_types.nny)" "nnreal"))) (nnreal_div_posreal_is_nnreal 0 (nnreal_div_posreal_is_nnreal-1 nil 3237052399 ("" (grind) (("" (lemma "posreal_mult_closed") (("" (case "nnx!1 = 0") (("1" (assert) nil nil) ("2" (inst -1 "nnx!1" "1/py!1") (("2" (assert) (("2" (lemma "inverse_mult") (("2" (inst -1 "py!1") (("2" (assert) (("2" (name-replace "a" "1/py!1") (("2" (assert) (("2" (lemma "posreal_mult_closed") (("2" (case-replace "a = 0") (("1" (assert) nil nil) ("2" (inst -1 "py!1" "-a") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (inverse_mult formula-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil (nnreal_div_posreal_is_nnreal subtype "number_fields./(real_types.nnx, real_types.py)" "nnreal"))) (nnreal_div_negreal_is_npreal 0 (nnreal_div_negreal_is_npreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "nnreal_div_posreal_is_nnreal") (("" (inst -1 "nnx!1" "-ny!1") (("" (assert) nil nil)) nil)) nil)) nil) ((nnreal_div_posreal_is_nnreal judgement-tcc nil real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil (nnreal_div_negreal_is_npreal subtype "number_fields./(real_types.nnx, real_types.ny)" "npreal"))) (npreal_plus_npreal_is_npreal 0 (npreal_plus_npreal_is_npreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (npreal_plus_npreal_is_npreal subtype "(number_fields.+)(real_types.npx, real_types.npy)" "npreal"))) (npreal_times_npreal_is_nnreal 0 (npreal_times_npreal_is_nnreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "posreal_mult_closed") (("" (inst -1 "-npx!1" "-npy!1") (("" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (real_times_real_is_real application-judgement "real" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil (npreal_times_npreal_is_nnreal subtype "number_fields.*(real_types.npx, real_types.npy)" "nnreal"))) (npreal_div_posreal_is_npreal 0 (npreal_div_posreal_is_npreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "nnreal_div_posreal_is_nnreal") (("" (inst -1 "-npx!1" "py!1") (("" (assert) nil nil)) nil)) nil)) nil) ((nnreal_div_posreal_is_nnreal judgement-tcc nil real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil (npreal_div_posreal_is_npreal subtype "number_fields./(real_types.npx, real_types.py)" "npreal"))) (npreal_div_negreal_is_nnreal 0 (npreal_div_negreal_is_nnreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "npreal_div_posreal_is_npreal") (("" (inst -1 "npx!1" "-ny!1") (("" (assert) nil nil)) nil)) nil)) nil) ((npreal_div_posreal_is_npreal judgement-tcc nil real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil (npreal_div_negreal_is_nnreal subtype "number_fields./(real_types.npx, real_types.ny)" "nnreal"))) (posreal_plus_nnreal_is_posreal 0 (posreal_plus_nnreal_is_posreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posreal_plus_nnreal_is_posreal subtype "(number_fields.+)(real_types.px, real_types.nny)" "posreal"))) (nnreal_plus_posreal_is_posreal 0 (nnreal_plus_posreal_is_posreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnreal_plus_posreal_is_posreal subtype "(number_fields.+)(real_types.nnx, real_types.py)" "posreal"))) (posreal_times_posreal_is_posreal 0 (posreal_times_posreal_is_posreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "posreal_mult_closed") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (posreal_times_posreal_is_posreal subtype "number_fields.*(real_types.px, real_types.py)" "posreal"))) (posreal_div_posreal_is_posreal 0 (posreal_div_posreal_is_posreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "posreal_mult_closed") (("" (inst -1 "px!1" "1/py!1") (("" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (posreal_div_posreal_is_posreal subtype "number_fields./(real_types.px, real_types.py)" "posreal"))) (negreal_plus_negreal_is_negreal 0 (negreal_plus_negreal_is_negreal-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negreal_plus_negreal_is_negreal subtype "(number_fields.+)(real_types.nx, real_types.ny)" "negreal"))) (negreal_times_negreal_is_posreal 0 (negreal_times_negreal_is_posreal-1 nil 3237052399 ("" (skosimp) (("" (lemma "posreal_mult_closed") (("" (inst -1 "-nx!1" "-ny!1") (("" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil (negreal_times_negreal_is_posreal subtype "number_fields.*(real_types.nx, real_types.ny)" "posreal"))) (negreal_div_negreal_is_posreal 0 (negreal_div_negreal_is_posreal-1 nil 3237052399 ("" (lemma "posreal_div_posreal_is_posreal") (("" (skosimp) (("" (inst -1 "-nx!1" "-ny!1") (("" (assert) nil nil)) nil)) nil)) nil) ((npreal_div_negreal_is_nnreal application-judgement "nnreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal judgement-tcc nil real_types nil)) nil (negreal_div_negreal_is_posreal subtype "number_fields./(real_types.nx, real_types.ny)" "posreal"))))(rationals (closed_plus 0 (closed_plus-1 nil 3246296579 ("" (postpone) nil nil) nil shostak)) (rat_plus_rat_is_rat 0 (rat_plus_rat_is_rat-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_plus") nil nil)) nil) ((closed_plus formula-decl nil rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) nil (rat_plus_rat_is_rat subtype "(number_fields.+)(rationals.x, rationals.y)" "rat"))) (rat_minus_rat_is_rat 0 (rat_minus_rat_is_rat-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_minus") nil nil)) nil) ((closed_minus formula-decl nil rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) nil (rat_minus_rat_is_rat subtype "(number_fields.-)(rationals.x, rationals.y)" "rat"))) (rat_times_rat_is_rat 0 (rat_times_rat_is_rat-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_times") nil nil)) nil) ((closed_times formula-decl nil rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) nil (rat_times_rat_is_rat subtype "number_fields.*(rationals.x, rationals.y)" "rat"))) (rat_div_nzrat_is_rat 0 (rat_div_nzrat_is_rat-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_divides") nil nil)) nil) ((closed_divides formula-decl nil rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (/= const-decl "boolean" notequal nil) (nzrat nonempty-type-eq-decl nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) nil (rat_div_nzrat_is_rat subtype "number_fields./(rationals.x, rationals.n0z)" "rat"))) (minus_rat_is_rat 0 (minus_rat_is_rat-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_neg") nil nil)) nil) ((closed_neg formula-decl nil rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) nil (minus_rat_is_rat subtype "(number_fields.-)(rationals.x)" "rat"))) (posrat_is_nzrat 0 (posrat_is_nzrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posrat_is_nzrat subtype "rationals.x" "nzrat"))) (negrat_is_nzrat 0 (negrat_is_nzrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negrat_is_nzrat subtype "rationals.x" "nzrat"))) (nzrat_times_nzrat_is_nzrat 0 (nzrat_times_nzrat_is_nzrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nzrat_times_nzrat_is_nzrat subtype "number_fields.*(rationals.n0x, rationals.n0y)" "nzrat"))) (nzrat_div_nzrat_is_nzrat 0 (nzrat_div_nzrat_is_nzrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nzrat_div_nzrat_is_nzrat subtype "number_fields./(rationals.n0x, rationals.n0y)" "nzrat"))) (minus_nzrat_is_nzrat 0 (minus_nzrat_is_nzrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (minus_nzrat_is_nzrat subtype "(number_fields.-)(rationals.n0x)" "nzrat"))) (nnrat_plus_nnrat_is_nnrat 0 (nnrat_plus_nnrat_is_nnrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnrat_plus_nnrat_is_nnrat subtype "(number_fields.+)(rationals.nnx, rationals.nny)" "nonneg_rat"))) (nnrat_times_nnrat_is_nnrat 0 (nnrat_times_nnrat_is_nnrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (nnrat_times_nnrat_is_nnrat subtype "number_fields.*(rationals.nnx, rationals.nny)" "nonneg_rat"))) (nnrat_div_posrat_is_nnrat 0 (nnrat_div_posrat_is_nnrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (nnrat_div_posrat_is_nnrat subtype "number_fields./(rationals.nnx, rationals.py)" "nonneg_rat"))) (nnrrat_div_negrat_is_nprat 0 (nnrrat_div_negrat_is_nprat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (<= const-decl "bool" reals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (< const-decl "bool" reals nil) (negrat nonempty-type-eq-decl nil rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil)) nil (nnrrat_div_negrat_is_nprat subtype "number_fields./(rationals.nnx, rationals.ny)" "nprat"))) (nprat_plus_nprat_is_nprat 0 (nprat_plus_nprat_is_nprat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nprat_plus_nprat_is_nprat subtype "(number_fields.+)(rationals.npx, rationals.npy)" "nprat"))) (nprat_times_nprat_is_nnrat 0 (nprat_times_nprat_is_nnrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (nprat_times_nprat_is_nnrat subtype "number_fields.*(rationals.npx, rationals.npy)" "nnrat"))) (nprat_div_posrat_is_nprat 0 (nprat_div_posrat_is_nprat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (>= const-decl "bool" reals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil)) nil (nprat_div_posrat_is_nprat subtype "number_fields./(rationals.npx, rationals.py)" "nprat"))) (nprat_div_negrat_is_nnrat 0 (nprat_div_negrat_is_nnrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (< const-decl "bool" reals nil) (negrat nonempty-type-eq-decl nil rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (npreal_div_negreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (nprat_div_negrat_is_nnrat subtype "number_fields./(rationals.npx, rationals.ny)" "nnrat"))) (posrat_plus_nnrat_is_posrat 0 (posrat_plus_nnrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posrat_plus_nnrat_is_posrat subtype "(number_fields.+)(rationals.px, rationals.nny)" "posrat"))) (nnrat_plus_posrat_is_posrat 0 (nnrat_plus_posrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnrat_plus_posrat_is_posrat subtype "(number_fields.+)(rationals.nnx, rationals.py)" "posrat"))) (posrat_times_posrat_is_posrat 0 (posrat_times_posrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (posrat_times_posrat_is_posrat subtype "number_fields.*(rationals.px, rationals.py)" "posrat"))) (posrat_div_posrat_is_posrat 0 (posrat_div_posrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (posrat_div_posrat_is_posrat subtype "number_fields./(rationals.px, rationals.py)" "posrat"))) (negrat_plus_negrat_is_negrat 0 (negrat_plus_negrat_is_negrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negrat_plus_negrat_is_negrat subtype "(number_fields.+)(rationals.nx, rationals.ny)" "negrat"))) (negrat_times_negrat_is_posrat 0 (negrat_times_negrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (< const-decl "bool" reals nil) (negrat nonempty-type-eq-decl nil rationals nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_times_nprat_is_nnrat application-judgement "nnrat" rationals nil) (negreal_times_negreal_is_posreal application-judgement "posreal" real_types nil)) nil (negrat_times_negrat_is_posrat subtype "number_fields.*(rationals.nx, rationals.ny)" "posrat"))) (negrat_div_negrat_is_posrat 0 (negrat_div_negrat_is_posrat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonpos_rat nonempty-type-eq-decl nil rationals nil) (< const-decl "bool" reals nil) (negrat nonempty-type-eq-decl nil rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_div_negrat_is_nnrat application-judgement "nnrat" rationals nil) (negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil)) nil (negrat_div_negrat_is_posrat subtype "number_fields./(rationals.nx, rationals.ny)" "posrat"))))(integers (upfrom_TCC1 0 (upfrom_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (upfrom subtype "integers.i" "integers.upfrom(integers.i)"))) (above_TCC1 0 (above_TCC1-1 nil 3237052399 ("" (skeep :preds? t) (("" (assert) (("" (rewrite "closed_plus") nil nil)) nil)) nil) ((rat_plus_rat_is_rat application-judgement "rat" rationals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (closed_plus formula-decl nil integers nil)) nil (above subtype "(number_fields.+)(integers.i, 1)" "integers.above(integers.i)"))) (int_plus_int_is_int 0 (int_plus_int_is_int-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_plus") nil nil)) nil) ((closed_plus formula-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) nil (int_plus_int_is_int subtype "(number_fields.+)(integers.i, integers.j)" "int"))) (int_minus_int_is_int 0 (int_minus_int_is_int-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_minus") nil nil)) nil) ((closed_minus formula-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) nil (int_minus_int_is_int subtype "(number_fields.-)(integers.i, integers.j)" "int"))) (int_times_int_is_int 0 (int_times_int_is_int-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_times") nil nil)) nil) ((closed_times formula-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) nil (int_times_int_is_int subtype "number_fields.*(integers.i, integers.j)" "int"))) (minus_int_is_int 0 (minus_int_is_int-1 nil 3237052399 ("" (skeep :preds? t) (("" (rewrite "closed_neg") nil nil)) nil) ((closed_neg formula-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) nil (minus_int_is_int subtype "(number_fields.-)(integers.i)" "int"))) (minus_nzint_is_nzint 0 (minus_nzint_is_nzint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (minus_nzint_is_nzint subtype "(number_fields.-)(integers.n0i)" "nzint"))) (posint_is_nzint 0 (posint_is_nzint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posint_is_nzint subtype "integers.x" "nzint"))) (negint_is_nzint 0 (negint_is_nzint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negint_is_nzint subtype "integers.x" "nzint"))) (nzint_times_nzint_is_nzint 0 (nzint_times_nzint_is_nzint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nzint_times_nzint_is_nzint subtype "number_fields.*(integers.n0i, integers.n0j)" "nzint"))) (nnint_plus_nnint_is_nnint 0 (nnint_plus_nnint_is_nnint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnint_plus_nnint_is_nnint subtype "(number_fields.+)(integers.nni, integers.nnj)" "nonneg_int"))) (nnint_times_nnint_is_nnint 0 (nnint_times_nnint_is_nnint-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil)) nil (nnint_times_nnint_is_nnint subtype "number_fields.*(integers.nni, integers.nnj)" "nonneg_int"))) (npint_plus_npint_is_npint 0 (npint_plus_npint_is_npint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (npint_plus_npint_is_npint subtype "(number_fields.+)(integers.npi, integers.npj)" "nonpos_int"))) (npint_times_npint_is_nnint 0 (npint_times_npint_is_nnint-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonpos_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nprat_times_nprat_is_nnrat application-judgement "nnrat" rationals nil)) nil (npint_times_npint_is_nnint subtype "number_fields.*(integers.npi, integers.npj)" "nonneg_int"))) (posint_plus_nnint_is_posint 0 (posint_plus_nnint_is_posint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posint_plus_nnint_is_posint subtype "(number_fields.+)(integers.pi, integers.nnj)" "posint"))) (nnint_plus_posint_is_posint 0 (nnint_plus_posint_is_posint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (nnint_plus_posint_is_posint subtype "(number_fields.+)(integers.nni, integers.pj)" "posint"))) (posint_times_posint_is_posint 0 (posint_times_posint_is_posint-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil)) nil (posint_times_posint_is_posint subtype "number_fields.*(integers.pi, integers.pj)" "posint"))) (negint_plus_negint_is_negint 0 (negint_plus_negint_is_negint-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (negint_plus_negint_is_negint subtype "(number_fields.+)(integers.ni, integers.nj)" "negint"))) (negint_times_negint_is_posint 0 (negint_times_negint_is_posint-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonpos_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (negint nonempty-type-eq-decl nil integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (npint_times_npint_is_nnint application-judgement "nonneg_int" integers nil) (negrat_times_negrat_is_posrat application-judgement "posrat" rationals nil)) nil (negint_times_negint_is_posint subtype "number_fields.*(integers.ni, integers.nj)" "posint"))) (even_int_TCC1 0 (even_int_TCC1-1 nil 3237052399 ("" (expand "even?") (("" (inst 1 "0") (("" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even? const-decl "bool" integers nil)) nil (even_int subtype "0" "even_int"))) (odd_int_TCC1 0 (odd_int_TCC1-1 nil 3237052399 ("" (expand "odd?") (("" (inst 1 "0") (("" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (odd? const-decl "bool" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (odd_int subtype "1" "odd_int"))) (odd_is_nzint 0 (odd_is_nzint-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil)) nil (odd_is_nzint subtype "integers.x" "nzint"))) (even_plus_even_is_even 0 (even_plus_even_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 + j!2") (("" (assert) nil nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (even_plus_even_is_even subtype "(number_fields.+)(integers.e1, integers.e2)" "even_int"))) (even_minus_even_is_even 0 (even_minus_even_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 - j!2") (("" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (even_minus_even_is_even subtype "(number_fields.-)(integers.e1, integers.e2)" "even_int"))) (odd_plus_odd_is_even 0 (odd_plus_odd_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "1 + j!1 + j!2") (("" (assert) nil nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (odd_plus_odd_is_even subtype "(number_fields.+)(integers.o1, integers.o2)" "even_int"))) (odd_minus_odd_is_even 0 (odd_minus_odd_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 - j!2") (("" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (odd_minus_odd_is_even subtype "(number_fields.-)(integers.o1, integers.o2)" "even_int"))) (odd_plus_even_is_odd 0 (odd_plus_even_is_odd-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 + j!2") (("" (assert) nil nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd? const-decl "bool" integers nil)) nil (odd_plus_even_is_odd subtype "(number_fields.+)(integers.o1, integers.e2)" "odd_int"))) (odd_minus_even_is_odd 0 (odd_minus_even_is_odd-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!2 - j!1") (("" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd? const-decl "bool" integers nil)) nil (odd_minus_even_is_odd subtype "(number_fields.-)(integers.o1, integers.e2)" "odd_int"))) (even_plus_odd_is_odd 0 (even_plus_odd_is_odd-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 + j!2") (("" (assert) nil nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd? const-decl "bool" integers nil)) nil (even_plus_odd_is_odd subtype "(number_fields.+)(integers.e1, integers.o2)" "odd_int"))) (even_minus_odd_is_odd 0 (even_minus_odd_is_odd-1 nil 3282864786 ("" (grind :if-match nil) (("" (inst 1 "j!1 - j!2 - 1") (("" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (even_int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd? const-decl "bool" integers nil)) shostak (even_minus_odd_is_odd subtype "(number_fields.-)(integers.e1, integers.o2)" "odd_int"))) (even_times_int_is_even 0 (even_times_int_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "i!1 * j!1") nil nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (even_times_int_is_even subtype "number_fields.*(integers.e1, integers.i)" "even_int"))) (int_times_even_is_even 0 (int_times_even_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "i!1 * j!1") nil nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_times_int_is_even application-judgement "even_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (int_times_even_is_even subtype "number_fields.*(integers.i, integers.e2)" "even_int"))) (odd_times_odd_is_odd 0 (odd_times_odd_is_odd-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "j!1 + j!2 + 2 * j!1 * j!2") (("" (assert) nil nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (odd? const-decl "bool" integers nil)) nil (odd_times_odd_is_odd subtype "number_fields.*(integers.o1, integers.o2)" "odd_int"))) (minus_even_is_even 0 (minus_even_is_even-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "-j!1") (("" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_times_int_is_even application-judgement "even_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (minus_int_is_int application-judgement "int" integers nil) (even? const-decl "bool" integers nil)) nil (minus_even_is_even subtype "(number_fields.-)(integers.e1)" "even_int"))) (minus_odd_is_odd 0 (minus_odd_is_odd-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 1 "-1 - j!1") (("" (assert) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (odd? const-decl "bool" integers nil)) nil (minus_odd_is_odd subtype "(number_fields.-)(integers.o1)" "odd_int"))))(naturalnumbers (upfrom_nat_is_nat 0 (upfrom_nat_is_nat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (upfrom_nat_is_nat subtype "naturalnumbers.x" "nat"))) (upfrom_posnat_is_posnat 0 (upfrom_posnat_is_posnat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (upfrom_posnat_is_posnat subtype "naturalnumbers.x" "posnat"))) (above_nat_is_posnat 0 (above_nat_is_posnat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (above_nat_is_posnat subtype "naturalnumbers.x" "posnat"))) (subrange_nat_is_nat 0 (subrange_nat_is_nat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (subrange_nat_is_nat subtype "naturalnumbers.x" "nat"))) (subrange_posnat_is_posnat 0 (subrange_posnat_is_posnat-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (subrange_posnat_is_posnat subtype "naturalnumbers.x" "posnat"))) (upto_TCC1 0 (upto_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (upto subtype "naturalnumbers.i" "naturalnumbers.upto(naturalnumbers.i)"))) (succ_TCC1 0 (succ_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak (succ subtype "(number_fields.+)(naturalnumbers.i, 1)" "nat"))) (pred_TCC1 0 (pred_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (pred subtype "(number_fields.-)(naturalnumbers.i, 1)" "nat"))) (tilde_TCC1 0 (tilde_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (tilde subtype "(number_fields.-)(naturalnumbers.i, naturalnumbers.j)" "nat"))) (nat_induction 0 (nat_induction-1 nil 3237052399 ("" (lemma "wf_induction[nat, (LAMBDA (m,n:nat): m < n)]") (("1" (beta) (("1" (skosimp*) (("1" (inst -1 "p!1") (("1" (split) (("1" (inst -1 "i!1") nil nil) ("2" (skosimp*) (("2" (case "x!1 = 0") (("1" (assert) nil nil) ("2" (inst -1 "x!1 - 1") (("1" (inst -3 "x!1 - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (lemma "wf_nat") (("2" (propax) nil nil)) nil)) nil)) nil) ((wf_nat formula-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "nat" naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (wf_induction formula-decl nil wf_induction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil)) nil)) (NAT_induction 0 (NAT_induction-1 nil 3237052399 ("" (lemma "nat_induction") (("" (skosimp*) (("" (inst -1 "(LAMBDA (n:nat): (FORALL (m:nat): m <= n IMPLIES p!1(m)))") (("" (split) (("1" (inst -1 "i!1") (("1" (inst -1 "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "0") (("2" (split) (("1" (assert) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst -3 "m!1") (("3" (assert) (("3" (skosimp*) (("3" (inst -1 "k!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)) (even_or_odd 0 (even_or_odd-2 "" 3388684085 ("" (case "FORALL (n: nat): even?(n) IFF NOT odd?(n)") (("1" (skosimp) (("1" (case "x!1 >= 0") (("1" (inst -2 "x!1") nil nil) ("2" (inst -1 "-x!1") (("1" (grind :if-match nil) (("1" (inst 3 "-j!1") (("1" (assert) nil nil)) nil) ("2" (inst 2 "-j!2") (("2" (assert) nil nil)) nil) ("3" (inst 4 "-j!1-1") (("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("2" (inst 2 "j!2 + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_times_int_is_even application-judgement "even_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (x!1 skolem-const-decl "int" naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd? const-decl "bool" integers nil)) shostak) (even_or_odd-1 nil 3252307123 ("" (case "FORALL (n: nat): even?(n) IFF NOT odd?(n)") (("1" (skosimp) (("1" (case "x!1 >= 0") (("1" (inst -2 "x!1") nil nil) ("2" (inst -1 "-x!1") (("1" (grind :if-match nil) (("1" (inst 3 "-j!1") (("1" (assert) nil nil)) nil) ("2" (inst 2 "-j!2") (("2" (assert) nil nil)) nil) ("3" (inst 4 "-j!1-1") (("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (grind :if-match nil) nil nil) ("3" (skosimp) (("3" (grind :if-match nil) (("3" (inst 2 "j!2 + 1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (odd_iff_not_even 0 (odd_iff_not_even-1 nil 3307950416 ("" (skosimp*) (("" (rewrite "even_or_odd") (("" (assert) nil nil)) nil)) nil) ((even_or_odd formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (even_iff_not_odd 0 (even_iff_not_odd-1 nil 3307950458 ("" (skosimp*) (("" (rewrite "even_or_odd") nil nil)) nil) ((even_or_odd formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (odd_or_even_int 0 (odd_or_even_int-1 nil 3307950482 ("" (skosimp*) (("" (rewrite "even_or_odd") nil nil)) nil) ((even_or_odd formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (odd_iff_even_succ 0 (odd_iff_even_succ-1 nil 3307950500 ("" (skosimp*) (("" (expand "even?") (("" (expand "odd?") (("" (split) (("1" (skosimp*) (("1" (inst + "j!1+1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst + "j!1-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even? const-decl "bool" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd? const-decl "bool" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak)) (even_iff_odd_succ 0 (even_iff_odd_succ-1 nil 3307950534 ("" (expand "even?") (("" (expand "odd?") (("" (propax) nil nil)) nil)) nil) ((even_times_int_is_even application-judgement "even_int" integers nil) (odd? const-decl "bool" integers nil) (even? const-decl "bool" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (even_plus1 0 (even_plus1-1 nil 3307980590 ("" (skosimp) (("" (rewrite "even_iff_odd_succ") (("" (use "odd_iff_not_even") (("" (assert) nil nil)) nil)) nil)) nil) ((even_iff_odd_succ formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (odd_iff_not_even formula-decl nil naturalnumbers nil)) shostak)) (odd_plus1 0 (odd_plus1-1 nil 3307980758 ("" (skosimp) (("" (rewrite "odd_iff_even_succ") (("" (rewrite "even_iff_not_odd") (("" (assert) nil nil)) nil)) nil)) nil) ((odd_iff_even_succ formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_iff_not_odd formula-decl nil naturalnumbers nil)) shostak)) (even_div2 0 (even_div2-1 nil 3307950586 ("" (expand "even?") (("" (skosimp*) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil) ((even_times_int_is_even application-judgement "even_int" integers nil) (even? const-decl "bool" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) shostak)) (odd_div2 0 (odd_div2-1 nil 3307950609 ("" (expand "odd?") (("" (skosimp*) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil) ((odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd? const-decl "bool" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak)))(min_nat (min_TCC1 0 (min_TCC1-1 nil 3237052399 ("" (inst + "lambda S: epsilon(lambda (n: nat): T_pred(n) AND S(n) AND
                                    FORALL x: S(x) IMPLIES n <= x)") (("" (skolem!) (("" (use "epsilon_ax[nat]") (("" (split -) (("1" (propax) nil nil) ("2" (delete 2) (("2" (assert) (("2" (lemma "wf_nat") (("2" (expand "well_founded?") (("2" (inst - "lambda (x: nat): T_pred(x) AND S!1(x)") (("2" (ground) (("1" (skolem!) (("1" (inst? +) (("1" (assert) (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (x!1 skolem-const-decl "T" min_nat nil) (S!1 skolem-const-decl "(nonempty?[T])" min_nat nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (wf_nat formula-decl nil naturalnumbers nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-subtype-decl nil min_nat nil) (T_pred const-decl "[nat -> boolean]" min_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (min existence "" "[S: (sets[T].nonempty?) -> {a | booleans.AND(S(min_nat.a), FORALL x: booleans.IMPLIES(S(min_nat.x), reals.<=(min_nat.a, min_nat.x)))}]"))) (min_def 0 (min_def-1 nil 3237052399 ("" (skolem!) (("" (typepred "min(S!1)") (("" (expand "minimum?") (("" (ground) (("1" (replace*) nil nil) ("2" (inst? -2 :where -4) (("2" (inst? - :where -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-subtype-decl nil min_nat nil) (T_pred const-decl "[nat -> boolean]" min_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minimum? const-decl "bool" min_nat nil)) nil)))(real_defs (abs_TCC1 0 (abs_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil (abs subtype "(number_fields.-)(real_defs.m)" "{n: real_types.nonneg_real | booleans.AND(reals.>=(n, real_defs.m), reals.>=(n, (number_fields.-)(real_defs.m)))}"))) (abs_TCC2 0 (abs_TCC2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (abs subtype "real_defs.m" "{n: real_types.nonneg_real | booleans.AND(reals.>=(n, real_defs.m), reals.>=(n, (number_fields.-)(real_defs.m)))}"))) (nonzero_abs_is_pos 0 (nonzero_abs_is_pos-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nzreal nonempty-type-eq-decl nil reals nil)) nil (nonzero_abs_is_pos subtype "real_defs.abs(real_defs.x)" "{y: real_types.posreal | reals.>=(y, real_defs.x)}"))) (rat_abs_is_nonneg 0 (rat_abs_is_nonneg-1 nil 3237052399 ("" (skosimp) (("" (expand "abs") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((minus_rat_is_rat application-judgement "rat" rationals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil (rat_abs_is_nonneg subtype "real_defs.abs(real_defs.q)" "{r: rationals.nonneg_rat | reals.>=(r, real_defs.q)}"))) (nzrat_abs_is_pos 0 (nzrat_abs_is_pos-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nzrat nonempty-type-eq-decl nil rationals nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil)) nil (nzrat_abs_is_pos subtype "real_defs.abs(real_defs.q)" "{r: rationals.posrat | reals.>=(r, real_defs.q)}"))) (int_abs_is_nonneg 0 (int_abs_is_nonneg-1 nil 3237052399 ("" (skosimp) (("" (expand "abs") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil (int_abs_is_nonneg subtype "real_defs.abs(real_defs.i)" "{j: integers.nonneg_int | reals.>=(j, real_defs.i)}"))) (nzint_abs_is_pos 0 (nzint_abs_is_pos-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil)) nil (nzint_abs_is_pos subtype "real_defs.abs(real_defs.i)" "{j: integers.posint | reals.>=(j, real_defs.i)}"))) (max_TCC1 0 (max_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (max subtype "real_defs.n" "{p: reals.real | booleans.AND(reals.>=(p, real_defs.m), reals.>=(p, real_defs.n))}"))) (max_TCC2 0 (max_TCC2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (max subtype "real_defs.m" "{p: reals.real | booleans.AND(reals.>=(p, real_defs.m), reals.>=(p, real_defs.n))}"))) (min_TCC1 0 (min_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (min subtype "real_defs.n" "{p: reals.real | booleans.AND(reals.<=(p, real_defs.m), reals.<=(p, real_defs.n))}"))) (min_TCC2 0 (min_TCC2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil (min subtype "real_defs.m" "{p: reals.real | booleans.AND(reals.<=(p, real_defs.m), reals.<=(p, real_defs.n))}"))) (nzreal_max 0 (nzreal_max-1 nil 3237052399 ("" (skosimp) (("" (expand "max") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) nil (nzreal_max subtype "real_defs.max(real_defs.x, real_defs.y)" "{z: reals.nzreal | booleans.AND(reals.>=(z, real_defs.x), reals.>=(z, real_defs.y))}"))) (nzreal_min 0 (nzreal_min-1 nil 3237052399 ("" (skosimp) (("" (expand "min") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (nzreal_min subtype "real_defs.min(real_defs.x, real_defs.y)" "{z: reals.nzreal | booleans.AND(reals.<=(z, real_defs.x), reals.<=(z, real_defs.y))}"))) (nonneg_real_max 0 (nonneg_real_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) nil (nonneg_real_max subtype "real_defs.max(real_defs.x, real_defs.y)" "{z: real_types.nonneg_real | booleans.AND(reals.>=(z, real_defs.x), reals.>=(z, real_defs.y))}"))) (nonneg_real_min 0 (nonneg_real_min-1 nil 3237052399 ("" (skosimp) (("" (expand "min") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (nonneg_real_min subtype "real_defs.min(real_defs.x, real_defs.y)" "{z: real_types.nonneg_real | booleans.AND(reals.<=(z, real_defs.x), reals.<=(z, real_defs.y))}"))) (posreal_max 0 (posreal_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (nzreal_max application-judgement "{z: nzreal | z >= x AND z >= y}" real_defs nil)) nil (posreal_max subtype "real_defs.max(real_defs.x, real_defs.y)" "{z: real_types.posreal | booleans.AND(reals.>=(z, real_defs.x), reals.>=(z, real_defs.y))}"))) (posreal_min 0 (posreal_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real_min application-judgement "{z: nonneg_real | z <= x AND z <= y}" real_defs nil) (nzreal_min application-judgement "{z: nzreal | z <= x AND z <= y}" real_defs nil)) nil (posreal_min subtype "real_defs.min(real_defs.x, real_defs.y)" "{z: real_types.posreal | booleans.AND(reals.<=(z, real_defs.x), reals.<=(z, real_defs.y))}"))) (rat_max 0 (rat_max-1 nil 3237052399 ("" (skosimp) (("" (expand "max") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) nil (rat_max subtype "real_defs.max(real_defs.q, real_defs.r)" "{s: rationals.rat | booleans.AND(reals.>=(s, real_defs.q), reals.>=(s, real_defs.r))}"))) (rat_min 0 (rat_min-1 nil 3237052399 ("" (skosimp) (("" (expand "min") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (rat_min subtype "real_defs.min(real_defs.q, real_defs.r)" "{s: rationals.rat | booleans.AND(reals.<=(s, real_defs.q), reals.<=(s, real_defs.r))}"))) (nzrat_max 0 (nzrat_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nzrat nonempty-type-eq-decl nil rationals nil) (nzreal_max application-judgement "{z: nzreal | z >= x AND z >= y}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (/= const-decl "boolean" notequal nil)) nil (nzrat_max subtype "real_defs.max(real_defs.q, real_defs.r)" "{s: rationals.nzrat | booleans.AND(reals.>=(s, real_defs.q), reals.>=(s, real_defs.r))}"))) (nzrat_min 0 (nzrat_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nzrat nonempty-type-eq-decl nil rationals nil) (nzreal_min application-judgement "{z: nzreal | z <= x AND z <= y}" real_defs nil) (rat_min application-judgement "{s: rat | s <= q AND s <= r}" real_defs nil) (/= const-decl "boolean" notequal nil)) nil (nzrat_min subtype "real_defs.min(real_defs.q, real_defs.r)" "{s: rationals.nzrat | booleans.AND(reals.<=(s, real_defs.q), reals.<=(s, real_defs.r))}"))) (nonneg_rat_max 0 (nonneg_rat_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)) nil (nonneg_rat_max subtype "real_defs.max(real_defs.q, real_defs.r)" "{s: rationals.nonneg_rat | booleans.AND(reals.>=(s, real_defs.q), reals.>=(s, real_defs.r))}"))) (nonneg_rat_min 0 (nonneg_rat_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (rat_min application-judgement "{s: rat | s <= q AND s <= r}" real_defs nil) (nonneg_real_min application-judgement "{z: nonneg_real | z <= x AND z <= y}" real_defs nil)) nil (nonneg_rat_min subtype "real_defs.min(real_defs.q, real_defs.r)" "{s: rationals.nonneg_rat | booleans.AND(reals.<=(s, real_defs.q), reals.<=(s, real_defs.r))}"))) (posrat_max 0 (posrat_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nzrat_max application-judgement "{s: nzrat | s >= q AND s >= r}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}" real_defs nil)) nil (posrat_max subtype "real_defs.max(real_defs.q, real_defs.r)" "{s: rationals.posrat | booleans.AND(reals.>=(s, real_defs.q), reals.>=(s, real_defs.r))}"))) (posrat_min 0 (posrat_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nzrat_min application-judgement "{s: nzrat | s <= q AND s <= r}" real_defs nil) (nonneg_rat_min application-judgement "{s: nonneg_rat | s <= q AND s <= r}" real_defs nil) (posreal_min application-judgement "{z: posreal | z <= x AND z <= y}" real_defs nil)) nil (posrat_min subtype "real_defs.min(real_defs.q, real_defs.r)" "{s: rationals.posrat | booleans.AND(reals.<=(s, real_defs.q), reals.<=(s, real_defs.r))}"))) (int_max 0 (int_max-1 nil 3237052399 ("" (skosimp) (("" (expand "max") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) nil (int_max subtype "real_defs.max(real_defs.i, real_defs.j)" "{k: integers.int | booleans.AND(reals.<=(real_defs.i, k), reals.<=(real_defs.j, k))}"))) (int_min 0 (int_min-1 nil 3237052399 ("" (skosimp) (("" (expand "min") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (int_min subtype "real_defs.min(real_defs.i, real_defs.j)" "{k: integers.int | booleans.AND(reals.<=(k, real_defs.i), reals.<=(k, real_defs.j))}"))) (nzint_max 0 (nzint_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (nzrat_max application-judgement "{s: nzrat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (/= const-decl "boolean" notequal nil)) nil (nzint_max subtype "real_defs.max(real_defs.i, real_defs.j)" "{k: integers.nzint | booleans.AND(reals.<=(real_defs.i, k), reals.<=(real_defs.j, k))}"))) (nzint_min 0 (nzint_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (nzrat_min application-judgement "{s: nzrat | s <= q AND s <= r}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (/= const-decl "boolean" notequal nil)) nil (nzint_min subtype "real_defs.min(real_defs.i, real_defs.j)" "{k: integers.nzint | booleans.AND(reals.<=(k, real_defs.i), reals.<=(k, real_defs.j))}"))) (nat_max 0 (nat_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)) nil (nat_max subtype "real_defs.max(real_defs.i, real_defs.j)" "{k: naturalnumbers.nat | booleans.AND(reals.<=(real_defs.i, k), reals.<=(real_defs.j, k))}"))) (nat_min 0 (nat_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (nonneg_rat_min application-judgement "{s: nonneg_rat | s <= q AND s <= r}" real_defs nil)) nil (nat_min subtype "real_defs.min(real_defs.i, real_defs.j)" "{k: naturalnumbers.nat | booleans.AND(reals.<=(k, real_defs.i), reals.<=(k, real_defs.j))}"))) (posint_max 0 (posint_max-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (nzint_max application-judgement "{k: nzint | i <= k AND j <= k}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil)) nil (posint_max subtype "real_defs.max(real_defs.i, real_defs.j)" "{k: integers.posint | booleans.AND(reals.<=(real_defs.i, k), reals.<=(real_defs.j, k))}"))) (posint_min 0 (posint_min-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (nzint_min application-judgement "{k: nzint | k <= i AND k <= j}" real_defs nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (posrat_min application-judgement "{s: posrat | s <= q AND s <= r}" real_defs nil)) nil (posint_min subtype "real_defs.min(real_defs.i, real_defs.j)" "{k: integers.posint | booleans.AND(reals.<=(k, real_defs.i), reals.<=(k, real_defs.j))}"))) (min_le 0 (min_le-1 nil 3307951039 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (min_lt 0 (min_lt-1 nil 3307951075 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (min_ge 0 (min_ge-1 nil 3307951084 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (min_gt 0 (min_gt-1 nil 3307951093 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (le_min 0 (le_min-1 nil 3307951100 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (lt_min 0 (lt_min-1 nil 3307951109 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (ge_min 0 (ge_min-1 nil 3307951118 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (gt_min 0 (gt_min-1 nil 3307951125 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (max_le 0 (max_le-1 nil 3307951134 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (max_lt 0 (max_lt-1 nil 3307951142 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (max_ge 0 (max_ge-1 nil 3307951149 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (max_gt 0 (max_gt-1 nil 3307951158 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (le_max 0 (le_max-1 nil 3307951168 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (lt_max 0 (lt_max-1 nil 3307951177 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (ge_max 0 (ge_max-1 nil 3307951188 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)) (gt_max 0 (gt_max-1 nil 3307951197 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak)))(real_props (inv_ne_0 0 (inv_ne_0-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (both_sides_plus1 0 (both_sides_plus1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (both_sides_plus2 0 (both_sides_plus2-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (both_sides_minus1 0 (both_sides_minus1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (both_sides_minus2 0 (both_sides_minus2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times1 0 (both_sides_times1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times2 0 (both_sides_times2-1 nil 3237052399 ("" (lemma "both_sides_times1") (("" (skosimp*) (("" (prop) (("1" (inst -2 "n0z!1" "x!1" "y!1") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times1 formula-decl nil real_props nil)) nil)) (both_sides_div1 0 (both_sides_div1-1 nil 3237052399 ("" (grind) (("" (lemma "both_sides_times1") (("" (inst -1 "1/n0z!1" "x!1" "y!1") (("" (assert) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (both_sides_div2 0 (both_sides_div2-1 nil 3237052399 ("" (grind) (("" (lemma "both_sides_times1") (("" (inst-cp -1 "n0x!1" "n0z!1/n0x!1" "n0z!1/n0y!1") (("" (flatten) (("" (delete -2) (("" (split) (("1" (case "n0z!1 = (n0z!1/n0x!1) * n0x!1") (("1" (replace -1 :dir rl) (("1" (delete -1) (("1" (delete -3) (("1" (inst -2 "n0y!1" "n0z!1" "(n0z!1/n0y!1)*n0x!1") (("1" (flatten) (("1" (delete -2) (("1" (split) (("1" (case "(n0z!1 / n0y!1) * n0x!1 * n0y!1 = n0z!1 * n0x!1") (("1" (replace -1) (("1" (rewrite "both_sides_times2") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2 3 4 5) (("2" (use "div_def") (("2" (replace -1) (("2" (use "associative_mult") (("2" (replace -1 :dir rl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (times_plus 0 (times_plus-1 nil 3237052399 ("" (grind) nil nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (times_div1 0 (times_div1-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (times_div2 0 (times_div2-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (div_times 0 (div_times-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (div_eq_zero 0 (div_eq_zero-1 nil 3237052399 ("" (grind) (("" (lemma "both_sides_times1") (("" (inst -1 "n0z!1" "x!1/n0z!1" "0") (("" (flatten) (("" (delete -1) (("" (split) (("1" (delete -2) (("1" (assert) (("1" (rewrite "commutative_mult") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_simp 0 (div_simp-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (div_cancel1 0 (div_cancel1-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_cancel2 0 (div_cancel2-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_cancel3 0 (div_cancel3-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_cancel4 0 (div_cancel4-1 nil 3510504283 ("" (skosimp) (("" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (cross_mult 0 (cross_mult-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (add_div 0 (add_div-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (minus_div1 0 (minus_div1-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (minus_div2 0 (minus_div2-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (div_distributes 0 (div_distributes-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (div_distributes_minus 0 (div_distributes_minus-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (div_div1 0 (div_div1-1 nil 3237052399 ("" (grind) nil nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (div_div2 0 (div_div2-1 nil 3237052399 ("" (grind) nil nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (idem_add_is_zero 0 (idem_add_is_zero-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (zero_times1 0 (zero_times1-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (zero_times2 0 (zero_times2-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (zero_times3 0 (zero_times3-1 nil 3237052399 ("" (skosimp*) (("" (prop) (("1" (lemma "trichotomy") (("1" (inst-cp -1 "x!1") (("1" (inst -1 "y!1") (("1" (assert) (("1" (prop) (("1" (lemma "posreal_mult_closed") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "posreal_mult_closed") (("2" (inst -1 "-x!1" "y!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "posreal_mult_closed") (("3" (inst -1 "x!1" "-y!1") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "posreal_mult_closed") (("4" (inst -1 "-x!1" "-y!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (posreal_mult_closed formula-decl nil real_axioms nil) (trichotomy formula-decl nil real_axioms nil)) nil)) (neg_times_neg 0 (neg_times_neg-1 nil 3237052399 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil)) nil)) (zero_is_neg_zero 0 (zero_is_neg_zero-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (strict_lt 0 (strict_lt-1 nil 3237052399 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (trichotomous? const-decl "bool" orders nil) (strict_total_order? const-decl "bool" orders nil)) nil)) (trich_lt 0 (trich_lt-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (tri_unique_lt1 0 (tri_unique_lt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil)) nil)) (tri_unique_lt2 0 (tri_unique_lt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (zero_not_lt_zero 0 (zero_not_lt_zero-1 nil 3237052399 ("" (grind) nil nil) nil nil)) (neg_lt 0 (neg_lt-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (pos_times_lt 0 (pos_times_lt-1 nil 3237052399 ("" (grind) (("1" (lemma "posreal_mult_closed") (("1" (case "x!1 = 0") (("1" (assert) nil nil) ("2" (case "y!1 = 0") (("1" (assert) nil nil) ("2" (inst -1 "x!1" "-y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = 0") (("1" (assert) nil nil) ("2" (case "y!1 = 0") (("1" (assert) nil nil) ("2" (lemma "posreal_mult_closed") (("2" (inst -1 "-x!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "posreal_mult_closed") (("3" (inst -1 "x!1" "y!1") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "posreal_mult_closed") (("4" (inst -1 "-x!1" "-y!1") (("4" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (neg_times_lt 0 (neg_times_lt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "pos_times_lt") (("" (inst -1 "x!1" "-y!1") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((pos_times_lt formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (quotient_pos_lt 0 (quotient_pos_lt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "inverse_mult") (("" (inst?) (("" (lemma "pos_times_lt") (("" (inst -1 "n0x!1" "1/n0x!1") (("" (replace -2) (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inverse_mult formula-decl nil number_fields nil) (pos_times_lt formula-decl nil real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (quotient_neg_lt 0 (quotient_neg_lt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "quotient_pos_lt") (("" (inst -1 "-n0x!1") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((quotient_pos_lt formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (pos_div_lt 0 (pos_div_lt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "pos_times_lt") (("" (inst -1 "x!1" "1/n0y!1") (("" (lemma "quotient_pos_lt") (("" (inst -1 "n0y!1") (("" (lemma "quotient_neg_lt") (("" (inst -1 "n0y!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pos_times_lt formula-decl nil real_props nil) (quotient_pos_lt formula-decl nil real_props nil) (quotient_neg_lt formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (neg_div_lt 0 (neg_div_lt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "pos_div_lt") (("" (inst -1 "n0y!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((pos_div_lt formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (div_mult_pos_lt1 0 (div_mult_pos_lt1-1 nil 3237052399 ("" (grind) (("1" (lemma "posreal_mult_closed") (("1" (inst -1 "x!1 - (z!1/py!1)" "py!1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "posreal_mult_closed") (("2" (inst -1 "x!1*py!1 - z!1" "1/py!1") (("2" (assert) nil nil)) nil)) nil)) nil) ((posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_mult_closed formula-decl nil real_axioms nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil)) (div_mult_pos_lt2 0 (div_mult_pos_lt2-1 nil 3237052399 ("" (lemma "div_mult_pos_lt1") (("" (skosimp) (("" (inst -1 "py!1" "-x!1" "-z!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt1 formula-decl nil real_props nil)) nil)) (div_mult_neg_lt1 0 (div_mult_neg_lt1-1 nil 3237052399 ("" (lemma "div_mult_pos_lt2") (("" (skosimp) (("" (inst -1 "-ny!1" "-x!1" "z!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt2 formula-decl nil real_props nil)) nil)) (div_mult_neg_lt2 0 (div_mult_neg_lt2-1 nil 3237052399 ("" (skosimp) (("" (lemma "div_mult_pos_lt1") (("" (inst -1 "-ny!1" "-x!1" "z!1") (("" (grind) nil nil)) nil)) nil)) nil) ((div_mult_pos_lt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_plus_lt1 0 (both_sides_plus_lt1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_plus_lt2 0 (both_sides_plus_lt2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_lt1 0 (both_sides_minus_lt1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_lt2 0 (both_sides_minus_lt2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times_pos_lt1 0 (both_sides_times_pos_lt1-1 nil 3237052399 ("" (grind) (("1" (lemma "posreal_mult_closed") (("1" (inst -1 "(y!1 - x!1) * pz!1" "1/pz!1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "posreal_mult_closed") (("2" (inst -1 "y!1-x!1" "pz!1") (("2" (assert) nil nil)) nil)) nil)) nil) ((posreal_mult_closed formula-decl nil real_axioms nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil)) (both_sides_times_pos_lt2 0 (both_sides_times_pos_lt2-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt1") (("" (skosimp) (("" (inst -1 "pz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_lt1 0 (both_sides_times_neg_lt1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt1") (("" (skosimp) (("" (inst -1 "-nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_lt2 0 (both_sides_times_neg_lt2-1 nil 3237052399 ("" (lemma "both_sides_times_neg_lt1") (("" (skosimp) (("" (inst -1 "nz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_lt1 0 (both_sides_div_pos_lt1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt1") (("" (skosimp) (("" (inst -1 "1/pz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_lt2 0 (both_sides_div_pos_lt2-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_times_pos_lt1") (("" (inst -1 "px!1 * py!1" "pz!1 / px!1" "pz!1 / py!1") (("" (assert) (("" (grind) (("1" (case "pz!1 / px!1 * (px!1 * py!1) = pz!1 * py!1") (("1" (replace -1) (("1" (hide -1) (("1" (case "pz!1 / py!1 * (px!1 * py!1) = pz!1 * px!1") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "both_sides_times_pos_lt2") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "pz!1 / px!1 * (px!1 * py!1) = pz!1 * py!1") (("1" (case "pz!1 / py!1 * (px!1 * py!1) = pz!1 * px!1") (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_times_pos_lt1 formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) nil)) (both_sides_div_pos_lt3 0 (both_sides_div_pos_lt3-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_div_pos_lt2") (("" (inst -1 "py!1" "px!1" "-nz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((both_sides_div_pos_lt2 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (both_sides_div_neg_lt1 0 (both_sides_div_neg_lt1-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt1") (("" (skosimp) (("" (inst -1 "-nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_lt2 0 (both_sides_div_neg_lt2-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt2") (("" (skosimp) (("" (inst -1 "-ny!1" "-nx!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_lt3 0 (both_sides_div_neg_lt3-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt3") (("" (skosimp) (("" (inst -1 "nz!1" "-ny!1" "-nx!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_lt3 formula-decl nil real_props nil)) nil)) (lt_plus_lt1 0 (lt_plus_lt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (lt_plus_lt2 0 (lt_plus_lt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (lt_minus_lt1 0 (lt_minus_lt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (lt_minus_lt2 0 (lt_minus_lt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (lt_times_lt_pos1 0 (lt_times_lt_pos1-1 nil 3237052399 ("" (skosimp*) (("" (case "nnz!1 = 0") (("1" (assert) (("1" (lemma "pos_times_lt") (("1" (inst -1 "y!1" "w!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "both_sides_times_pos_lt1") (("2" (inst-cp -1 "nnz!1" "px!1" "y!1") (("1" (inst -1 "y!1" "nnz!1" "w!1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_times_lt formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nnz!1 skolem-const-decl "nonneg_real" real_props nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (y!1 skolem-const-decl "real" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (lt_times_lt_pos2 0 (lt_times_lt_pos2-1 nil 3237052399 ("" (skosimp*) (("" (case "nnx!1 = 0") (("1" (assert) (("1" (lemma "pos_times_lt") (("1" (inst -1 "y!1" "w!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "both_sides_times_pos_lt1") (("2" (inst-cp -1 "pz!1" "nnx!1" "y!1") (("2" (inst -1 "y!1" "pz!1" "w!1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_times_lt formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (y!1 skolem-const-decl "real" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (lt_div_lt_pos1_TCC1 0 (lt_div_lt_pos1_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (lt_div_lt_pos1 subtype "real_props.w" "nznum"))) (lt_div_lt_pos1 0 (lt_div_lt_pos1-1 nil 3237052399 ("" (grind) (("" (delete -5 -6) (("" (lemma "both_sides_div_pos_lt1") (("" (inst -1 "w!1" "px!1" "y!1") (("" (lemma "both_sides_div_pos_lt2") (("" (inst -1 "w!1" "pz!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_div_pos_lt2 formula-decl nil real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil)) (lt_div_lt_pos2_TCC1 0 (lt_div_lt_pos2_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (lt_div_lt_pos2 subtype "real_props.w" "nznum"))) (lt_div_lt_pos2 0 (lt_div_lt_pos2-1 nil 3237052399 ("" (grind) (("" (delete -4 -5) (("" (lemma "both_sides_div_pos_lt1") (("" (inst -1 "w!1" "nnx!1" "y!1") (("" (lemma "both_sides_div_pos_lt2") (("" (inst -1 "w!1" "pz!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_div_pos_lt2 formula-decl nil real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil)) (lt_times_lt_neg1 0 (lt_times_lt_neg1-1 nil 3237052399 ("" (lemma "lt_times_lt_pos1") (("" (skosimp) (("" (inst -1 "-npw!1" "-ny!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (lt_times_lt_pos1 formula-decl nil real_props nil)) nil)) (lt_times_lt_neg2 0 (lt_times_lt_neg2-1 nil 3237052399 ("" (lemma "lt_times_lt_pos2") (("" (skosimp) (("" (inst -1 "-npy!1" "-nw!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (lt_times_lt_pos2 formula-decl nil real_props nil)) nil)) (lt_div_lt_neg1_TCC1 0 (lt_div_lt_neg1_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (lt_div_lt_neg1 subtype "real_props.z" "nznum"))) (lt_div_lt_neg1 0 (lt_div_lt_neg1-1 nil 3237052399 ("" (lemma "lt_div_lt_pos1") (("" (skosimp) (("" (inst -1 "-ny!1" "-nw!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (lt_div_lt_pos1 formula-decl nil real_props nil)) nil)) (lt_div_lt_neg2_TCC1 0 (lt_div_lt_neg2_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (lt_div_lt_neg2 subtype "real_props.z" "nznum"))) (lt_div_lt_neg2 0 (lt_div_lt_neg2-1 nil 3237052399 ("" (lemma "lt_div_lt_pos2") (("" (skosimp) (("" (inst -1 "-npy!1" "-nw!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (lt_div_lt_pos2 formula-decl nil real_props nil)) nil)) (total_le 0 (total_le-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (dichotomous? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil)) nil)) (dich_le 0 (dich_le-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (zero_le_zero 0 (zero_le_zero-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (neg_le 0 (neg_le-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (pos_times_le 0 (pos_times_le-1 nil 3237052399 ("" (lemma "pos_times_lt") (("" (skosimp) (("" (case "x!1 = 0") (("1" (grind) nil nil) ("2" (case "y!1 = 0") (("1" (grind) nil nil) ("2" (inst?) (("2" (lemma "zero_times3") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero_times3 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (pos_times_lt formula-decl nil real_props nil)) nil)) (neg_times_le 0 (neg_times_le-1 nil 3237052399 ("" (lemma "pos_times_le") (("" (skosimp) (("" (inst -1 "x!1" "-y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (pos_times_le formula-decl nil real_props nil)) nil)) (quotient_pos_le 0 (quotient_pos_le-1 nil 3237052399 ("" (lemma "quotient_pos_lt") (("" (skosimp) (("" (inst?) (("" (lemma "inv_ne_0") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((inv_ne_0 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (quotient_pos_lt formula-decl nil real_props nil)) nil)) (quotient_neg_le 0 (quotient_neg_le-1 nil 3237052399 ("" (lemma "quotient_pos_le") (("" (skosimp) (("" (inst -1 "-n0x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (quotient_pos_le formula-decl nil real_props nil)) nil)) (pos_div_le 0 (pos_div_le-1 nil 3237052399 ("" (lemma "pos_div_lt") (("" (skosimp) (("" (case "x!1 = 0") (("1" (grind) nil nil) ("2" (inst?) (("2" (lemma "zero_times3") (("2" (inst -1 "x!1" "1/n0y!1") (("2" (lemma "inv_ne_0") (("2" (inst -1 "n0y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (inv_ne_0 formula-decl nil real_props nil) (zero_times3 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (pos_div_lt formula-decl nil real_props nil)) nil)) (neg_div_le 0 (neg_div_le-1 nil 3237052399 ("" (lemma "pos_div_le") (("" (skosimp) (("" (inst -1 "-n0y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pos_div_le formula-decl nil real_props nil)) nil)) (div_mult_pos_le1 0 (div_mult_pos_le1-1 nil 3237052399 ("" (lemma "div_mult_pos_lt1") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) (("" (case-replace "z!1 = x!1 * py!1") (("1" (assert) (("1" (case-replace "x!1 * py!1 / py!1 = x!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3 4) (("2" (use "div_def") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_def formula-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_pos_lt1 formula-decl nil real_props nil)) nil)) (div_mult_pos_le2 0 (div_mult_pos_le2-1 nil 3237052399 ("" (lemma "div_mult_pos_lt2") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) (("" (case-replace "z!1 = x!1 * py!1") (("1" (assert) (("1" (case-replace "x!1 * py!1 / py!1 = x!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3 4) (("2" (use "div_def") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_def formula-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_pos_lt2 formula-decl nil real_props nil)) nil)) (div_mult_neg_le1 0 (div_mult_neg_le1-1 nil 3237052399 ("" (lemma "div_mult_neg_lt1") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) (("" (case-replace "z!1 = x!1 * ny!1") (("1" (assert) (("1" (case-replace "x!1 * ny!1 / ny!1 = x!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3 4) (("2" (use "div_def") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (div_def formula-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_neg_lt1 formula-decl nil real_props nil)) nil)) (div_mult_neg_le2 0 (div_mult_neg_le2-1 nil 3237052399 ("" (lemma "div_mult_neg_lt2") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) (("" (case-replace "z!1 = x!1 * ny!1") (("1" (assert) (("1" (case-replace "x!1 * ny!1 / ny!1 = x!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3 4) (("2" (use "div_def") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (div_def formula-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_neg_lt2 formula-decl nil real_props nil)) nil)) (both_sides_plus_le1 0 (both_sides_plus_le1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_plus_le2 0 (both_sides_plus_le2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_le1 0 (both_sides_minus_le1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_le2 0 (both_sides_minus_le2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times_pos_le1 0 (both_sides_times_pos_le1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt1") (("" (skosimp) (("" (inst?) (("" (inst -1 "y!1") (("" (grind) (("" (lemma "both_sides_times1") (("" (inst?) (("" (inst -1 "y!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_times1 formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_le2 0 (both_sides_times_pos_le2-1 nil 3237052399 ("" (lemma "both_sides_times_pos_le1") (("" (skosimp) (("" (inst -1 "pz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_le1 0 (both_sides_times_neg_le1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_le1") (("" (skosimp) (("" (inst -1 "-nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_le2 0 (both_sides_times_neg_le2-1 nil 3237052399 ("" (lemma "both_sides_times_neg_le1") (("" (skosimp) (("" (inst -1 "nz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_le1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_le1 0 (both_sides_div_pos_le1-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt1") (("" (skosimp) (("" (inst?) (("" (inst -1 "y!1") (("" (grind) (("" (lemma "both_sides_times_pos_le1") (("" (inst -1 "1/pz!1" "x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_le2 0 (both_sides_div_pos_le2-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt2") (("" (skosimp) (("" (inst?) (("" (inst -1 "py!1") (("" (grind) (("" (lemma "both_sides_div2") (("" (inst?) (("" (inst -1 "py!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_div2 formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_le3 0 (both_sides_div_pos_le3-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le2") (("" (skosimp) (("" (inst -1 "py!1" "px!1" "-nz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_le1 0 (both_sides_div_neg_le1-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le1") (("" (skosimp) (("" (inst -1 "-nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_le2 0 (both_sides_div_neg_le2-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le2") (("" (skosimp) (("" (inst -1 "-ny!1" "-nx!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_le3 0 (both_sides_div_neg_le3-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le3") (("" (skosimp) (("" (inst -1 "nz!1" "-ny!1" "-nx!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_div_pos_le3 formula-decl nil real_props nil)) nil)) (le_plus_le 0 (le_plus_le-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (le_minus_le 0 (le_minus_le-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (le_times_le_pos 0 (le_times_le_pos-1 nil 3237052399 ("" (lemma "lt_times_lt_pos1") (("" (skosimp) (("" (case "nnz!1 = w!1") (("1" (lemma "both_sides_times_pos_le1") (("1" (inst -1 "w!1" "nnx!1" "y!1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst -1 "nnz!1" "nnx!1" "w!1" "y!1") (("1" (grind) nil nil) ("2" (grind) (("2" (lemma "pos_times_le") (("2" (inst -1 "y!1" "w!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnx!1 skolem-const-decl "nonneg_real" real_props nil) (pos_times_le formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (w!1 skolem-const-decl "real" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (lt_times_lt_pos1 formula-decl nil real_props nil)) nil)) (le_div_le_pos_TCC1 0 (le_div_le_pos_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (le_div_le_pos subtype "real_props.w" "nznum"))) (le_div_le_pos 0 (le_div_le_pos-1 nil 3237052399 ("" (lemma "le_times_le_pos") (("" (skosimp) (("" (inst -1 "nnx!1" "1/w!1" "1/pz!1" "y!1") (("1" (grind) (("1" (rewrite "both_sides_div_pos_le2") nil nil)) nil) ("2" (assert) (("2" (lemma "quotient_pos_lt") (("2" (inst -1 "w!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((nonzero_real nonempty-type-eq-decl nil reals nil) (quotient_pos_lt formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (both_sides_div_pos_le2 formula-decl nil real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (w!1 skolem-const-decl "real" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (le_times_le_pos formula-decl nil real_props nil)) nil)) (le_times_le_neg 0 (le_times_le_neg-1 nil 3237052399 ("" (lemma "le_times_le_pos") (("" (skosimp) (("" (inst -1 "-npy!1" "-npw!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (le_times_le_pos formula-decl nil real_props nil)) nil)) (le_div_le_neg_TCC1 0 (le_div_le_neg_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (le_div_le_neg subtype "real_props.z" "nznum"))) (le_div_le_neg 0 (le_div_le_neg-1 nil 3237052399 ("" (lemma "le_div_le_pos") (("" (skosimp) (("" (inst -1 "-npy!1" "-nw!1" "-z!1" "-x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (le_div_le_pos formula-decl nil real_props nil)) nil)) (strict_gt 0 (strict_gt-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (trichotomous? const-decl "bool" orders nil) (strict_total_order? const-decl "bool" orders nil)) nil)) (trich_gt 0 (trich_gt-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (tri_unique_gt1 0 (tri_unique_gt1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil)) nil)) (tri_unique_gt2 0 (tri_unique_gt2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (zero_not_gt_zero 0 (zero_not_gt_zero-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (neg_gt 0 (neg_gt-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (pos_times_gt 0 (pos_times_gt-1 nil 3237052399 ("" (lemma "pos_times_lt") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_times_lt formula-decl nil real_props nil)) nil)) (neg_times_gt 0 (neg_times_gt-1 nil 3237052399 ("" (lemma "neg_times_lt") (("" (skosimp) (("" (inst -1 "x!1" "y!1") (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (neg_times_lt formula-decl nil real_props nil)) nil)) (quotient_pos_gt 0 (quotient_pos_gt-1 nil 3237052399 ("" (lemma "quotient_pos_lt") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (quotient_pos_lt formula-decl nil real_props nil)) nil)) (quotient_neg_gt 0 (quotient_neg_gt-1 nil 3237052399 ("" (lemma "quotient_neg_lt") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (quotient_neg_lt formula-decl nil real_props nil)) nil)) (pos_div_gt 0 (pos_div_gt-1 nil 3237052399 ("" (lemma "pos_div_lt") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_div_lt formula-decl nil real_props nil)) nil)) (neg_div_gt 0 (neg_div_gt-1 nil 3237052399 ("" (lemma "neg_div_lt") (("" (skosimp) (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (neg_div_lt formula-decl nil real_props nil)) nil)) (both_sides_plus_gt1 0 (both_sides_plus_gt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_plus_gt2 0 (both_sides_plus_gt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_gt1 0 (both_sides_minus_gt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_gt2 0 (both_sides_minus_gt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times_pos_gt1 0 (both_sides_times_pos_gt1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt1") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_gt2 0 (both_sides_times_pos_gt2-1 nil 3237052399 ("" (lemma "both_sides_times_pos_lt2") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_gt1 0 (both_sides_times_neg_gt1-1 nil 3237052399 ("" (lemma "both_sides_times_neg_lt1") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_gt2 0 (both_sides_times_neg_gt2-1 nil 3237052399 ("" (lemma "both_sides_times_neg_lt2") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_gt1 0 (both_sides_div_pos_gt1-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt1") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_gt2 0 (both_sides_div_pos_gt2-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt2") (("" (skosimp) (("" (inst -1 "py!1" "px!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_gt3 0 (both_sides_div_pos_gt3-1 nil 3237052399 ("" (lemma "both_sides_div_pos_lt3") (("" (skosimp) (("" (inst -1 "nz!1" "py!1" "px!1") (("" (grind) nil nil)) nil)) nil)) nil) ((npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_lt3 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_gt1 0 (both_sides_div_neg_gt1-1 nil 3237052399 ("" (lemma "both_sides_div_neg_lt1") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_gt2 0 (both_sides_div_neg_gt2-1 nil 3237052399 ("" (lemma "both_sides_div_neg_lt2") (("" (skosimp) (("" (inst -1 "ny!1" "nx!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_gt3 0 (both_sides_div_neg_gt3-1 nil 3237052399 ("" (lemma "both_sides_div_neg_lt3") (("" (skosimp) (("" (inst -1 "ny!1" "nx!1" "nz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_lt3 formula-decl nil real_props nil)) nil)) (gt_plus_gt1 0 (gt_plus_gt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (gt_plus_gt2 0 (gt_plus_gt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (gt_minus_gt1 0 (gt_minus_gt1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (gt_minus_gt2 0 (gt_minus_gt2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (gt_times_gt_pos1 0 (gt_times_gt_pos1-1 nil 3237052399 ("" (lemma "lt_times_lt_pos1") (("" (skosimp) (("" (inst -1 "nnw!1" "py!1" "z!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_times_lt_pos1 formula-decl nil real_props nil)) nil)) (gt_times_gt_pos2 0 (gt_times_gt_pos2-1 nil 3237052399 ("" (lemma "lt_times_lt_pos2") (("" (skosimp) (("" (inst -1 "nny!1" "pw!1" "z!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_times_lt_pos2 formula-decl nil real_props nil)) nil)) (gt_div_gt_pos1_TCC1 0 (gt_div_gt_pos1_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (gt_div_gt_pos1 subtype "real_props.z" "nznum"))) (gt_div_gt_pos1 0 (gt_div_gt_pos1-1 nil 3237052399 ("" (lemma "lt_div_lt_pos1") (("" (skosimp) (("" (inst -1 "py!1" "pw!1" "z!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_div_lt_pos1 formula-decl nil real_props nil)) nil)) (gt_div_gt_pos2_TCC1 0 (gt_div_gt_pos2_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (gt_div_gt_pos2 subtype "real_props.z" "nznum"))) (gt_div_gt_pos2 0 (gt_div_gt_pos2-1 nil 3237052399 ("" (lemma "lt_div_lt_pos2") (("" (skosimp) (("" (inst -1 "nny!1" "pw!1" "z!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_div_lt_pos2 formula-decl nil real_props nil)) nil)) (gt_times_gt_neg1 0 (gt_times_gt_neg1-1 nil 3237052399 ("" (lemma "lt_times_lt_neg1") (("" (skosimp) (("" (inst -1 "npz!1" "nx!1" "y!1" "w!1") (("" (grind) nil nil)) nil)) nil)) nil) ((npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_times_lt_neg1 formula-decl nil real_props nil)) nil)) (gt_times_gt_neg2 0 (gt_times_gt_neg2-1 nil 3237052399 ("" (lemma "lt_times_lt_neg2") (("" (skosimp) (("" (inst -1 "npx!1" "nz!1" "y!1" "w!1") (("" (grind) nil nil)) nil)) nil)) nil) ((npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_times_lt_neg2 formula-decl nil real_props nil)) nil)) (gt_div_gt_neg1_TCC1 0 (gt_div_gt_neg1_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (gt_div_gt_neg1 subtype "real_props.w" "nznum"))) (gt_div_gt_neg1 0 (gt_div_gt_neg1-1 nil 3237052399 ("" (lemma "lt_div_lt_neg1") (("" (skosimp) (("" (inst -1 "nz!1" "nx!1" "y!1" "w!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_div_lt_neg1 formula-decl nil real_props nil)) nil)) (gt_div_gt_neg2_TCC1 0 (gt_div_gt_neg2_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (gt_div_gt_neg2 subtype "real_props.w" "nznum"))) (gt_div_gt_neg2 0 (gt_div_gt_neg2-1 nil 3237052399 ("" (lemma "lt_div_lt_neg2") (("" (skosimp) (("" (inst -1 "npx!1" "nz!1" "y!1" "w!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (lt_div_lt_neg2 formula-decl nil real_props nil)) nil)) (total_ge 0 (total_ge-1 nil 3252308047 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (dichotomous? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil)) shostak)) (dich_ge 0 (dich_ge-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (zero_ge_zero 0 (zero_ge_zero-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil)) (neg_ge 0 (neg_ge-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (pos_times_ge 0 (pos_times_ge-1 nil 3237052399 ("" (lemma "pos_times_le") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_times_le formula-decl nil real_props nil)) nil)) (neg_times_ge 0 (neg_times_ge-1 nil 3237052399 ("" (lemma "neg_times_le") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (neg_times_le formula-decl nil real_props nil)) nil)) (quotient_pos_ge 0 (quotient_pos_ge-1 nil 3237052399 ("" (lemma "quotient_pos_le") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (quotient_pos_le formula-decl nil real_props nil)) nil)) (quotient_neg_ge 0 (quotient_neg_ge-1 nil 3237052399 ("" (lemma "quotient_neg_le") (("" (skosimp) (("" (grind) nil nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (quotient_neg_le formula-decl nil real_props nil)) nil)) (pos_div_ge 0 (pos_div_ge-1 nil 3237052399 ("" (lemma "pos_div_le") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pos_div_le formula-decl nil real_props nil)) nil)) (neg_div_ge 0 (neg_div_ge-1 nil 3237052399 ("" (lemma "neg_div_le") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (neg_div_le formula-decl nil real_props nil)) nil)) (div_mult_pos_ge1 0 (div_mult_pos_ge1-1 nil 3237052399 ("" (lemma "div_mult_pos_le2") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_pos_le2 formula-decl nil real_props nil)) nil)) (div_mult_pos_ge2 0 (div_mult_pos_ge2-1 nil 3237052399 ("" (lemma "div_mult_pos_le1") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_pos_le1 formula-decl nil real_props nil)) nil)) (div_mult_neg_ge1 0 (div_mult_neg_ge1-1 nil 3237052399 ("" (lemma "div_mult_neg_le2") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_neg_le2 formula-decl nil real_props nil)) nil)) (div_mult_neg_ge2 0 (div_mult_neg_ge2-1 nil 3237052399 ("" (lemma "div_mult_neg_le1") (("" (skosimp) (("" (inst?) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_mult_neg_le1 formula-decl nil real_props nil)) nil)) (both_sides_plus_ge1 0 (both_sides_plus_ge1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_plus_ge2 0 (both_sides_plus_ge2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_ge1 0 (both_sides_minus_ge1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_minus_ge2 0 (both_sides_minus_ge2-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (both_sides_times_pos_ge1 0 (both_sides_times_pos_ge1-1 nil 3237052399 ("" (lemma "both_sides_times_pos_le1") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_ge2 0 (both_sides_times_pos_ge2-1 nil 3237052399 ("" (lemma "both_sides_times_pos_le2") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_pos_le2 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_ge1 0 (both_sides_times_neg_ge1-1 nil 3237052399 ("" (lemma "both_sides_times_neg_le1") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_le1 formula-decl nil real_props nil)) nil)) (both_sides_times_neg_ge2 0 (both_sides_times_neg_ge2-1 nil 3237052399 ("" (lemma "both_sides_times_neg_le2") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_times_neg_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_ge1 0 (both_sides_div_pos_ge1-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le1") (("" (skosimp) (("" (inst -1 "pz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_ge2 0 (both_sides_div_pos_ge2-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le2") (("" (skosimp) (("" (inst -1 "py!1" "px!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_ge3 0 (both_sides_div_pos_ge3-1 nil 3237052399 ("" (lemma "both_sides_div_pos_le3") (("" (skosimp) (("" (inst -1 "nz!1" "py!1" "px!1") (("" (grind) nil nil)) nil)) nil)) nil) ((npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_pos_le3 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_ge1 0 (both_sides_div_neg_ge1-1 nil 3237052399 ("" (lemma "both_sides_div_neg_le1") (("" (skosimp) (("" (inst -1 "nz!1" "y!1" "x!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_le1 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_ge2 0 (both_sides_div_neg_ge2-1 nil 3237052399 ("" (lemma "both_sides_div_neg_le2") (("" (skosimp) (("" (inst -1 "ny!1" "nx!1" "pz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((nnreal_div_negreal_is_npreal application-judgement "npreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_neg_ge3 0 (both_sides_div_neg_ge3-1 nil 3237052399 ("" (lemma "both_sides_div_neg_le3") (("" (skosimp) (("" (inst -1 "ny!1" "nx!1" "nz!1") (("" (grind) nil nil)) nil)) nil)) nil) ((negreal_div_negreal_is_posreal application-judgement "posreal" real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_div_neg_le3 formula-decl nil real_props nil)) nil)) (ge_plus_ge 0 (ge_plus_ge-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (ge_minus_ge 0 (ge_minus_ge-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (ge_times_ge_pos 0 (ge_times_ge_pos-1 nil 3237052399 ("" (lemma "le_times_le_pos") (("" (skosimp) (("" (inst -1 "nny!1" "nnw!1" "z!1" "x!1") (("" (assert) nil nil)) nil)) nil)) nil) ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_times_le_pos formula-decl nil real_props nil)) nil)) (ge_div_ge_pos_TCC1 0 (ge_div_ge_pos_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (ge_div_ge_pos subtype "real_props.z" "nznum"))) (ge_div_ge_pos 0 (ge_div_ge_pos-1 nil 3237052399 ("" (lemma "le_div_le_pos") (("" (skosimp) (("" (inst -1 "nny!1" "pw!1" "z!1" "x!1") (("" (assert) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_div_le_pos formula-decl nil real_props nil)) nil)) (ge_times_ge_neg 0 (ge_times_ge_neg-1 nil 3237052399 ("" (lemma "le_times_le_neg") (("" (skosimp) (("" (inst -1 "npz!1" "npx!1" "y!1" "w!1") (("" (assert) nil nil)) nil)) nil)) nil) ((npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_times_le_neg formula-decl nil real_props nil)) nil)) (ge_div_ge_neg_TCC1 0 (ge_div_ge_neg_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (/= const-decl "boolean" notequal nil)) nil (ge_div_ge_neg subtype "real_props.w" "nznum"))) (ge_div_ge_neg 0 (ge_div_ge_neg-1 nil 3237052399 ("" (lemma "le_div_le_neg") (("" (skosimp*) (("" (inst -1 "npx!1" "nz!1" "y!1" "w!1") (("" (assert) nil nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_div_le_neg formula-decl nil real_props nil)) nil)) (nonzero_times1 0 (nonzero_times1-1 nil 3237052399 ("" (lemma "zero_times3") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (zero_times3 formula-decl nil real_props nil)) nil)) (nonzero_times2 0 (nonzero_times2-1 nil 3237052399 ("" (lemma "zero_times3") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (zero_times3 formula-decl nil real_props nil)) nil)) (nonzero_times3 0 (nonzero_times3-1 nil 3237052399 ("" (lemma "zero_times3") (("" (skosimp) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (zero_times3 formula-decl nil real_props nil)) nil)) (eq1_gt 0 (eq1_gt-2 "" 3505059980 ("" (skosimp) (("" (lemma "div_cancel3") (("" (inst -1 "y!1" "1" "x!1") (("1" (assert) (("1" (hide -3) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "div_mult_pos_ge2") (("1" (inst -1 "y!1" "1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_times3") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((div_cancel3 formula-decl nil real_props nil) (zero_times3 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (y!1 skolem-const-decl "real" real_props nil)) shostak) (eq1_gt-1 nil 3237052399 ("" (skosimp) (("" (lemma "div_cancel3") (("" (inst -1 "y!1" "1" "x!1") (("1" (assert) (("1" (hide -3) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "div_mult_pos_gt2") (("1" (inst -1 "y!1" "1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_times3") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((div_cancel3 formula-decl nil real_props nil) (zero_times3 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (eq1_ge 0 (eq1_ge-1 nil 3237052399 ("" (lemma "eq1_gt") (("" (skosimp) (("" (case "x!1 = 1") (("1" (assert) nil nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (eq1_gt formula-decl nil real_props nil)) nil)) (eqm1_gt 0 (eqm1_gt-1 nil 3237052399 ("" (skosimp) (("" (lemma "eq1_gt") (("" (inst -1 "x!1" "-y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((eq1_gt formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (eqm1_ge 0 (eqm1_ge-1 nil 3237052399 ("" (lemma "eq1_ge") (("" (skosimp) (("" (inst -1 "x!1" "-y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (eq1_ge formula-decl nil real_props nil)) nil)) (eqm1_lt 0 (eqm1_lt-1 nil 3237052399 ("" (skosimp) (("" (lemma "eq1_gt") (("" (inst -1 "-x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((eq1_gt formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (eqm1_le 0 (eqm1_le-1 nil 3237052399 ("" (lemma "eq1_ge") (("" (skosimp) (("" (inst -1 "-x!1" "y!1") (("" (grind) nil nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil) (eq1_ge formula-decl nil real_props nil)) nil)) (sqrt_1 0 (sqrt_1-1 nil 3237052399 ("" (skosimp*) (("" (ground) (("" (case "abs(x!1)>1") (("1" (lemma "eq1_gt") (("1" (inst -1 "abs(x!1)" "abs(x!1)") (("1" (assert) (("1" (expand "abs" 1) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "div_mult_pos_ge1") (("2" (inst -1 "abs(x!1)" "1" "1") (("1" (ground) (("1" (lemma "eq1_ge") (("1" (inst -1 "1/abs(x!1)" "1/abs(x!1)") (("1" (assert) (("1" (split) (("1" (case "abs(x!1) = 1") (("1" (assert) (("1" (expand "abs" -1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (rewrite "div_mult_pos_le1") (("2" (expand "abs" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (case "x!1 = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" 1) (("2" (lift-if) (("2" (prop) (("1" (rewrite "div_times") (("1" (assert) nil nil)) nil) ("2" (rewrite "div_times") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (expand "abs" 2) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = 0") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (expand "abs" 2) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_times formula-decl nil real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (eq1_ge formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (x!1 skolem-const-decl "real" real_props nil) (eq1_gt formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil)) (sqrt_1_lt 0 (sqrt_1_lt-1 nil 3237052399 ("" (skosimp*) (("" (case-replace "x!1 * x!1 - 1 < 0") (("1" (hide -2) (("1" (case-replace "x!1 * x!1 - 1 = (x!1 + 1)*(x!1 - 1)") (("1" (hide -1) (("1" (lemma "pos_times_lt") (("1" (inst?) (("1" (assert) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (pos_times_lt formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (sqrt_1_le 0 (sqrt_1_le-1 nil 3237052399 ("" (skosimp*) (("" (case-replace "x!1 * x!1 - 1 <= 0") (("1" (hide -2) (("1" (case-replace "x!1 * x!1 - 1 = (x!1 + 1)*(x!1 - 1)") (("1" (hide -1) (("1" (lemma "neg_times_le") (("1" (inst?) (("1" (assert) (("1" (hide -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (neg_times_le formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (idem_mult 0 (idem_mult-1 nil 3237052399 ("" (skosimp*) (("" (ground) (("" (lemma "div_cancel3") (("" (inst -1 "x!1" "x!1" "x!1") (("" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_cancel3 formula-decl nil real_props nil)) nil)) (product_1 0 (product_1-2 "Needed a :flush? t for some reason" 3299954096 ("" (skosimp) (("" (case "i!1 = 0") (("1" (grind) nil nil) ("2" (case "j!1 = 0") (("1" (grind) nil nil) ("2" (lemma "eq1_ge") (("2" (inst?) (("2" (lemma "eq1_ge") (("2" (inst -1 "j!1" "i!1") (("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_times_int_is_int application-judgement "int" integers nil) (eq1_ge formula-decl nil real_props nil)) shostak) (product_1-1 nil 3237052399 ("" (skosimp) (("" (case "i!1 = 0") (("1" (grind) nil nil) ("2" (case "j!1 = 0") (("1" (grind) nil nil) ("2" (lemma "eq1_ge") (("2" (inst?) (("2" (lemma "eq1_ge") (("2" (inst -1 "j!1" "i!1") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (product_m1 0 (product_m1-1 nil 3237052399 ("" (skosimp) (("" (lemma "product_1") (("" (inst -1 "i!1" "-j!1") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((product_1 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (triangle 0 (triangle-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil)) (abs_mult 0 (abs_mult-1 nil 3237052399 ("" (skosimp) (("" (lemma "neg_times_lt") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((neg_times_lt formula-decl nil real_props nil) (minus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (abs_div 0 (abs_div-1 nil 3237052399 ("" (skosimp*) (("" (lemma "pos_div_gt") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((pos_div_gt formula-decl nil real_props nil) (minus_real_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (abs_abs 0 (abs_abs-1 nil 3237052399 ("" (skosimp*) (("" (expand "abs") (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (abs_square 0 (abs_square-1 nil 3237052399 ("" (skosimp*) (("" (expand "abs") (("" (propax) nil nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (abs_limits 0 (abs_limits-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil)) (axiom_of_archimedes 0 (axiom_of_archimedes-2 "" 3299954306 ("" (lemma "real_complete") (("" (inst -1 "{x:real|EXISTS (z : int) : z=x}") (("1" (grind :if-match nil) (("1" (inst -4 "y!1 - 1") (("1" (reduce :if-match nil) (("1" (inst - "s!1 + 1") (("1" (assert) nil nil) ("2" (inst 1 "1 + s!1") (("2" (assert) (("2" (lemma "int_plus_int_is_int") (("2" (inst?) (("2" (assert) (("2" (lemma "rat_plus_rat_is_rat") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil) ("2" (delete 2) (("2" (grind) (("2" (inst - "0") (("2" (assert) (("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (s!1 skolem-const-decl "({x: real | EXISTS (z: int): z = x})" real_props nil) (rat_plus_rat_is_rat judgement-tcc nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (int_plus_int_is_int judgement-tcc nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_complete formula-decl nil bounded_real_defs nil)) shostak) (axiom_of_archimedes-1 nil 3237052399 ("" (lemma "real_complete") (("" (inst -1 "{x:real|EXISTS (z : int) : z=x}") (("1" (grind :if-match nil) (("1" (inst -4 "y!1 - 1") (("1" (reduce :if-match nil) (("1" (inst - "s!1 + 1") (("1" (assert) nil nil) ("2" (lemma "int_plus_int_is_int") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil) ("2" (delete 2) (("2" (grind) (("2" (inst - "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (archimedean 0 (archimedean-1 nil 3237052399 ("" (skolem!) (("" (lemma "axiom_of_archimedes" ("x" "1/px!1")) (("" (skolem!) (("" (assert) (("" (inst + "i!1") (("" (rewrite "div_mult_pos_lt1") (("" (rewrite "div_mult_pos_lt1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (axiom_of_archimedes formula-decl nil real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil)) nil)) (real_lt_is_strict_total_order 0 (real_lt_is_strict_total_order-1 nil 3252221044 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (trichotomous? const-decl "bool" orders nil) (strict_total_order? const-decl "bool" orders nil)) shostak (real_lt_is_strict_total_order subtype "reals.<" "(orders[real].strict_total_order?)"))) (real_le_is_total_order 0 (real_le_is_total_order-1 nil 3252221044 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (dichotomous? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil)) shostak (real_le_is_total_order subtype "reals.<=" "(orders[real].total_order?)"))) (real_gt_is_strict_total_order 0 (real_gt_is_strict_total_order-1 nil 3252221044 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (trichotomous? const-decl "bool" orders nil) (strict_total_order? const-decl "bool" orders nil)) shostak (real_gt_is_strict_total_order subtype "reals.>" "(orders[real].strict_total_order?)"))) (real_ge_is_total_order 0 (real_ge_is_total_order-1 nil 3252221044 ("" (grind) nil nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (dichotomous? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil)) shostak (real_ge_is_total_order subtype "reals.>=" "(orders[real].total_order?)"))))(extra_real_props (pos_neg_split 0 (pos_neg_split-1 nil 3505061062 ("" (skosimp*) (("" (inst 1 "abs(n0x!1)" "-abs(n0x!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (< const-decl "bool" reals nil) (n0x!1 skolem-const-decl "nonzero_real" extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil)) nil)) (div_mult_pos_neg_lt1 0 (div_mult_pos_neg_lt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_lt1 formula-decl nil real_props nil) (div_mult_neg_lt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (div_mult_pos_neg_lt2 0 (div_mult_pos_neg_lt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_neg_lt2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (div_mult_pos_neg_le1 0 (div_mult_pos_neg_le1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_le1 formula-decl nil real_props nil) (div_mult_neg_le1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (div_mult_pos_neg_le2 0 (div_mult_pos_neg_le2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_le2 formula-decl nil real_props nil) (div_mult_neg_le2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (div_mult_pos_neg_gt1 0 (div_mult_pos_neg_gt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (skosimp) (("" (prop) (("1" (mult-by -2 "n0y!1") nil nil) ("2" (mult-by -1 "n0y!1" -) nil nil) ("3" (assert) (("3" (lemma "div_mult_pos_ge2") (("3" (inst -1 "n0y!1" "x!1" "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "div_mult_neg_ge2") (("4" (inst -1 "n0y!1" "x!1" "z!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((div_mult_neg_ge2 formula-decl nil real_props nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_neg_gt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (n0y!1 skolem-const-decl "nonzero_real" extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_cancel2 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_mult_pos_neg_gt2 0 (div_mult_pos_neg_gt2-2 "" 3505092622 ("" (skosimp) (("" (prop) (("1" (lemma "div_mult_pos_ge1") (("1" (inst -1 "n0y!1" "x!1" "z!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "div_mult_neg_ge1") (("2" (inst -1 "n0y!1" "x!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "div_mult_pos_ge1") (("3" (inst -1 "n0y!1" "x!1" "z!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("4" (lemma "div_mult_neg_ge2") (("4" (inst -1 "n0y!1" "x!1" "z!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (n0y!1 skolem-const-decl "nonzero_real" extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_neg_ge2 formula-decl nil real_props nil)) shostak) (div_mult_pos_neg_gt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_neg_ge2 formula-decl nil real_props nil)) nil)) (div_mult_pos_neg_ge1 0 (div_mult_pos_neg_ge1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_ge1 formula-decl nil real_props nil) (div_mult_neg_ge1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (div_mult_pos_neg_ge2 0 (div_mult_pos_neg_ge2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_ge2 formula-decl nil real_props nil) (div_mult_neg_ge2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (both_sides_times_pos_neg_lt1 0 (both_sides_times_pos_neg_lt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_lt1 formula-decl nil real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_lt2 0 (both_sides_times_pos_neg_lt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_lt2 formula-decl nil real_props nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_le1 0 (both_sides_times_pos_neg_le1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_le1 formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_le2 0 (both_sides_times_pos_neg_le2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_le2 formula-decl nil real_props nil) (both_sides_times_pos_le2 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_gt1 0 (both_sides_times_pos_neg_gt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_gt1 formula-decl nil real_props nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_gt2 0 (both_sides_times_pos_neg_gt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_gt2 formula-decl nil real_props nil) (both_sides_times_pos_gt2 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_ge1 0 (both_sides_times_pos_neg_ge1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_ge1 formula-decl nil real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil)) nil)) (both_sides_times_pos_neg_ge2 0 (both_sides_times_pos_neg_ge2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_ge2 formula-decl nil real_props nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_lt1 0 (both_sides_div_pos_neg_lt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_lt1 formula-decl nil real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_lt2 0 (both_sides_div_pos_neg_lt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_lt3 0 (both_sides_div_pos_neg_lt3-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_lt3 formula-decl nil real_props nil) (both_sides_div_neg_lt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_le1 0 (both_sides_div_pos_neg_le1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_le1 formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_le2 0 (both_sides_div_pos_neg_le2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_le2 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (both_sides_div_pos_le2 formula-decl nil real_props nil) (both_sides_times_neg_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_le3 0 (both_sides_div_pos_neg_le3-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_le3 formula-decl nil real_props nil) (both_sides_div_neg_le2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_gt1 0 (both_sides_div_pos_neg_gt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_gt1 formula-decl nil real_props nil) (both_sides_div_pos_gt1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_gt2 0 (both_sides_div_pos_neg_gt2-2 "" 3717231822 ("" (skosimp) (("" (lemma "both_sides_div_pos_neg_lt2") (("" (inst - "n0z!1" "py!1" " px!1") (("" (grind) nil nil)) nil)) nil)) nil) ((both_sides_div_pos_neg_lt2 formula-decl nil extra_real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (both_sides_div_pos_neg_gt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_pos_neg_lt2 formula-decl nil extra_real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_div_pos_neg_gt3 0 (both_sides_div_pos_neg_gt3-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_gt3 formula-decl nil real_props nil) (both_sides_div_neg_gt2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_ge1 0 (both_sides_div_pos_neg_ge1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_ge1 formula-decl nil real_props nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_ge2 0 (both_sides_div_pos_neg_ge2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (both_sides_div_pos_ge2 formula-decl nil real_props nil) (both_sides_times_neg_ge2 formula-decl nil real_props nil)) nil)) (both_sides_div_pos_neg_ge3 0 (both_sides_div_pos_neg_ge3-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_div_neg_ge3 formula-decl nil real_props nil) (both_sides_div_neg_ge2 formula-decl nil real_props nil)) nil)) (both_sides_times1_imp 0 (both_sides_times1_imp-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (both_sides_times2_imp 0 (both_sides_times2_imp-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (both_sides_times_pos_le1_imp 0 (both_sides_times_pos_le1_imp-1 nil 3505061062 ("" (grind) (("" (case "nnw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_pos_le1") nil nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) nil)) (both_sides_times_pos_le2_imp 0 (both_sides_times_pos_le2_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "nnw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_pos_le2") nil nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_neg_le1_imp 0 (both_sides_times_neg_le1_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "npw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_neg_le1") nil nil)) nil)) nil) ((nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (both_sides_times_neg_le1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_neg_le2_imp 0 (both_sides_times_neg_le2_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "npw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_neg_le2") nil nil)) nil)) nil) ((nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (both_sides_times_neg_le2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_pos_ge1_imp 0 (both_sides_times_pos_ge1_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "nnw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_pos_ge1") nil nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_pos_ge2_imp 0 (both_sides_times_pos_ge2_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "nnw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_pos_ge2") nil nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_neg_ge1_imp 0 (both_sides_times_neg_ge1_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "npw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_neg_ge1") nil nil)) nil)) nil) ((nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (both_sides_times_neg_ge1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_neg_ge2_imp 0 (both_sides_times_neg_ge2_imp-1 nil 3505061062 ("" (skosimp*) (("" (case "npw!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "both_sides_times_neg_ge2") nil nil)) nil)) nil) ((nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (both_sides_times_neg_ge2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (both_sides_times_pos_neg_le1_imp 0 (both_sides_times_pos_neg_le1_imp-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_le1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (both_sides_times_pos_neg_le2_imp 0 (both_sides_times_pos_neg_le2_imp-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_le2 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (both_sides_times_pos_neg_ge1_imp 0 (both_sides_times_pos_neg_ge1_imp-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_ge1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (both_sides_times_pos_neg_ge2_imp 0 (both_sides_times_pos_neg_ge2_imp-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_ge2 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (zero_times4 0 (zero_times4-1 nil 3505061062 ("" (skosimp*) (("" (use "zero_times3") (("" (ground) nil nil)) nil)) nil) ((zero_times3 formula-decl nil real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (times_div_cancel1 0 (times_div_cancel1-1 nil 3505061062 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (times_div_cancel2 0 (times_div_cancel2-1 nil 3505061062 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_mult_pos_gt1 0 (div_mult_pos_gt1-2 "" 3505095167 ("" (auto-rewrite-theory "real_props") (("" (skosimp) (("" (prop) (("1" (mult-by -1 "py!1" +) nil nil) ("2" (lemma "div_mult_pos_neg_gt1") (("2" (inst -1 "py!1" "x!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_cancel2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak) (div_mult_pos_gt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((div_mult_pos_neg_gt1 formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_cancel2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_mult_pos_gt2 0 (div_mult_pos_gt2-2 "" 3505095229 ("" (skosimp) (("" (prop) (("1" (mult-by -1 "py!1" +) nil nil) ("2" (lemma "div_mult_pos_neg_gt2") (("2" (inst -1 "py!1" "x!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((both_sides_times_pos_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_neg_gt2 formula-decl nil extra_real_props nil)) shostak) (div_mult_pos_gt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_pos_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_neg_gt2 formula-decl nil extra_real_props nil)) nil)) (div_mult_neg_gt1 0 (div_mult_neg_gt1-2 "" 3505095500 ("" (skosimp) (("" (prop) (("1" (mult-by -1 "ny!1" -) nil nil) ("2" (lemma "div_mult_neg_le1") (("2" (inst -1 "ny!1" "x!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (both_sides_times_neg_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_neg_le1 formula-decl nil real_props nil)) shostak) (div_mult_neg_gt1-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (both_sides_times_neg_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_neg_le1 formula-decl nil real_props nil)) nil)) (div_mult_neg_gt2 0 (div_mult_neg_gt2-2 "" 3505095550 ("" (skosimp) (("" (prop) (("1" (mult-by -1 "ny!1" -) nil nil) ("2" (lemma "div_mult_neg_le2") (("2" (inst -1 "ny!1" "x!1" "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((both_sides_times_neg_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_neg_le2 formula-decl nil real_props nil)) shostak) (div_mult_neg_gt2-1 nil 3505061062 ("" (auto-rewrite-theory "real_props") (("" (grind) nil nil)) nil) ((both_sides_times_neg_gt1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_neg_le2 formula-decl nil real_props nil)) nil)) (lt_cut 0 (lt_cut-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (le_cut 0 (le_cut-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (gt_cut 0 (gt_cut-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge_cut 0 (ge_cut-1 nil 3505061062 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (le_times_le_any1 0 (le_times_le_any1-1 nil 3505061062 ("" (skosimp*) (("" (split) (("1" (flatten) (("1" (split -3) (("1" (expand "abs") (("1" (ground) (("1" (rewrite "le_times_le_pos") nil nil) ("2" (lemma "le_times_le_pos") (("2" (inst -1 "-w!1" "-x!1" "z!1" "y!1") (("2" (ground) nil nil)) nil)) nil) ("3" (lemma "le_times_le_pos") (("3" (inst -1 "w!1" "x!1" "-z!1" "-y!1") (("3" (ground) nil nil)) nil)) nil) ("4" (rewrite "le_times_le_neg") nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (use "neg_times_le") (("1" (lemma "pos_times_le") (("1" (inst -1 "y!1" "z!1") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lemma "ge_times_ge_pos") (("2" (ground) (("1" (inst -3 "-z!1" "y!1" "w!1" "-x!1") (("1" (ground) nil nil)) nil) ("2" (inst -3 "-z!1" "y!1" "-w!1" "x!1") (("2" (ground) nil nil)) nil) ("3" (inst -3 "z!1" "-y!1" "w!1" "-x!1") (("3" (ground) nil nil)) nil) ("4" (inst -3 "z!1" "-y!1" "-w!1" "x!1") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_times_le_pos formula-decl nil real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (le_times_le_neg formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (pos_times_le formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (ge_times_ge_pos formula-decl nil real_props nil)) nil)) (ge_times_ge_any1 0 (ge_times_ge_any1-1 nil 3505061062 ("" (skosimp*) (("" (split) (("1" (flatten) (("1" (split -3) (("1" (expand "abs") (("1" (ground) (("1" (rewrite "ge_times_ge_pos") nil nil) ("2" (lemma "ge_times_ge_pos") (("2" (inst -1 "-z!1" "-y!1" "w!1" "x!1") (("2" (ground) nil nil)) nil)) nil) ("3" (lemma "ge_times_ge_pos") (("3" (inst -1 "z!1" "y!1" "-w!1" "-x!1") (("3" (ground) nil nil)) nil)) nil) ("4" (rewrite "ge_times_ge_neg") nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (use "pos_times_ge") (("1" (lemma "neg_times_ge") (("1" (inst -1 "y!1" "z!1") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "abs") (("2" (lemma "le_times_le_pos") (("2" (ground) (("1" (inst -3 "w!1" "-x!1" "-z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (inst -3 "w!1" "-x!1" "z!1" "-y!1") (("2" (ground) nil nil)) nil) ("3" (inst -3 "-w!1" "x!1" "-z!1" "y!1") (("3" (ground) nil nil)) nil) ("4" (inst -3 "-w!1" "x!1" "z!1" "-y!1") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ge_times_ge_pos formula-decl nil real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (ge_times_ge_neg formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (neg_times_ge formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (le_times_le_pos formula-decl nil real_props nil)) nil)) (lt_times_lt_any1 0 (lt_times_lt_any1-1 nil 3505061062 ("" (skosimp*) (("" (split) (("1" (lemma "pos_times_lt") (("1" (inst -1 "y!1" "z!1") (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (lemma "lt_times_lt_pos1") (("1" (lemma "lt_times_lt_pos2") (("1" (expand "abs") (("1" (ground) (("1" (inst -8 "x!1" "w!1" "z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (inst -7 "w!1" "x!1" "z!1" "y!1") (("2" (ground) nil nil)) nil) ("3" (inst -6 "x!1" "w!1" "-z!1" "-y!1") (("3" (smash) nil nil)) nil) ("4" (inst -5 "w!1" "x!1" "-z!1" "-y!1") (("4" (smash) nil nil)) nil) ("5" (inst -6 "-x!1" "-w!1" "z!1" "y!1") (("5" (ground) nil nil)) nil) ("6" (inst -5 "-w!1" "-x!1" "z!1" "y!1") (("6" (ground) nil nil)) nil) ("7" (inst -4 "-x!1" "-w!1" "-z!1" "-y!1") (("7" (smash) nil nil)) nil) ("8" (inst -3 "-w!1" "-x!1" "-z!1" "-y!1") (("8" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1 1) (("1" (use "neg_times_lt") (("1" (lemma "pos_times_lt") (("1" (inst -1 "y!1" "z!1") (("1" (smash) nil nil)) nil)) nil)) nil) ("2" (lemma "gt_times_gt_pos1") (("2" (lemma "gt_times_gt_pos2") (("2" (expand "abs") (("2" (ground) (("1" (inst -6 "-z!1" "y!1" "w!1" "-x!1") (("1" (ground) nil nil)) nil) ("2" (inst -6 "-z!1" "y!1" "-w!1" "x!1") (("2" (ground) nil nil)) nil) ("3" (smash) (("1" (inst -6 "y!1" "-z!1" "w!1" "-x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil) ("4" (smash) (("1" (inst -6 "y!1" "-z!1" "-w!1" "x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil) ("5" (smash) (("1" (inst -7 "z!1" "-y!1" "w!1" "-x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil) ("6" (smash) (("1" (inst -7 "z!1" "-y!1" "-w!1" "x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil) ("7" (smash) (("1" (inst -6 "-y!1" "z!1" "w!1" "-x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil) ("8" (smash) (("1" (inst -6 "-y!1" "z!1" "-w!1" "x!1") (("1" (ground) nil nil)) nil) ("2" (use "neg_times_lt") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (pos_times_lt formula-decl nil real_props nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (gt_times_gt_pos2 formula-decl nil real_props nil) (gt_times_gt_pos1 formula-decl nil real_props nil)) nil)) (gt_times_gt_any1 0 (gt_times_gt_any1-1 nil 3505061062 ("" (skosimp*) (("" (split) (("1" (lemma "pos_times_gt") (("1" (inst -1 "w!1" "x!1") (("1" (ground) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (lemma "gt_times_gt_pos1") (("1" (lemma "gt_times_gt_pos2") (("1" (expand "abs") (("1" (ground) (("1" (inst -8 "z!1" "y!1" "w!1" "x!1") (("1" (ground) nil nil)) nil) ("2" (inst -7 "y!1" "z!1" "w!1" "x!1") (("2" (ground) nil nil)) nil) ("3" (inst -6 "z!1" "y!1" "-w!1" "-x!1") (("3" (smash) nil nil)) nil) ("4" (inst -5 "y!1" "z!1" "-w!1" "-x!1") (("4" (smash) nil nil)) nil) ("5" (inst -6 "-z!1" "-y!1" "w!1" "x!1") (("5" (ground) nil nil)) nil) ("6" (inst -5 "-y!1" "-z!1" "w!1" "x!1") (("6" (ground) nil nil)) nil) ("7" (inst -4 "-z!1" "-y!1" "-w!1" "-x!1") (("7" (smash) nil nil)) nil) ("8" (inst -3 "-y!1" "-z!1" "-w!1" "-x!1") (("8" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1 1) (("1" (use "pos_times_gt") (("1" (lemma "neg_times_gt") (("1" (inst -1 "y!1" "z!1") (("1" (smash) nil nil)) nil)) nil)) nil) ("2" (lemma "lt_times_lt_pos1") (("2" (lemma "lt_times_lt_pos2") (("2" (expand "abs") (("2" (ground) (("1" (inst -6 "-x!1" "w!1" "-z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (inst -6 "-x!1" "w!1" "z!1" "-y!1") (("2" (ground) nil nil)) nil) ("3" (smash) (("1" (inst -6 "w!1" "-x!1" "-z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("4" (smash) (("1" (inst -6 "w!1" "-x!1" "z!1" "-y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("5" (smash) (("1" (inst -7 "x!1" "-w!1" "-z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("6" (smash) (("1" (inst -7 "x!1" "-w!1" "z!1" "-y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("7" (smash) (("1" (inst -6 "-w!1" "x!1" "-z!1" "y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil) ("8" (smash) (("1" (inst -6 "-w!1" "x!1" "z!1" "-y!1") (("1" (ground) nil nil)) nil) ("2" (lemma "neg_times_gt") (("2" (inst -1 "y!1" "z!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (pos_times_gt formula-decl nil real_props nil) (gt_times_gt_pos1 formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (gt_times_gt_pos2 formula-decl nil real_props nil) (neg_times_gt formula-decl nil real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_times_lt_pos1 formula-decl nil real_props nil)) nil)) (le_times_le_any2 0 (le_times_le_any2-1 nil 3505061062 ("" (skosimp*) (("" (lemma "gt_times_gt_any1") (("" (inst -1 "w!1" "x!1" "y!1" "z!1") (("" (ground) nil nil)) nil)) nil)) nil) ((gt_times_gt_any1 formula-decl nil extra_real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (ge_times_ge_any2 0 (ge_times_ge_any2-1 nil 3505061062 ("" (skosimp*) (("" (lemma "lt_times_lt_any1") (("" (inst -1 "w!1" "x!1" "y!1" "z!1") (("" (ground) nil nil)) nil)) nil)) nil) ((lt_times_lt_any1 formula-decl nil extra_real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (lt_times_lt_any2 0 (lt_times_lt_any2-1 nil 3505061062 ("" (skosimp*) (("" (lemma "ge_times_ge_any1") (("" (inst -1 "w!1" "x!1" "y!1" "z!1") (("" (ground) nil nil)) nil)) nil)) nil) ((ge_times_ge_any1 formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (gt_times_gt_any2 0 (gt_times_gt_any2-1 nil 3505061062 ("" (skosimp*) (("" (lemma "le_times_le_any1") (("" (inst -1 "w!1" "x!1" "y!1" "z!1") (("" (ground) nil nil)) nil)) nil)) nil) ((le_times_le_any1 formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)))(extra_tegies (neg_mult 0 (neg_mult-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (mult_neg 0 (mult_neg-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (neg_add 0 (neg_add-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil)) nil)) (add_neg 0 (add_neg-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil)) nil)) (neg_div 0 (neg_div-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (div_neg 0 (div_neg-1 nil 3505061119 ("" (grind) nil nil) ((minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil)) (one_times 0 (one_times-1 nil 3505061119 ("" (grind) nil nil) nil nil)) (neg_one_times 0 (neg_one_times-1 nil 3564901186 ("" (grind) nil nil) nil shostak)) (zero_div 0 (zero_div-1 nil 3505061119 ("" (grind) nil nil) nil nil)) (neg_neg 0 (neg_neg-1 nil 3505061119 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil)) nil)))(rational_props (rational_pred_ax2 0 (rational_pred_ax2-1 nil 3243832709 ("" (skosimp) (("" (lemma "rational_pred_ax") (("" (inst?) (("" (skosimp) (("" (case "n0j!1 > 0") (("1" (inst 1 "i!1" "n0j!1") (("1" (assert) nil nil)) nil) ("2" (inst 2 "-i!1" "-n0j!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rational_pred_ax formula-decl nil rational_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (n0j!1 skolem-const-decl "nzint" rational_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (density_positive 0 (density_positive-1 nil 3237052399 ("" (skosimp) (("" (assert) (("" (lemma "archimedean" ("px" "y!1 - x!1")) (("" (skolem!) (("" (lemma "posreal_mult_closed" ("x" "y!1" "y" "n!1")) (("" (ground) (("" (lemma "wf_nat") (("" (expand "well_founded?") (("" (inst -1 "LAMBDA (n : nat) : y!1 * n!1 <= n") (("" (reduce :if-match nil) (("1" (auto-rewrite "div_mult_pos_lt1" "div_mult_pos_lt2") (("1" (inst + "(y!2 - 1)/n!1") (("1" (assert) (("1" (inst - "y!2 -1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "axiom_of_archimedes" ("x" "y!1 * n!1")) (("2" (skolem!) (("2" (assert) (("2" (inst + "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (well_founded? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (rat nonempty-type-eq-decl nil rationals nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (axiom_of_archimedes formula-decl nil real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (wf_nat formula-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal_mult_closed formula-decl nil real_axioms nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (archimedean formula-decl nil real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (density 0 (density-1 nil 3237052399 ("" (lemma "density_positive") (("" (skosimp) (("" (case "x!1 >= 0") (("1" (inst? -) (("1" (assert) nil nil)) nil) ("2" (lemma "axiom_of_archimedes" ("x" "-x!1")) (("2" (skosimp) (("2" (inst -2 "i!1 + x!1" "i!1 + y!1") (("2" (assert) (("2" (skosimp) (("2" (inst 2 "r!1 - i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (axiom_of_archimedes formula-decl nil real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rat nonempty-type-eq-decl nil rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (density_positive formula-decl nil rational_props nil)) nil)))(integer_props (integer_pred_ax 0 (integer_pred_ax-1 nil 3237052399 ("" (skosimp*) (("" (case "i!1 >= 0") (("1" (inst 1 "i!1") nil nil) ("2" (inst 2 "-i!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (i!1 skolem-const-decl "int" integer_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (div_simple 0 (div_simple-1 nil 3237052399 ("" (grind :if-match nil) (("" (inst 2 "i!1/n0j!1") (("" (assert) nil nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil)) (lub_nat_TCC1 0 (lub_nat_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (extend const-decl "R" extend nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (lub_nat subtype "extend[real, nat, booleans.bool, booleans.FALSE].extend(integer_props.N)" "(sets[real].nonempty?)"))) (lub_nat 0 (lub_nat-2 "" 3299954571 ("" (induct "m") (("1" (skosimp*) (("1" (expand "upper_bound?") (("1" (typepred "N!1") (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "member") (("1" (inst 1 "x!1") (("1" (expand "least_upper_bound?") (("1" (split) (("1" (expand "upper_bound?") (("1" (skosimp*) (("1" (inst -2 "s!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "upper_bound?") (("2" (inst -1 "x!1") (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -1 "N!1") (("2" (assert) (("2" (replace 1) (("2" (assert) (("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (inst 2 "s!1") (("1" (expand "least_upper_bound?") (("1" (split) (("1" (expand "upper_bound?") (("1" (skosimp*) (("1" (inst -1 "s!2") (("1" (assert) (("1" (case "forall (i, j: int): i < j iff i + 1 <= j") (("1" (inst -1 "s!1" "s!2") (("1" (assert) nil nil) ("2" (typepred "s!2") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil) ("3" (typepred "s!1") (("3" (expand "extend") (("3" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (ground) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "upper_bound?") (("2" (inst -1 "s!1") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "s!1") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (skosimp) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (typepred "N!1") (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (skosimp) (("3" (inst -3 "x!1") (("3" (expand "member") (("3" (expand "extend") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (typepred "N!1") (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -2 "x!1") (("4" (expand "extend") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (s!2 skolem-const-decl "(extend[real, nat, bool, FALSE](N!1))" integer_props nil) (s!1 skolem-const-decl "(extend[real, nat, bool, FALSE](N!1))" integer_props nil) (N!1 skolem-const-decl "(nonempty?[nat])" integer_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!1 skolem-const-decl "nat" integer_props nil) (N!1 skolem-const-decl "(nonempty?[nat])" integer_props nil) (nat_induction formula-decl nil naturalnumbers nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil)) shostak) (lub_nat-1 nil 3237052399 ("" (induct "m") (("1" (skosimp*) (("1" (expand "upper_bound?") (("1" (typepred "N!1") (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "member") (("1" (inst 1 "x!1") (("1" (expand "least_upper_bound?") (("1" (split) (("1" (expand "upper_bound?") (("1" (skosimp*) (("1" (inst -2 "s!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "upper_bound?") (("2" (inst -1 "x!1") (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -1 "N!1") (("2" (assert) (("2" (replace 1) (("2" (assert) (("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (inst 2 "s!1") (("1" (expand "least_upper_bound?") (("1" (split) (("1" (expand "upper_bound?") (("1" (skosimp*) (("1" (inst -1 "s!2") (("1" (assert) (("1" (case "forall (i, j: int): i < j iff i + 1 <= j") (("1" (inst -1 "s!1" "s!2") (("1" (assert) nil nil) ("2" (typepred "s!2") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil) ("3" (typepred "s!1") (("3" (expand "extend") (("3" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "upper_bound?") (("2" (inst -1 "s!1") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "s!1") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (skosimp) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (typepred "N!1") (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (skosimp) (("3" (inst -3 "x!1") (("3" (expand "member") (("3" (expand "extend") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (typepred "N!1") (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -2 "x!1") (("4" (expand "extend") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (lub_int_TCC1 0 (lub_int_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (lub_int subtype "extend[real, int, booleans.bool, booleans.FALSE].extend(integer_props.I)" "(sets[real].nonempty?)"))) (lub_int 0 (lub_int-1 nil 3237052399 ("" (skosimp*) (("" (typepred "I!1") (("" (expand "nonempty?") (("" (expand "empty?") (("" (skosimp*) (("" (lemma "lub_nat") (("" (expand "member") (("" (inst - "{n|I!1(n+x!1)}" "i!1-x!1") (("1" (prop) (("1" (skosimp*) (("1" (inst + "n!1+x!1") (("1" (assert) (("1" (expand "least_upper_bound?") (("1" (prop) (("1" (expand "upper_bound?") (("1" (skosimp*) (("1" (assert) (("1" (inst - "s!1-x!1") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "extend") (("2" (split 1) (("1" (flatten) (("1" (typepred "s!1") (("1" (expand "extend") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "s!1") (("2" (expand "extend") (("2" (prop) (("1" (lemma "rat_minus_rat_is_rat") (("1" (inst?) nil nil)) nil) ("2" (lemma "int_minus_int_is_int") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "y!1-x!1") (("2" (assert) (("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (inst?) (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (typepred "s!1") (("2" (expand "extend" -1) (("2" (prop) (("2" (inst - "s!1+x!1") (("1" (assert) nil nil) ("2" (expand "extend" 1) (("2" (prop) (("1" (lemma "rat_plus_rat_is_rat") (("1" (inst?) nil nil)) nil) ("2" (lemma "int_plus_int_is_int") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "upper_bound?") (("2" (inst -2 "x!1") (("1" (assert) nil nil) ("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (inst -1 "0") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (empty? const-decl "bool" sets nil) (lub_nat formula-decl nil integer_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (I!1 skolem-const-decl "(nonempty?[int])" integer_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "int" integer_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i!1 skolem-const-decl "int" integer_props nil) (int_plus_int_is_int judgement-tcc nil integers nil) (rat_plus_rat_is_rat judgement-tcc nil rationals nil) (s!1 skolem-const-decl "(extend[real, nat, bool, FALSE]({n | I!1(n + x!1)}))" integer_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE](I!1))" integer_props nil) (rat nonempty-type-eq-decl nil rationals nil) (rat_minus_rat_is_rat judgement-tcc nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int judgement-tcc nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (n!1 skolem-const-decl "({n | I!1(n + x!1)})" integer_props nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (member const-decl "bool" sets nil)) nil)) (glb_nat 0 (glb_nat-1 nil 3237052399 ("" (lemma "lub_int") (("" (skosimp*) (("" (inst -1 "{i: nonpos_int | N!1(-i)}" "0") (("1" (grind :if-match nil) (("1" (inst 1 "-j!1") (("1" (prop) (("1" (skosimp*) (("1" (inst -3 "-s!1") (("1" (assert) nil nil) ("2" (typepred "s!1") (("2" (expand "extend") (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lemma "minus_rat_is_rat") (("3" (inst -1 "s!1") nil nil)) nil)) nil) ("4" (lemma "minus_int_is_int") (("4" (inst -1 "s!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (skosimp*) (("2" (inst -4 "-y!1") (("2" (prop) (("1" (assert) nil nil) ("2" (skosimp*) (("2" (inst -1 "-s!1") (("1" (assert) nil nil) ("2" (typepred "s!1") (("2" (expand "extend") (("2" (prop) (("1" (lemma "minus_rat_is_rat") (("1" (inst -1 "s!1") nil nil)) nil) ("2" (lemma "minus_int_is_int") (("2" (inst -1 "s!1") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "extend") (("2" (typepred "N!1") (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skosimp*) (("2" (inst -2 "-x!1") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (lower_bound? const-decl "bool" bounded_real_defs nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (s!1 skolem-const-decl "(extend[real, nat, bool, FALSE](N!1))" integer_props nil) (minus_rat_is_rat judgement-tcc nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (minus_int_is_int judgement-tcc nil integers nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE]
     (extend[int, nonpos_int, bool, FALSE]({i: nonpos_int | N!1(-i)})))" integer_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (<= const-decl "bool" reals nil) (nonpos_int nonempty-type-eq-decl nil integers nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N!1 skolem-const-decl "(nonempty?[nat])" integer_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (lub_int formula-decl nil integer_props nil)) nil)) (glb_int 0 (glb_int-1 nil 3237052399 ("" (lemma "lub_int") (("" (skosimp*) (("" (inst -1 "{i: int | I!1(-i)}" "-i!1") (("1" (prop) (("1" (skosimp*) (("1" (grind :if-match nil) (("1" (inst 1 "-j!1") (("1" (prop) (("1" (skosimp*) (("1" (inst -1 "-s!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2) (("2" (typepred "s!1") (("2" (expand "extend") (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (lemma "minus_rat_is_rat") (("2" (inst -1 "s!1") nil nil)) nil) ("3" (lemma "minus_int_is_int") (("3" (inst -1 "s!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -3 "-y!1") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "-s!1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3) (("2" (typepred "s!1") (("2" (expand "extend") (("2" (assert) (("2" (ground) (("1" (lemma "minus_rat_is_rat") (("1" (inst -1 "s!1") nil nil)) nil) ("2" (lemma "minus_int_is_int") (("2" (inst -1 "s!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :if-match nil) (("2" (inst -4 "-s!1") (("1" (assert) nil nil) ("2" (hide -1 -2 -3 2) (("2" (typepred "s!1") (("2" (expand "extend") (("2" (ground) (("1" (lemma "minus_rat_is_rat") (("1" (inst -1 "s!1") nil nil)) nil) ("2" (lemma "minus_int_is_int") (("2" (inst -1 "s!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (typepred "I!1") (("2" (grind :if-match nil) (("2" (inst -3 "-x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (greatest_lower_bound? const-decl "bool" bounded_real_defs nil) (lower_bound? const-decl "bool" bounded_real_defs nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (minus_real_is_real application-judgement "real" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE](I!1))" integer_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_int_is_int judgement-tcc nil integers nil) (minus_rat_is_rat judgement-tcc nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE]({i: int | I!1(-i)}))" integer_props nil) (TRUE const-decl "bool" booleans nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE]({i: int | I!1(-i)}))" integer_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (I!1 skolem-const-decl "(nonempty?[int])" integer_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (lub_int formula-decl nil integer_props nil)) nil)))(floor_ceil (floor_exists 0 (floor_exists-1 nil 3237052399 ("" (skosimp*) (("" (lemma "lub_int") (("" (lemma "axiom_of_archimedes") (("" (inst?) (("" (skosimp*) (("" (inst - "{i|i<=x!1}" "i!1") (("1" (prop) (("1" (expand "least_upper_bound?") (("1" (skolem-typepred) (("1" (inst?) (("1" (prop) (("1" (expand "upper_bound?") (("1" (inst - "j!1+1") (("1" (assert) nil nil) ("2" (expand "extend") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upper_bound?") (("2" (skolem-typepred) (("2" (expand "extend") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nonempty_exists") (("2" (lemma "axiom_of_archimedes") (("2" (inst - "abs(x!1)") (("2" (skosimp*) (("2" (inst + "-i!2") (("2" (expand "abs") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lub_int formula-decl nil integer_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (x!1 skolem-const-decl "real" floor_ceil nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j!1 skolem-const-decl "({i | i <= x!1})" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (i!2 skolem-const-decl "int" floor_ceil nil) (minus_int_is_int application-judgement "int" integers nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonempty_exists formula-decl nil sets_lemmas nil) (axiom_of_archimedes formula-decl nil real_props nil)) nil)) (ceiling_exists 0 (ceiling_exists-1 nil 3237052399 ("" (skosimp*) (("" (case "integer?(x!1)") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (expand "integer?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "floor_exists") (("2" (inst?) (("2" (skosimp*) (("2" (inst + "i!1+1") (("2" (assert) (("2" (expand "integer?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (integer? const-decl "bool" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (x!1 skolem-const-decl "real" floor_ceil nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (floor_exists formula-decl nil floor_ceil nil)) nil)) (floor_TCC1 0 (floor_TCC1-1 nil 3237052399 ("" (inst + "lambda x: choose( {i: integer | i <= x & x < 1 + i})") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (lemma "floor_exists") (("" (skosimp*) (("" (inst?) (("" (skosimp*) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (floor_exists formula-decl nil floor_ceil nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real nonempty-type-from-decl nil reals nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (floor existence "" "[x: reals.real -> {i | booleans.&(reals.<=(floor_ceil.i, x), reals.<(x, (number_fields.+)(1, floor_ceil.i)))}]"))) (fractional_TCC1 0 (fractional_TCC1-1 nil 3237052399 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (fractional subtype "(number_fields.-)(floor_ceil.x, floor_ceil.floor(floor_ceil.x))" "{x | booleans.&(reals.<=(0, floor_ceil.x), reals.<(floor_ceil.x, 1))}"))) (ceiling_TCC1 0 (ceiling_TCC1-1 nil 3237052399 ("" (inst + "lambda x: choose( {i: integer | x <= i & i < x + 1})") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (lemma "ceiling_exists") (("" (skosimp*) (("" (inst - "x!1") (("" (skosimp*) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ceiling_exists formula-decl nil floor_ceil nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (ceiling existence "" "[x: reals.real -> {i | booleans.&(reals.<=(x, floor_ceil.i), reals.<(floor_ceil.i, (number_fields.+)(1, x)))}]"))) (floor_def 0 (floor_def-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ceiling_def 0 (ceiling_def-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (floor_ceiling_reflect1 0 (floor_ceiling_reflect1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (floor_ceiling_reflect2 0 (floor_ceiling_reflect2-1 nil 3237052399 ("" (grind) nil nil) ((minus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (nonneg_floor_is_nat 0 (nonneg_floor_is_nat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nonneg_floor_is_nat subtype "floor_ceil.floor(floor_ceil.x)" "nat"))) (nonneg_ceiling_is_nat 0 (nonneg_ceiling_is_nat-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nonneg_ceiling_is_nat subtype "floor_ceil.ceiling(floor_ceil.x)" "nat"))) (floor_int 0 (floor_int-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil)) nil)) (ceiling_int 0 (ceiling_int-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil)) nil)) (floor_plus_int 0 (floor_plus_int-1 nil 3237052399 ("" (skolem!) (("" (name "j!1" "floor(x!1+i!1)") (("" (name "k!1" "floor(x!1)") (("" (typepred "floor(i!1 + x!1)") (("" (typepred "floor(x!1)") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (ceiling_plus_int 0 (ceiling_plus_int-1 nil 3237052399 ("" (skolem!) (("" (lemma "ceiling_def") (("" (inst-cp - "x!1+i!1") (("" (flatten) (("" (name "j!1" "ceiling(x!1)") (("" (name "k!1" "ceiling(x!1+i!1)") (("" (replace -1) (("" (replace -2) (("" (inst - "x!1") (("" (replace -2) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ceiling_def formula-decl nil floor_ceil nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (ceiling const-decl "{i | x <= i & i < x + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (floor_ceiling_nonint 0 (floor_ceiling_nonint-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (integer? const-decl "bool" integers nil)) nil)) (floor_ceiling_int 0 (floor_ceiling_int-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil)) nil)) (floor_neg 0 (floor_neg-1 nil 3237052399 ("" (skosimp*) (("" (lift-if) (("" (prop) (("1" (rewrite "floor_int") (("1" (rewrite "floor_int") (("1" (assert) nil nil) ("2" (rewrite "closed_neg") (("1" (assert) (("1" (expand "integer?") (("1" (flatten) (("1" (rewrite "closed_neg") nil nil)) nil)) nil)) nil) ("2" (expand "integer?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "integer?") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "integer?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (floor_int formula-decl nil floor_ceil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (minus_int_is_int application-judgement "int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (rat nonempty-type-eq-decl nil rationals nil) (closed_neg formula-decl nil rationals nil) (integer? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (closed_neg formula-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil)) nil)) (real_parts 0 (real_parts-1 nil 3237052399 ("" (expand "fractional") (("" (propax) nil nil)) nil) ((fractional const-decl "{x | 0 <= x & x < 1}" floor_ceil nil)) nil)) (floor_plus 0 (floor_plus-2 "" 3237078783 ("" (skosimp) (("" (expand "fractional") (("" (lemma "floor_plus_int") (("" (inst -1 "-1 * floor(x!1) - floor(y!1)" "x!1 + y!1") (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (fractional const-decl "{x | 0 <= x & x < 1}" floor_ceil nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (floor_plus_int formula-decl nil floor_ceil nil)) shostak) (floor_plus-1 nil 3237052399 ("" (skolem!) (("" (expand "fractional") (("" (assert) nil nil)) nil)) nil) nil nil)) (ceiling_plus 0 (ceiling_plus-1 nil 3237052399 ("" (skolem!) (("" (expand "fractional") (("" (lemma "ceiling_plus_int") (("" (inst-cp -1 "-floor(x!1) - floor(y!1)" "x!1 + y!1") (("" (replace -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (fractional const-decl "{x | 0 <= x & x < 1}" floor_ceil nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ceiling_plus_int formula-decl nil floor_ceil nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil)) (floor_split 0 (floor_split-1 nil 3237052399 ("" (grind) nil nil) ((rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (floor_within_1 0 (floor_within_1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (ceiling_within_1 0 (ceiling_within_1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil)) (floor_val 0 (floor_val-2 "" 3299954653 ("" (grind :if-match nil) (("" (typepred "floor(i!1/j!1)") (("" (case "j!1 > 0") (("1" (case "i!1/j!1 >= k!1" "i!1/j!1 < k!1 + 1") (("1" (name-replace "q" "i!1/j!1") (("1" (hide -3 -6 -7 -8 -9 1) (("1" (assert) (("1" (assert :flush? t) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1 -2 -3 -4 -5 -6 -7 2 3) (("2" (assert) (("2" (use "div_mult_pos_lt1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 -5 -7 2 3) (("3" (use "div_mult_pos_ge1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (rat nonempty-type-eq-decl nil rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (> const-decl "bool" reals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak) (floor_val-1 nil 3237052399 ("" (grind :if-match nil) (("" (typepred "floor(i!1/j!1)") (("" (case "j!1 > 0") (("1" (case "i!1/j!1 >= k!1" "i!1/j!1 < k!1 + 1") (("1" (name-replace "q" "i!1/j!1") (("1" (hide -3 -6 -7 -8 -9 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide -1 -2 -3 -4 -5 -6 -7 2 3) (("2" (assert) (("2" (use "div_mult_pos_lt1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 -5 -7 2 3) (("3" (use "div_mult_pos_ge1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) nil nil)) (floor_small 0 (floor_small-1 nil 3237052399 ("" (skosimp) (("" (lift-if) (("" (prop) (("1" (case "i!1/j!1 < 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "(j!1 - i!1)/j!1 > 0") (("1" (assert) nil nil) ("2" (grind) (("1" (use "pos_div_gt") (("1" (assert) nil nil)) nil) ("2" (use "pos_div_gt") (("2" (assert) nil nil)) nil) ("3" (use "pos_div_gt") (("3" (assert) nil nil)) nil) ("4" (use "pos_div_gt") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "floor(i!1/j!1)") (("2" (case "i!1/j!1 >= -1") (("1" (assert) nil nil) ("2" (hide -1 -2 2 3) (("2" (case "(i!1 + j!1)/j!1 >= 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind :if-match nil) (("1" (use "pos_div_ge") (("1" (assert) nil nil)) nil) ("2" (use "pos_div_ge") (("2" (assert) nil nil)) nil) ("3" (use "pos_div_ge") (("3" (assert) nil nil)) nil) ("4" (use "pos_div_ge") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pos_div_ge formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (pos_div_gt formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) nil)) (floor_eq_0 0 (floor_eq_0-1 nil 3237052399 ("" (skosimp) (("" (typepred "floor(x!1)") (("" (assert) nil nil)) nil)) nil) ((floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (fractional_plus 0 (fractional_plus-1 nil 3307951383 ("" (skosimp*) (("" (lemma "floor_plus" ("x" "x!1" "y" "y!1")) (("" (expand "fractional" 1 1) (("" (replace -1 1) (("" (lemma "real_parts" ("x" "fractional(x!1) + fractional(y!1)")) (("" (hide -2) (("" (lemma "real_parts" ("x" "x!1")) (("" (lemma "real_parts" ("x" "y!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_plus formula-decl nil floor_ceil nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_parts formula-decl nil floor_ceil nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (fractional const-decl "{x | 0 <= x & x < 1}" floor_ceil nil)) shostak)) (floor_div 0 (floor_div-1 nil 3307951426 ("" (skosimp*) (("" (lemma "floor_def" ("x" "x!1/py!1")) (("" (flatten -1) (("" (split 1) (("1" (assert) (("1" (flatten) (("1" (replace -1) (("1" (rewrite "div_mult_pos_le2" -2) (("1" (rewrite "div_mult_pos_lt1" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "trich_lt" ("x" "floor(x!1 / py!1)" "y" "i!1")) (("2" (rewrite "div_mult_pos_le2" -4) (("2" (rewrite "div_mult_pos_lt1" -5) (("2" (split -1) (("1" (lemma "both_sides_times_pos_le1" ("y" "i!1" "x" "floor(x!1 / py!1)+1" "pz" "py!1")) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil) ("3" (lemma "both_sides_times_pos_le1" ("x" "i!1+1" "y" "floor(x!1 / py!1)" "pz" "py!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_def formula-decl nil floor_ceil nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (div_mult_pos_le2 formula-decl nil real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (trich_lt formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) shostak)) (floor_0 0 (floor_0-1 nil 3307951470 ("" (skosimp*) (("" (lemma "floor_div" ("x" "x!1" "py" "1" "i" "0")) (("" (replace -1 1) (("" (assert) nil nil)) nil)) nil)) nil) ((posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_div formula-decl nil floor_ceil nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak)))(exponentiation (expt_TCC1 0 (expt_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (expt subtype "(number_fields.-)(exponentiation.n, 1)" "nat"))) (expt_TCC2 0 (expt_TCC2-1 nil 3237052399 ("" (grind) nil nil) nil nil (expt termination "exponentiation.expt(exponentiation.r, (number_fields.-)(exponentiation.n, 1))" "nil"))) (expt_pos_aux 0 (expt_pos_aux-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (rewrite "pos_times_gt") nil nil)) nil)) nil)) nil)) nil) ((pos_times_gt formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (expt_nonzero_aux 0 (expt_nonzero_aux-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" -2) (("2" (inst?) (("2" (rewrite "zero_times3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((zero_times3 formula-decl nil real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (nnreal_expt 0 (nnreal_expt-1 nil 3237052399 ("" (induct "n") (("1" (skosimp) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst -1 "x!1") (("2" (assert) (("2" (lemma "pos_times_ge") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pos_times_ge formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (nnreal type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (nnreal_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "nnreal"))) (posreal_expt 0 (posreal_expt-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst -1 "x!1") (("2" (expand "expt" +) (("2" (assert) (("2" (lemma "pos_times_gt") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pos_times_gt formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (posreal_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "posreal"))) (nzreal_expt 0 (nzreal_expt-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" -2) (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (nzreal_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "nzreal"))) (rat_expt 0 (rat_expt-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst -1 "x!1") (("2" (expand "expt" +) (("2" (lemma "rat_times_rat_is_rat") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (j!1 skolem-const-decl "nat" exponentiation nil) (x!1 skolem-const-decl "rat" exponentiation nil) (rat_times_rat_is_rat judgement-tcc nil rationals nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (rat nonempty-type-eq-decl nil rationals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (rat_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "rat"))) (nnrat_expt 0 (nnrat_expt-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnrat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_expt application-judgement "rat" exponentiation nil) (nnreal_expt application-judgement "nnreal" exponentiation nil)) nil (nnrat_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "nnrat"))) (posrat_expt 0 (posrat_expt-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_expt application-judgement "nnrat" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil)) nil (posrat_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "posrat"))) (int_expt 0 (int_expt-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst -1 "x!1") (("2" (expand "expt" +) (("2" (lemma "int_times_int_is_int") (("2" (inst -1 "x!1" "expt(x!1, j!1)") nil nil)) nil)) nil)) nil)) nil)) nil) ((rat_times_rat_is_rat application-judgement "rat" rationals nil) (x!1 skolem-const-decl "int" exponentiation nil) (j!1 skolem-const-decl "nat" exponentiation nil) (int_times_int_is_int judgement-tcc nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rat_expt application-judgement "rat" exponentiation nil)) nil (int_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "int"))) (nat_expt 0 (nat_expt-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_expt application-judgement "int" exponentiation nil) (nnrat_expt application-judgement "nnrat" exponentiation nil)) nil (nat_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "nat"))) (posnat_expt 0 (posnat_expt-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (posrat_expt application-judgement "posrat" exponentiation nil)) nil (posnat_expt subtype "exponentiation.expt(exponentiation.x, exponentiation.n)" "posnat"))) (caret_TCC1 0 (caret_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil)) nil (caret subtype "(number_fields.-)(exponentiation.i)" "nat"))) (caret_TCC2 0 (caret_TCC2-1 nil 3237052399 ("" (skolem!) (("" (typepred "i!1") (("" (rewrite "expt_nonzero_aux") nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (expt_nonzero_aux formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (caret subtype "exponentiation.expt(exponentiation.r, (number_fields.-)(exponentiation.i))" "nznum"))) (expt_pos_TCC1 0 (expt_pos_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (expt_pos subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.px /= 0, reals.>=(i, 0))}"))) (expt_pos 0 (expt_pos-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (rewrite "expt_pos_aux") nil nil) ("2" (rewrite "quotient_pos_gt") (("2" (rewrite "expt_pos_aux") nil nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_pos_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (quotient_pos_gt formula-decl nil real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (expt_nonzero_TCC1 0 (expt_nonzero_TCC1-1 nil 3237052399 ("" (grind) nil nil) nil nil (expt_nonzero subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.n0x /= 0, reals.>=(i, 0))}"))) (expt_nonzero 0 (expt_nonzero-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (lemma "expt_nonzero_aux") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "inv_ne_0") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i!1 skolem-const-decl "int" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (expt_nonzero_aux formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (expt def-decl "real" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (inv_ne_0 formula-decl nil real_props nil)) nil)) (nnreal_exp 0 (nnreal_exp-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "^") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (case-replace "x!1 = 0") (("1" (expand "expt") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (use "expt_pos_aux") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "x!1 = 0") (("1" (expand "expt") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (use "expt_pos_aux") (("1" (lemma "quotient_pos_gt") (("1" (inst -1 "expt(x!1, -i!1)") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (expt def-decl "real" exponentiation nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "nnreal" exponentiation nil) (i!1 skolem-const-decl "{i: int | x!1 /= 0 OR i >= 0}" exponentiation nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (expt_pos_aux formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (quotient_pos_gt formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (nnreal_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "nnreal"))) (posreal_exp 0 (posreal_exp-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (use "expt_pos_aux") nil nil) ("2" (use "expt_pos_aux") (("1" (lemma "quotient_pos_gt") (("1" (inst -1 "expt(x!1, -i!1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (expt_pos_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (i!1 skolem-const-decl "int" exponentiation nil) (quotient_pos_gt formula-decl nil real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (expt def-decl "real" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (posreal_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "posreal"))) (nzreal_exp 0 (nzreal_exp-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (lemma "nzreal_expt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nzreal_expt") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i!1 skolem-const-decl "int" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_expt judgement-tcc nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil (nzreal_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "nzreal"))) (rat_exp 0 (rat_exp-1 nil 3237052399 ("" (skolem-typepred) (("" (expand "^") (("" (propax) nil nil)) nil)) nil) ((rat_expt application-judgement "rat" exponentiation nil) (^ const-decl "real" exponentiation nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (rat_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "rat"))) (nnrat_exp 0 (nnrat_exp-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (nnrat nonempty-type-eq-decl nil rationals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_exp application-judgement "rat" exponentiation nil) (nnreal_exp application-judgement "nnreal" exponentiation nil)) nil (nnrat_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "nnrat"))) (posrat_exp_TCC1 0 (posrat_exp_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (posrat_exp_ subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (posrat_exp 0 (posrat_exp-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (> const-decl "bool" reals nil) (posrat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posreal_exp application-judgement "posreal" exponentiation nil)) nil (posrat_exp subtype "exponentiation.^(exponentiation.x, exponentiation.i)" "posrat"))) (int_exp_TCC1 0 (int_exp_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (int_exp_ subtype "exponentiation.n" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (int_exp 0 (int_exp-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (int_expt application-judgement "int" exponentiation nil)) nil (int_exp subtype "exponentiation.^(exponentiation.x, exponentiation.n)" "int"))) (nat_exp 0 (nat_exp-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil (nat_exp subtype "exponentiation.^(exponentiation.x, exponentiation.n)" "nat"))) (posint_exp 0 (posint_exp-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil (posint_exp subtype "exponentiation.^(exponentiation.x, exponentiation.n)" "posint"))) (expt_x0_aux 0 (expt_x0_aux-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((expt def-decl "real" exponentiation nil)) nil)) (expt_x1_aux 0 (expt_x1_aux-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((expt def-decl "real" exponentiation nil)) nil)) (expt_1n_aux 0 (expt_1n_aux-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil) ((posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (increasing_expt_aux 0 (increasing_expt_aux-2 "" 3505096595 ("" (induct "m") (("1" (skosimp*) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "expt") (("1" (lemma "both_sides_times_pos_gt1") (("1" (inst -1 "gt1x!1" "gt1x!1" "1") (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "expt" 1) (("2" (lemma "div_mult_pos_gt2") (("2" (inst -1 "gt1x!1" "expt(gt1x!1, j!1 + 2)" "gt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal_expt application-judgement "posreal" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (increasing_expt_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp*) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "expt") (("1" (lemma "both_sides_times_pos_gt1") (("1" (inst -1 "gt1x!1" "gt1x!1" "1") (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "expt" 1) (("2" (lemma "div_mult_pos_gt1") (("2" (inst -1 "gt1x!1" "expt(gt1x!1, j!1 + 2)" "gt1x!1") (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_expt application-judgement "nzreal" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_gt2 formula-decl nil extra_real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (both_sides_times_pos_gt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (decreasing_expt_aux 0 (decreasing_expt_aux-2 "" 3505096761 ("" (induct "m") (("1" (skosimp) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "expt") (("1" (lemma "div_mult_pos_lt2") (("1" (inst -1 "lt1x!1" "lt1x!1" "lt1x!1") (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "expt" +) (("2" (lemma "div_mult_pos_gt1") (("2" (inst -1 "lt1x!1" "expt(lt1x!1, 2 + j!1)" "lt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (decreasing_expt_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "expt") (("1" (lemma "div_mult_pos_lt2") (("1" (inst -1 "lt1x!1" "lt1x!1" "lt1x!1") (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "expt" +) (("2" (lemma "div_mult_pos_gt2") (("2" (inst -1 "lt1x!1" "expt(lt1x!1, 2 + j!1)" "lt1x!1") (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_expt application-judgement "nzreal" exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (expt_1_aux 0 (expt_1_aux-2 "" 3505096840 ("" (induct "n") (("1" (skosimp*) (("1" (prop) (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "expt") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst -1 "px!1") (("2" (expand "expt" +) (("2" (ground) (("2" (case "j!1 = 0") (("1" (replace -1) (("1" (expand "expt") (("1" (expand "expt") (("1" (assert) (("1" (rewrite "sqrt_1") nil nil)) nil)) nil)) nil)) nil) ("2" (case "px!1 > 1") (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "px!1" "j!1-1") (("1" (assert) (("1" (lemma "eq1_gt") (("1" (inst -1 "px!1" "expt(px!1, 1 + j!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "decreasing_expt_aux") (("2" (inst -1 "px!1" "j!1-1") (("1" (lemma "eq1_gt") (("1" (inst -1 "1/px!1" "1/expt(px!1, 1 + j!1)") (("1" (assert) (("1" (split) (("1" (rewrite "div_mult_pos_lt1") nil nil) ("2" (assert) (("2" (rewrite "div_mult_pos_gt1") nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (px!1 skolem-const-decl "posreal" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "nat" exponentiation nil) (eq1_gt formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (increasing_expt_aux formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (decreasing_expt_aux formula-decl nil exponentiation nil) (sqrt_1 formula-decl nil real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (expt_1_aux-1 nil 3237052399 ("" (induct "n") (("1" (skosimp*) (("1" (prop) (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "expt") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst -1 "px!1") (("2" (expand "expt" +) (("2" (ground) (("2" (case "j!1 = 0") (("1" (replace -1) (("1" (expand "expt") (("1" (expand "expt") (("1" (assert) (("1" (rewrite "sqrt_1") nil nil)) nil)) nil)) nil)) nil) ("2" (case "px!1 > 1") (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "px!1" "j!1-1") (("1" (assert) (("1" (lemma "eq1_gt") (("1" (inst -1 "px!1" "expt(px!1, 1 + j!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "decreasing_expt_aux") (("2" (inst -1 "px!1" "j!1-1") (("1" (lemma "eq1_gt") (("1" (inst -1 "1/px!1" "1/expt(px!1, 1 + j!1)") (("1" (assert) (("1" (split) (("1" (rewrite "div_mult_pos_lt1") nil nil) ("2" (assert) (("2" (rewrite "div_mult_pos_gt2") nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (eq1_gt formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (increasing_expt_aux formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (decreasing_expt_aux formula-decl nil exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (sqrt_1 formula-decl nil real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (expt_plus_aux 0 (expt_plus_aux-1 nil 3237052399 ("" (induct "n") (("1" (skosimp*) (("1" (expand "expt" 1 3) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "expt" 1 3) (("2" (expand "expt" 1 1) (("2" (inst -1 "m!1" "n0x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil)) (expt_minus_aux_TCC1 0 (expt_minus_aux_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (expt_minus_aux subtype "(number_fields.-)(exponentiation.m, exponentiation.n)" "nat"))) (expt_minus_aux 0 (expt_minus_aux-1 nil 3237052399 ("" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "j!1 + 1 = n!1") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "expt" 2 1) (("2" (expand "expt" 2 2) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (rewrite "times_div1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil)) nil)) (expt_times_aux 0 (expt_times_aux-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" 1 2) (("2" (expand "expt" 1 1) (("2" (lift-if) (("2" (inst -1 "m!1" "n0x!1") (("2" (replace -1 :dir rl) (("2" (prop) (("1" (assert) (("1" (case "m!1 = 0") (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (case "j!1 = 0") (("1" (assert) nil nil) ("2" (lemma "posreal_mult_closed") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (case "m!1 = 0") (("1" (grind) nil nil) ("2" (case "j!1 = 0") (("1" (replace -1) (("1" (expand "expt" 3 3) (("1" (expand "expt" 3 2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "expt_plus_aux") (("2" (inst -1 "m!1" "m!1 * j!1" "n0x!1") (("2" (replace -1 :dir rl) (("2" (expand "expt" 3 2) (("2" (lift-if) (("2" (assert) (("2" (assert) (("2" (prop) (("2" (lemma "zero_times3") (("2" (inst -1 "m!1" "j!1 + 1") (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even_times_int_is_even application-judgement "even_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (posreal_mult_closed formula-decl nil real_axioms nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_plus_aux formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil)) (expt_divide_aux 0 (expt_divide_aux-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" 1 2) (("2" (inst?) (("2" (replace -1 :dir rl) (("2" (case "expt(n0x!1, j!1 * m!1 + m!1) = expt(n0x!1, m!1) * expt(n0x!1, m!1 * j!1)") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "expt_plus_aux") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_plus_aux formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (both_sides_expt1_aux 0 (both_sides_expt1_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp) (("1" (expand "expt") (("1" (expand "expt" 1 1) (("1" (ground) (("1" (case "px!1 > 1") (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "px!1" "n!1-1") (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "decreasing_expt_aux") (("2" (inst -1 "px!1" "n!1-1") (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "expt") (("2" (propax) nil nil)) nil) ("3" (replace -1) (("3" (rewrite "expt_1n_aux") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (expand "expt" 1 1) (("2" (expand "expt" 1 2) (("2" (case "n!1 = 0") (("1" (replace -1) (("1" (ground) (("1" (expand "expt" -1 2) (("1" (case "px!1 >1") (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "px!1" "j!1") (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "decreasing_expt_aux") (("2" (inst -1 "px!1" "j!1") (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "expt_1n_aux") (("2" (rewrite "expt_1n_aux") nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (inst -2 "n!1-1" "px!1") (("1" (assert) (("1" (rewrite "both_sides_times2") nil nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "expt_1n_aux") (("2" (rewrite "expt_1n_aux") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (px!1 skolem-const-decl "posreal" exponentiation nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (both_sides_times2 formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_1n_aux formula-decl nil exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (px!1 skolem-const-decl "posreal" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (increasing_expt_aux formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (decreasing_expt_aux formula-decl nil exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (both_sides_expt2_aux 0 (both_sides_expt2_aux-1 nil 3237052399 ("" (induct "pm") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp) (("3" (skosimp) (("3" (split) (("1" (expand "expt" +) (("1" (inst -1 "px!1" "py!1") (("1" (ground) (("1" (hide 1) (("1" (hide -2) (("1" (case "FORALL (m:nat), (px, py: posreal): px > py IMPLIES expt(px,m+1) > expt(py, m+1)") (("1" (case "px!1>py!1") (("1" (inst -2 "j!1-1" "px!1" "py!1") (("1" (assert) (("1" (lemma "gt_times_gt_pos1") (("1" (inst -1 "expt(py!1, j!1)" "py!1" "px!1" "expt(px!1, j!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "expt" +) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "j!1-1" "py!1" "px!1") (("1" (assert) (("1" (lemma "gt_times_gt_pos1") (("1" (inst -1 "expt(px!1, j!1)" "px!1" "py!1" "expt(py!1, j!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (induct "m") (("1" (skosimp*) (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (expand "expt" +) (("2" (rewrite "gt_times_gt_pos1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "expt") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "nat" exponentiation nil) (gt_times_gt_pos1 formula-decl nil real_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_pos_lt_aux 0 (both_sides_expt_pos_lt_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp) (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -1 "px!1" "py!1") (("2" (expand "expt" 1) (("2" (ground) (("1" (rewrite "lt_times_lt_pos1") nil nil) ("2" (lemma "ge_times_ge_pos") (("2" (inst -1 "expt(py!1, 1 + j!1)" "py!1" "px!1" "expt(px!1, 1 + j!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_times_ge_pos formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (both_sides_expt_gt1_lt_aux 0 (both_sides_expt_gt1_lt_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp*) (("1" (expand "expt") (("1" (expand "expt" 1 1) (("1" (ground) (("1" (expand "expt") (("1" (assert) nil nil)) nil) ("2" (lemma "increasing_expt_aux") (("2" (inst -1 "gt1x!1" "n!1 - 1") (("2" (expand "expt" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (ground) (("1" (case "n!1 = 0") (("1" (replace -1) (("1" (expand "expt" -2 2) (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "gt1x!1" "j!1") (("1" (expand "expt" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "gt1x!1" "n!1-1") (("1" (ground) (("1" (rewrite "both_sides_times_pos_lt2") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "gt1x!1" "n!1-1") (("2" (assert) (("2" (rewrite "both_sides_times_pos_lt2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (n!1 skolem-const-decl "nat" exponentiation nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (increasing_expt_aux formula-decl nil exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (both_sides_expt_lt1_lt_aux 0 (both_sides_expt_lt1_lt_aux-1 nil 3237052399 ("" (induct "m") (("1" (skosimp*) (("1" (expand "expt" 1 1) (("1" (expand "expt" -1 1) (("1" (ground) (("1" (lemma "decreasing_expt_aux") (("1" (inst -1 "lt1x!1" "n!1-1") (("1" (assert) nil nil) ("2" (expand "expt") (("2" (expand "expt") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst -1 "lt1x!1" "n!1 - 1") (("1" (ground) (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (rewrite "both_sides_times_pos_lt2") nil nil)) nil) ("2" (ground) (("2" (expand "expt" 1 2) (("2" (lemma "decreasing_expt_aux") (("2" (inst -1 "lt1x!1" "j!1") (("2" (expand "expt" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((n!1 skolem-const-decl "nat" exponentiation nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (decreasing_expt_aux formula-decl nil exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (n!1 skolem-const-decl "nat" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (both_sides_expt_pos_le_aux 0 (both_sides_expt_pos_le_aux-1 nil 3237052399 ("" (skosimp) (("" (ground) (("1" (lemma "both_sides_expt_pos_lt_aux") (("1" (inst -1 "m!1" "py!1" "px!1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "both_sides_expt_pos_lt_aux") (("2" (inst -1 "m!1" "py!1" "px!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_pos_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_le_aux 0 (both_sides_expt_gt1_le_aux-1 nil 3237052399 ("" (skosimp) (("" (lemma "both_sides_expt_gt1_lt_aux") (("" (inst -1 "gt1x!1" "n!1" "m!1") (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((both_sides_expt_gt1_lt_aux formula-decl nil exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_lt1_le_aux 0 (both_sides_expt_lt1_le_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_lt1_lt_aux") (("" (skosimp) (("" (inst -1 "lt1x!1" "n!1" "m!1") (("" (ground) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_lt1_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_pos_gt_aux 0 (both_sides_expt_pos_gt_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_pos_lt_aux") (("" (skosimp) (("" (inst -1 "m!1" "py!1" "px!1") (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_pos_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_gt_aux 0 (both_sides_expt_gt1_gt_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_gt1_lt_aux") (("" (skosimp) (("" (inst -1 "gt1x!1" "n!1" "m!1") (("" (ground) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_gt1_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_lt1_gt_aux 0 (both_sides_expt_lt1_gt_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_lt1_lt_aux") (("" (skosimp) (("" (inst -1 "lt1x!1" "n!1" "m!1") (("" (ground) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_lt1_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_pos_ge_aux 0 (both_sides_expt_pos_ge_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_pos_le_aux") (("" (skosimp) (("" (inst -1 "m!1" "py!1" "px!1") (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_pos_le_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_ge_aux 0 (both_sides_expt_gt1_ge_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_gt1_le_aux") (("" (skosimp) (("" (inst -1 "gt1x!1" "n!1" "m!1") (("" (ground) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_gt1_le_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_lt1_ge_aux 0 (both_sides_expt_lt1_ge_aux-1 nil 3237052399 ("" (lemma "both_sides_expt_lt1_le_aux") (("" (skosimp) (("" (inst -1 "lt1x!1" "n!1" "m!1") (("" (ground) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_expt_lt1_le_aux formula-decl nil exponentiation nil)) nil)) (expt_of_mult 0 (expt_of_mult-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (expt_of_div 0 (expt_of_div-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil)) nil)) (expt_of_inv 0 (expt_of_inv-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil)) nil)) (expt_of_abs 0 (expt_of_abs-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (assert) (("2" (replace -1 :hide? t) (("2" (grind) (("1" (use "neg_times_lt") (("1" (assert) nil nil)) nil) ("2" (use "pos_times_lt") (("2" (assert) nil nil)) nil) ("3" (use "pos_times_lt") (("3" (assert) nil nil)) nil) ("4" (use "neg_times_lt") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pos_times_lt formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nat_induction formula-decl nil naturalnumbers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (abs_of_expt_inv 0 (abs_of_expt_inv-1 nil 3237052399 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "expt" +) (("2" (inst?) (("2" (assert) (("2" (lemma "div_times") (("2" (inst -1 "abs(n0x!1)" "expt(abs(n0x!1), j!1)" "1" "1") (("2" (replace -1 :dir rl) (("2" (replace -2 :dir rl) (("2" (hide -1 -2) (("2" (grind) (("1" (lemma "quotient_neg_lt") (("1" (inst-cp -1 "n0x!1 * expt(n0x!1, j!1)") (("1" (inst -1 "expt(n0x!1, j!1)") (("1" (assert) (("1" (hide -3 -5) (("1" (lemma "negreal_times_negreal_is_posreal") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "quotient_neg_lt") (("2" (inst-cp -1 "expt(n0x!1, j!1)") (("2" (inst -1 "n0x!1 * expt(n0x!1, j!1)") (("2" (assert) (("2" (hide -2 3) (("2" (lemma "nnreal_times_nnreal_is_nnreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "quotient_neg_lt") (("3" (inst-cp -1 "expt(n0x!1, j!1)") (("3" (inst -1 "n0x!1 * expt(n0x!1, j!1)") (("3" (assert) (("3" (hide 3 4) (("3" (lemma "posreal_mult_closed") (("3" (inst -1 "-n0x!1" "expt(n0x!1, j!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "quotient_neg_lt") (("4" (inst-cp -1 "expt(n0x!1, j!1)") (("4" (inst -1 "n0x!1 * expt(n0x!1, j!1)") (("4" (assert) (("4" (hide -2 2) (("4" (lemma "posreal_mult_closed") (("4" (inst -1 "n0x!1" "-expt(n0x!1, j!1)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((div_times formula-decl nil real_props nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal_mult_closed formula-decl nil real_axioms nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil) (quotient_neg_lt formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (negreal_times_negreal_is_posreal judgement-tcc nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil)) nil)) (expt_x0_TCC1 0 (expt_x0_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil)) nil (expt_x0 subtype "0" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_x0 0 (expt_x0-1 nil 3237052399 ("" (grind) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil)) (expt_x1_TCC1 0 (expt_x1_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((/= const-decl "boolean" notequal nil)) nil (expt_x1 subtype "1" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_x1 0 (expt_x1-1 nil 3237052399 ("" (grind) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil)) nil)) (expt_x2_TCC1 0 (expt_x2_TCC1-1 nil 3307950059 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (expt_x2 subtype "2" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_x2 0 (expt_x2-1 nil 3307951594 ("" (grind) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil)) shostak)) (expt_x3_TCC1 0 (expt_x3_TCC1-1 nil 3307950060 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (expt_x3 subtype "3" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_x3 0 (expt_x3-1 nil 3307951600 ("" (grind) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (expt_x4_TCC1 0 (expt_x4_TCC1-1 nil 3307950060 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (expt_x4 subtype "4" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_x4 0 (expt_x4-1 nil 3307951604 ("" (grind) nil nil) ((expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (expt_1i 0 (expt_1i-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (rewrite "expt_1n_aux") nil nil) ("2" (rewrite "expt_1n_aux") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_1n_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil)) (expt_eq_0_TCC1 0 (expt_eq_0_TCC1-1 nil 3307950060 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (expt_eq_0 subtype "exponentiation.pn" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (expt_eq_0 0 (expt_eq_0-1 nil 3307951654 ("" (induct "pn") (("1" (skosimp*) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (case "j!1 = 0") (("1" (replace -1) (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "x!1 ^ (1 + j!1) = x!1*x!1^j!1") (("1" (hide -1) (("1" (inst?) (("1" (ground) (("1" (rewrite "nonzero_times1") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nonzero_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (expt_plus_TCC1 0 (expt_plus_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (expt_plus subtype "((number_fields.+)(exponentiation.i, exponentiation.j))" "{i: integers.int | booleans.OR(exponentiation.n0x /= 0, reals.>=(i, 0))}"))) (expt_plus 0 (expt_plus-2 "" 3505097701 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (rewrite "expt_plus_aux") nil nil) ("2" (lemma "expt_minus_aux") (("2" (inst -1 "i!1" "-j!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) (("3" (assert) (("3" (lemma "expt_minus_aux") (("3" (inst -1 "j!1" "-i!1" "n0x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (lift-if) (("4" (prop) (("1" (assert) (("1" (lemma "cross_mult") (("1" (inst -1 "expt(n0x!1, -(i!1 + j!1))" "expt(n0x!1, -j!1)" "1" "expt(n0x!1, i!1)") (("1" (flatten) (("1" (hide -1) (("1" (split) (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "expt_plus_aux") (("2" (inst -1 "i!1" "-(i!1 + j!1)" "n0x!1") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (lemma "cross_mult") (("1" (inst -1 "expt(n0x!1, -(i!1 + j!1))" "expt(n0x!1, -i!1)" "1" "expt(n0x!1, j!1)") (("1" (flatten) (("1" (hide -1) (("1" (replace 1) (("1" (lemma "expt_plus_aux") (("1" (inst -1 "j!1" "-(i!1 + j!1)" "n0x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "expt(n0x!1, -(i!1 + j!1)) = expt(n0x!1, -i!1) * expt(n0x!1, -j!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "expt_plus_aux") (("2" (inst -1 "-i!1" "-j!1" "n0x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (i!1 skolem-const-decl "int" exponentiation nil) (j!1 skolem-const-decl "int" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (expt_minus_aux formula-decl nil exponentiation nil) (cross_mult formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (expt_plus-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (rewrite "expt_plus_aux") nil nil) ("2" (assert) nil nil) ("3" (lemma "expt_minus_aux") (("3" (inst -1 "j!1" "-i!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("4" (lemma "cross_mult") (("4" (inst -1 "expt(n0x!1, -(i!1 + j!1))" "expt(n0x!1, -i!1)" "1" "expt(n0x!1, j!1)") (("1" (flatten) (("1" (hide -1) (("1" (replace 2) (("1" (lemma "expt_plus_aux") (("1" (inst -1 "j!1" "-(i!1 + j!1)" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("5" (lemma "expt_minus_aux") (("5" (inst -1 "i!1" "-j!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("6" (assert) (("6" (lemma "cross_mult") (("6" (inst -1 "expt(n0x!1, -(i!1 + j!1))" "expt(n0x!1, -j!1)" "1" "expt(n0x!1, i!1)") (("6" (flatten) (("6" (hide -1) (("6" (split) (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "expt_plus_aux") (("2" (inst -1 "i!1" "-(i!1 + j!1)" "n0x!1") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) nil nil) ("8" (case "expt(n0x!1, -(i!1 + j!1)) = expt(n0x!1, -i!1) * expt(n0x!1, -j!1)") (("1" (assert) (("1" (replace -1) (("1" (lemma "div_times") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "expt_plus_aux") (("2" (inst -1 "-i!1" "-j!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (expt_minus_aux formula-decl nil exponentiation nil) (cross_mult formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (expt_times_TCC1 0 (expt_times_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (expt_times subtype "(number_fields.*(exponentiation.i, exponentiation.j))" "{i: integers.int | booleans.OR(exponentiation.n0x /= 0, reals.>=(i, 0))}"))) (expt_times 0 (expt_times-3 "" 3505098188 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (rewrite "expt_times_aux") nil nil) ("2" (assert) (("2" (rewrite "pos_times_ge") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (lemma "pos_times_ge") (("3" (inst?) (("3" (assert) (("3" (grind) (("3" (lemma "expt_1n_aux") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "expt_divide_aux") (("4" (inst -1 "-i!1" "-j!1" "n0x!1") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("5" (lift-if) (("5" (ground) (("1" (lemma "pos_times_ge") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "expt_divide_aux") (("2" (inst -1 "-i!1" "j!1" "n0x!1") (("2" (assert) nil nil)) nil)) nil) ("3" (case "expt(n0x!1, -(i!1 * j!1)) = expt(expt(n0x!1, i!1), -j!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_times_aux") (("2" (inst -1 "i!1" "-j!1" "n0x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (expt_divide_aux formula-decl nil exponentiation nil) (j!1 skolem-const-decl "int" exponentiation nil) (i!1 skolem-const-decl "int" exponentiation nil) (expt_1n_aux formula-decl nil exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_times_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (pos_times_ge formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_times_aux formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil)) shostak) (expt_times-2 "Needed a :flush? t for some reason" 3299952478 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (rewrite "expt_times_aux") nil nil) ("2" (assert) (("2" (rewrite "pos_times_ge") nil nil)) nil) ("3" (rewrite "pos_times_ge") (("3" (assert) (("3" (grind) nil nil)) nil)) nil) ("4" (lemma "expt_divide_aux") (("4" (inst -1 "-i!1" "j!1" "n0x!1") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("5" (lemma "pos_times_ge") (("5" (inst?) (("5" (assert) (("5" (grind) (("5" (lemma "expt_1n_aux") (("5" (inst?) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (case "expt(n0x!1, -(i!1 * j!1)) = expt(expt(n0x!1, i!1), -j!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "expt_times_aux") (("2" (inst -1 "i!1" "-j!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (propax) nil nil) ("5" (assert) nil nil)) nil) ("7" (lemma "expt_divide_aux") (("7" (inst -1 "-i!1" "-j!1" "n0x!1") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("8" (lemma "pos_times_ge") (("8" (inst?) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (expt_divide_aux formula-decl nil exponentiation nil) (expt_1n_aux formula-decl nil exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_times_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (pos_times_ge formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_times_aux formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil)) shostak) (expt_times-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (rewrite "expt_times_aux") nil nil) ("2" (assert) (("2" (rewrite "pos_times_ge") nil nil)) nil) ("3" (rewrite "pos_times_ge") (("3" (assert) (("3" (grind) nil nil)) nil)) nil) ("4" (lemma "expt_divide_aux") (("4" (inst -1 "-i!1" "j!1" "n0x!1") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("5" (lemma "pos_times_ge") (("5" (inst?) (("5" (assert) (("5" (grind) (("5" (rewrite "expt_1n_aux") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (case "expt(n0x!1, -(i!1 * j!1)) = expt(expt(n0x!1, i!1), -j!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "expt_times_aux") (("2" (inst -1 "i!1" "-j!1" "n0x!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (propax) nil nil) ("5" (assert) nil nil)) nil) ("7" (lemma "expt_divide_aux") (("7" (inst -1 "-i!1" "-j!1" "n0x!1") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("8" (lemma "pos_times_ge") (("8" (inst?) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (expt_inverse_TCC1 0 (expt_inverse_TCC1-1 nil 3237052399 ("" (grind) nil nil) nil nil (expt_inverse subtype "((number_fields.-)(exponentiation.i))" "{i: integers.int | booleans.OR(exponentiation.n0x /= 0, reals.>=(i, 0))}"))) (expt_inverse 0 (expt_inverse-1 nil 3237052399 ("" (skosimp*) (("" (expand "^") (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil)) nil)) (expt_div_TCC1 0 (expt_div_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (expt_div subtype "((number_fields.-)(exponentiation.i, exponentiation.j))" "{i: integers.int | booleans.OR(exponentiation.n0x /= 0, reals.>=(i, 0))}"))) (expt_div 0 (expt_div-1 nil 3237052399 ("" (skosimp) (("" (lemma "expt_inverse") (("" (inst -1 "j!1" "n0x!1") (("" (lemma "expt_plus") (("" (inst -1 "i!1" "-j!1" "n0x!1") (("" (assert) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((expt_inverse formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt1_TCC1 0 (both_sides_expt1_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) nil nil (both_sides_expt1 subtype "exponentiation.n0i" "{i: integers.int | booleans.OR(exponentiation.px /= 0, reals.>=(i, 0))}"))) (both_sides_expt1 0 (both_sides_expt1-1 nil 3237052399 ("" (lemma "both_sides_expt1_aux") (("" (skosimp) (("" (expand "^") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (inst -3 "n0i!1 - 1" "n0j!1 - 1" "px!1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (ground) (("1" (lemma "div_cancel3") (("1" (inst -1 "expt(px!1, -n0j!1)" "1" "expt(px!1, n0i!1)") (("1" (prop) (("1" (hide -1 -3) (("1" (rewrite "expt_plus_aux" :dir rl) (("1" (lemma "expt_1_aux") (("1" (inst -1 "-n0j!1 + n0i!1 - 1" "px!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "expt_1n_aux") (("2" (rewrite "expt_1n_aux") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (lemma "div_cancel3") (("1" (inst -1 "expt(px!1, -n0i!1)" "1" "expt(px!1, n0j!1)") (("1" (prop) (("1" (hide -1 -3) (("1" (rewrite "expt_plus_aux" :dir rl) (("1" (lemma "expt_1_aux") (("1" (inst -1 "n0j!1 - n0i!1 - 1" "px!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "expt" 1) (("2" (assert) nil nil)) nil) ("3" (replace -1) (("3" (rewrite "expt_1n_aux") (("3" (rewrite "expt_1n_aux") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (rewrite "cross_mult") (("4" (inst -2 "-n0j!1-1" "-n0i!1-1" "px!1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("5" (replace -1) (("5" (propax) nil nil)) nil) ("6" (replace -1) (("6" (rewrite "expt_1n_aux") (("6" (rewrite "expt_1n_aux") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (cross_mult formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (n0i!1 skolem-const-decl "nzint" exponentiation nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (n0j!1 skolem-const-decl "nzint" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (expt def-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (expt_1_aux formula-decl nil exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_plus_aux formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (div_cancel3 formula-decl nil real_props nil) (expt_1n_aux formula-decl nil exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (both_sides_expt1_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt2 0 (both_sides_expt2-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "both_sides_expt2_aux") (("" (lift-if) (("" (prop) (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (inst -2 "-n0i!1" "px!1" "py!1") (("1" (assert) (("1" (rewrite "cross_mult") nil nil)) nil) ("2" (assert) nil nil)) nil) ("4" (inst -2 "-n0i!1" "px!1" "py!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (n0i!1 skolem-const-decl "nzint" exponentiation nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (both_sides_expt2_aux formula-decl nil exponentiation nil)) nil)) (pos_expt_gt_TCC1 0 (pos_expt_gt_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (pos_expt_gt subtype "exponentiation.n" "{i: integers.int | booleans.OR(exponentiation.b /= 0, reals.>=(i, 0))}"))) (pos_expt_gt 0 (pos_expt_gt-1 nil 3237052399 ("" (induct "n") (("1" (skosimp) (("1" (rewrite "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "expt_plus") (("2" (rewrite "expt_x1") (("2" (inst?) (("2" (case "FORALL (a, b, c, d: nat): a < c & b < d => a + b < c * d") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "c") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (assert) (("2" (case "a!1 = 0") (("1" (assert) nil nil) ("2" (inst -1 "a!1-1" "b!2" "d!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((expt_x1 formula-decl nil exponentiation nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (a!1 skolem-const-decl "nat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt_x0 formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (expt_ge1 0 (expt_ge1-1 nil 3237052399 ("" (induct-and-rewrite "n" 1 "expt_plus" "expt_x0" "expt_x1") (("" (lemma "ge_times_ge_pos") (("" (inst?) (("" (inst - "1" "1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((ge_times_ge_pos formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (expt_x1 formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)) (both_sides_expt_pos_lt_TCC1 0 (both_sides_expt_pos_lt_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) nil nil (both_sides_expt_pos_lt subtype "exponentiation.pm" "{i: integers.int | booleans.OR(exponentiation.px /= 0, reals.>=(i, 0))}"))) (both_sides_expt_pos_lt 0 (both_sides_expt_pos_lt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "both_sides_expt_pos_lt_aux") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (both_sides_expt_pos_lt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_lt_TCC1 0 (both_sides_expt_gt1_lt_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) nil nil (both_sides_expt_gt1_lt subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.gt1x /= 0, reals.>=(i, 0))}"))) (both_sides_expt_gt1_lt 0 (both_sides_expt_gt1_lt-2 "" 3299962553 ("" (skosimp*) (("" (ground) (("1" (case "j!1<=i!1") (("1" (case "gt1x!1 ^ j!1 <= gt1x!1 ^ i!1") (("1" (assert) nil nil) ("2" (hide -2 2) (("2" (case "forall (n:nat): gt1x!1^j!1<=gt1x!1^(j!1+n)") (("1" (inst - "i!1-j!1") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst -1 "1" "j!1 + j!2" "gt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "le_times_le_pos") (("2" (inst - "1" "gt1x!1 ^ j!1" "gt1x!1 ^ (j!1 + j!2)" "gt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "forall (n:nat): gt1x!1^i!1<gt1x!1^(1+i!1+n)") (("1" (inst - "j!1-(i!1+1)") (("1" (assert) nil nil) ("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (lemma "both_sides_times_pos_lt1") (("1" (inst - "gt1x!1 ^ i!1" "1" "gt1x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst - "1" "(1 + i!1 + j!2)" "gt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "lt_times_lt_pos1") (("2" (inst - "gt1x!1^i!1" "1" "gt1x!1^(1+i!1+j!2)" "gt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (expt_plus formula-decl nil exponentiation nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (expt_x1 formula-decl nil exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (le_times_le_pos formula-decl nil real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil)) shostak) (both_sides_expt_gt1_lt-1 nil 3237052399 ("" (skosimp*) (("" (ground) (("1" (case "j!1<=i!1") (("1" (case "gt1x!1 ^ j!1 <= gt1x!1 ^ i!1") (("1" (assert) nil nil) ("2" (hide -2 2) (("2" (case "forall (n:nat): gt1x!1^j!1<=gt1x!1^(j!1+n)") (("1" (inst - "i!1-j!1") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst -1 "1" "j!1 + j!2" "gt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "le_times_le_pos") (("2" (inst - "1" "gt1x!1 ^ j!1" "gt1x!1 ^ (j!1 + j!2)" "gt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "forall (n:nat): gt1x!1^i!1<gt1x!1^(1+i!1+n)") (("1" (inst - "j!1-(i!1+1)") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (lemma "both_sides_times_pos_lt1") (("1" (inst - "gt1x!1 ^ i!1" "1" "gt1x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst - "1" "(1 + i!1 + j!2)" "gt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "lt_times_lt_pos1") (("2" (inst - "gt1x!1^i!1" "1" "gt1x!1^(1+i!1+j!2)" "gt1x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (both_sides_expt_lt1_lt_TCC1 0 (both_sides_expt_lt1_lt_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) nil nil (both_sides_expt_lt1_lt subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.lt1x /= 0, reals.>=(i, 0))}"))) (both_sides_expt_lt1_lt 0 (both_sides_expt_lt1_lt-2 "" 3299962626 ("" (skosimp*) (("" (ground) (("1" (case "FORALL (n:nat): lt1x!1^(i!1+n) <= lt1x!1^i!1") (("1" (inst -1 "j!1-i!1") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst - "1" "i!1 + j!2" "lt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "le_times_le_pos") (("2" (inst - "lt1x!1" "lt1x!1^(i!1+j!2)" "lt1x!1^i!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:nat): lt1x!1^(j!1+n+1) < lt1x!1^j!1") (("1" (inst -1 "i!1 -j!1 -1") (("1" (assert) nil nil) ("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (lemma "both_sides_times_pos_lt1") (("1" (inst -1 "lt1x!1 ^ j!1" "lt1x!1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst -1 "1" "1 + j!1 + j!2" "lt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "lt_times_lt_pos1") (("2" (inst -1 "lt1x!1 ^ (j!1 + j!2 + 1)" "lt1x!1" "lt1x!1 ^ j!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (le_times_le_pos formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (expt_x1 formula-decl nil exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak) (both_sides_expt_lt1_lt-1 nil 3237052399 ("" (skosimp*) (("" (ground) (("1" (case "FORALL (n:nat): lt1x!1^(i!1+n) <= lt1x!1^i!1") (("1" (inst -1 "j!1-i!1") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst - "1" "i!1 + j!2" "lt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "le_times_le_pos") (("2" (inst - "lt1x!1" "lt1x!1^(i!1+j!2)" "lt1x!1^i!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (n:nat): lt1x!1^(j!1+n+1) < lt1x!1^j!1") (("1" (inst -1 "i!1 -j!1 -1") (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (induct "n") (("1" (assert) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (lemma "both_sides_times_pos_lt1") (("1" (inst -1 "lt1x!1 ^ j!1" "lt1x!1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "expt_plus") (("2" (inst -1 "1" "1 + j!1 + j!2" "lt1x!1") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "expt_x1") (("2" (lemma "lt_times_lt_pos1") (("2" (inst -1 "lt1x!1 ^ (j!1 + j!2 + 1)" "lt1x!1" "lt1x!1 ^ j!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (both_sides_expt_pos_le 0 (both_sides_expt_pos_le-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "both_sides_expt_pos_le_aux") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (both_sides_expt_pos_le_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_le 0 (both_sides_expt_gt1_le-1 nil 3237052399 ("" (skosimp*) (("" (case "i!1 = j!1") (("1" (assert) nil nil) ("2" (lemma "both_sides_expt_gt1_lt") (("2" (inst -1 "gt1x!1" "j!1" "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil)) nil)) (both_sides_expt_lt1_le 0 (both_sides_expt_lt1_le-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_lt1_lt") (("" (inst -1 "j!1" "i!1" "lt1x!1") (("" (ground) nil nil)) nil)) nil)) nil) ((both_sides_expt_lt1_lt formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_pos_gt 0 (both_sides_expt_pos_gt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "both_sides_expt_pos_gt_aux") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (both_sides_expt_pos_gt_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_gt 0 (both_sides_expt_gt1_gt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_gt1_lt") (("" (inst -1 "gt1x!1" "j!1" "i!1") (("" (ground) nil nil)) nil)) nil)) nil) ((both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_lt1_gt 0 (both_sides_expt_lt1_gt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_lt1_lt") (("" (inst -1 "j!1" "i!1" "lt1x!1") (("" (ground) nil nil)) nil)) nil)) nil) ((both_sides_expt_lt1_lt formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_pos_ge 0 (both_sides_expt_pos_ge-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "both_sides_expt_pos_ge_aux") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (both_sides_expt_pos_ge_aux formula-decl nil exponentiation nil)) nil)) (both_sides_expt_gt1_ge 0 (both_sides_expt_gt1_ge-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_gt1_le") (("" (inst -1 "gt1x!1" "j!1" "i!1") (("" (ground) nil nil)) nil)) nil)) nil) ((both_sides_expt_gt1_le formula-decl nil exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (both_sides_expt_lt1_ge 0 (both_sides_expt_lt1_ge-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_lt1_le") (("" (inst -1 "j!1" "i!1" "lt1x!1") (("" (ground) nil nil)) nil)) nil)) nil) ((both_sides_expt_lt1_le formula-decl nil exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (expt_gt1_pos_TCC1 0 (expt_gt1_pos_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (expt_gt1_pos subtype "exponentiation.pm" "{i: integers.int | booleans.OR(exponentiation.gt1x /= 0, reals.>=(i, 0))}"))) (expt_gt1_pos 0 (expt_gt1_pos-1 nil 3237052399 ("" (induct "pm") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (split) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (inst?) (("1" (lemma "both_sides_times_pos_ge1") (("1" (inst -1 "gt1x!1" "gt1x!1 ^ j!1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (posreal_exp application-judgement "posreal" exponentiation nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (expt_x1 formula-decl nil exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (expt_gt1_neg_TCC1 0 (expt_gt1_neg_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (expt_gt1_neg subtype "((number_fields.-)(exponentiation.pm))" "{i: integers.int | booleans.OR(exponentiation.gt1x /= 0, reals.>=(i, 0))}"))) (expt_gt1_neg 0 (expt_gt1_neg-1 nil 3237052399 ("" (skosimp) (("" (case "gt1x!1^(-pm!1) * gt1x!1^pm!1 < gt1x!1^pm!1") (("1" (lemma "both_sides_times_pos_lt1") (("1" (inst -1 "gt1x!1 ^ pm!1" "gt1x!1 ^ (-pm!1)" "1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "expt_plus" :dir rl) (("2" (hide 2) (("2" (lemma "expt_gt1_pos") (("2" (inst -1 "gt1x!1" "pm!1") (("2" (assert) (("2" (expand "^" 1 1) (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (expt def-decl "real" exponentiation nil) (expt_gt1_pos formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil)) nil)) (expt_gt1_nonpos_TCC1 0 (expt_gt1_nonpos_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (expt_gt1_nonpos subtype "((number_fields.-)(exponentiation.m))" "{i: integers.int | booleans.OR(exponentiation.gt1x /= 0, reals.>=(i, 0))}"))) (expt_gt1_nonpos 0 (expt_gt1_nonpos-1 nil 3237052399 ("" (skosimp) (("" (case "m!1 = 0") (("1" (grind) nil nil) ("2" (lemma "expt_gt1_neg") (("2" (inst -1 "gt1x!1" "m!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_exp application-judgement "posreal" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (m!1 skolem-const-decl "nat" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt_gt1_neg formula-decl nil exponentiation nil)) nil)) (mult_expt_TCC1 0 (mult_expt_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (mult_expt subtype "exponentiation.i" "{i: integers.int | booleans.OR((number_fields.*(exponentiation.n0x, exponentiation.n0y)) /= 0, reals.>=(i, 0))}"))) (mult_expt 0 (mult_expt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lift-if) (("" (lemma "expt_of_mult") (("" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (expt_of_mult formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (i!1 skolem-const-decl "int" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (div_expt_TCC1 0 (div_expt_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (div_expt subtype "exponentiation.i" "{i: integers.int | booleans.OR((number_fields./(exponentiation.n0x, exponentiation.n0y)) /= 0, reals.>=(i, 0))}"))) (div_expt 0 (div_expt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lemma "expt_of_div") (("" (lift-if) (("" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (i!1 skolem-const-decl "int" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_of_div formula-decl nil exponentiation nil)) nil)) (inv_expt 0 (inv_expt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lift-if) (("" (lemma "expt_of_inv") (("" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (expt_of_inv formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (i!1 skolem-const-decl "int" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (abs_expt_TCC1 0 (abs_expt_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (/= const-decl "boolean" notequal nil)) nil (abs_expt subtype "exponentiation.i" "{i: integers.int | booleans.OR(real_defs.abs(exponentiation.n0x) /= 0, reals.>=(i, 0))}"))) (abs_expt 0 (abs_expt-1 nil 3237052399 ("" (skosimp) (("" (expand "^") (("" (lift-if) (("" (lemma "expt_of_abs") (("" (prop) (("1" (instantiate -2 ("i!1" "n0x!1")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (inst?) (("1" (lemma "abs_div") (("1" (inst -1 "expt(n0x!1, -i!1)" "1") (("1" (replace -1) (("1" (expand "abs" 2 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (^ const-decl "real" exponentiation nil) (expt_of_abs formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}" real_defs nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (posreal_expt application-judgement "posreal" exponentiation nil) (abs_div formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (i!1 skolem-const-decl "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil)) nil)) (abs_hat_nat_TCC1 0 (abs_hat_nat_TCC1-1 nil 3307950061 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (abs_hat_nat subtype "exponentiation.n" "{i: integers.int | booleans.OR(real_defs.abs(exponentiation.x) /= 0, reals.>=(i, 0))}"))) (abs_hat_nat_TCC2 0 (abs_hat_nat_TCC2-1 nil 3307950061 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (abs_hat_nat subtype "exponentiation.n" "{i: integers.int | booleans.OR(exponentiation.x /= 0, reals.>=(i, 0))}"))) (abs_hat_nat 0 (abs_hat_nat-1 nil 3307952457 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "^") (("2" (expand "expt" +) (("2" (rewrite "abs_mult") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (abs_mult formula-decl nil real_props nil) (expt def-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (expt_minus1_abs 0 (expt_minus1_abs-1 nil 3307952835 ("" (skosimp*) (("" (case "i!1<0") (("1" (lemma "expt_inverse" ("n0x" "-1" "i" "-i!1")) (("1" (replace -1) (("1" (rewrite "abs_div" 1) (("1" (rewrite "abs_hat_nat" 1 :dir rl) (("1" (expand "abs" 1) (("1" (rewrite "expt_1i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "abs_hat_nat" 2 :dir rl) (("2" (expand "abs") (("2" (rewrite "expt_1i" 2) nil nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (abs_hat_nat formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (expt_1i formula-decl nil exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (abs_div formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt_inverse formula-decl nil exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil)) shostak)) (even_m1_pow 0 (even_m1_pow-1 nil 3307952866 ("" (skosimp*) (("" (expand "even?") (("" (skosimp*) (("" (replace -1) (("" (lemma "expt_times" ("n0x" "-1" "i" "2" "j" "j!1")) (("" (replace -1) (("" (expand "^" 1 1) (("" (expand "expt") (("" (expand "expt") (("" (expand "expt") (("" (rewrite "expt_1i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even? const-decl "bool" integers nil) (expt def-decl "real" exponentiation nil) (expt_1i formula-decl nil exponentiation nil) (^ const-decl "real" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (expt_times formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil)) shostak)) (not_even_m1_pow 0 (not_even_m1_pow-1 nil 3307952902 ("" (skosimp*) (("" (rewrite "even_or_odd") (("" (expand "odd?") (("" (skosimp*) (("" (replace -1) (("" (lemma "expt_plus" ("n0x" "-1" "i" "1" "j" "2*j!1")) (("" (replace -1) (("" (lemma "expt_times" ("n0x" "-1" "i" "2" "j" "j!1")) (("" (replace -1) (("" (expand "^" 1 2) (("" (expand "expt") (("" (expand "expt") (("" (expand "expt") (("" (rewrite "expt_x1") (("" (rewrite "expt_1i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even_or_odd formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt_plus formula-decl nil exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (expt_times formula-decl nil exponentiation nil) (^ const-decl "real" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (expt_1i formula-decl nil exponentiation nil) (expt def-decl "real" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (odd? const-decl "bool" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak)) (expt_lt1_bound1 0 (expt_lt1_bound1-1 nil 3237052399 ("" (induct-and-simplify "n") (("" (use "both_sides_times_pos_le2" ("pz" "lt1x!1")) (("" (assert) nil nil)) nil)) nil) ((both_sides_times_pos_le2 formula-decl nil real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (expt def-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)) (expt_lt1_bound2 0 (expt_lt1_bound2-1 nil 3237052399 ("" (skolem!) (("" (use "expt_lt1_bound1") (("" (use "expt_1_aux") (("" (assert) nil nil)) nil)) nil)) nil) ((expt_lt1_bound1 formula-decl nil exponentiation nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt_1_aux formula-decl nil exponentiation nil)) nil)) (expt_gt1_bound1 0 (expt_gt1_bound1-1 nil 3237052399 ("" (skolem 1 ("a!1" _)) (("" (induct-and-simplify "n") (("" (lemma "both_sides_times_pos_le2") (("" (inst -1 "expt(a!1, j!1)" "1" "a!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat_induction formula-decl nil naturalnumbers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (expt def-decl "real" exponentiation nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_expt application-judgement "posreal" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (both_sides_times_pos_le2 formula-decl nil real_props nil)) nil)) (expt_gt1_bound2 0 (expt_gt1_bound2-1 nil 3237052399 ("" (skolem!) (("" (use "expt_gt1_bound1" ("n" "pn!1 - 1")) (("" (expand "expt" +) (("" (lemma "both_sides_times_pos_le1") (("" (assert) (("" (inst -1 "gt1x!1" "1" "expt(gt1x!1, pn!1-1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt_gt1_bound1 formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (posreal_expt application-judgement "posreal" exponentiation nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (expt def-decl "real" exponentiation nil)) nil)) (large_expt 0 (large_expt-1 nil 3237052399 ("" (skosimp) (("" (assert) (("" (auto-rewrite-theory "sets[real]") (("" (lemma "real_complete" ("S" "{x:real | EXISTS (n : nat) : x = expt(px!1, n)}")) (("1" (hide 1) (("1" (split -1) (("1" (skosimp*) (("1" (expand "least_upper_bound?") (("1" (flatten) (("1" (inst -2 "y!1/px!1") (("1" (case "y!1 > 0") (("1" (ground) (("1" (lemma "both_sides_div_pos_le2" ("px" "1" "py" "px!1" "pz" "y!1")) (("1" (assert) nil nil)) nil) ("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (inst - "s!1*px!1") (("1" (rewrite "div_mult_pos_le2") nil nil) ("2" (typepred "s!1") (("2" (skosimp*) (("2" (inst 1 "n!1+1") (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete -2) (("2" (expand "upper_bound?") (("2" (inst - "1") (("1" (assert) nil nil) ("2" (inst 1 "0") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal 1) (("2" (skolem!) (("2" (inst 2 "py!1") (("2" (expand "upper_bound?") (("2" (skosimp*) (("2" (typepred "s!1") (("2" (skosimp*) (("2" (inst 1 "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -1 "1") (("2" (inst 1 "0") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_complete formula-decl nil bounded_real_defs nil) (posreal_expt application-judgement "posreal" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_div_pos_le2 formula-decl nil real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_le2 formula-decl nil real_props nil) (s!1 skolem-const-decl "({x: real | EXISTS (n: nat): x = expt(px!1, n)})" exponentiation nil) (px!1 skolem-const-decl "posreal" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (upper_bound? const-decl "bool" bounded_real_defs nil)) nil)) (small_expt 0 (small_expt-1 nil 3237052399 ("" (skosimp*) (("" (lemma "large_expt" ("px" "1/px!1")) (("" (rewrite "div_mult_pos_lt2") (("" (assert) (("" (inst -1 "1/py!1") (("" (skolem!) (("" (inst 1 "n!1") (("" (rewrite "expt_of_inv") (("" (rewrite "both_sides_div_pos_lt2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (large_expt formula-decl nil exponentiation nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_of_inv formula-decl nil exponentiation nil) (posreal_expt application-judgement "posreal" exponentiation nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil) (expt def-decl "real" exponentiation nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_lt2 formula-decl nil real_props nil)) nil)) (exponent_adjust_TCC1 0 (exponent_adjust_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (exponent_adjust subtype "exponentiation.i" "{i: integers.int | booleans.OR(exponentiation.b /= 0, reals.>=(i, 0))}"))) (exponent_adjust_TCC2 0 (exponent_adjust_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (exponent_adjust subtype "((number_fields.-)(exponentiation.i, exponentiation.pm))" "{i: integers.int | booleans.OR(exponentiation.b /= 0, reals.>=(i, 0))}"))) (exponent_adjust_TCC3 0 (exponent_adjust_TCC3-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (exponent_adjust subtype "((number_fields.+)(exponentiation.i, 1))" "{i: integers.int | booleans.OR(exponentiation.b /= 0, reals.>=(i, 0))}"))) (exponent_adjust 0 (exponent_adjust-1 nil 3237052399 ("" (skosimp*) (("" (lemma "both_sides_expt_gt1_lt") (("" (inst - "b!1" "i!1 - pm!1" "i!1") (("" (ground) (("" (rewrite "expt_plus") (("" (rewrite "expt_x1") (("" (lemma "both_sides_times_pos_le1") (("" (inst - "b!1 ^ i!1" "2" "b!1") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_x1 formula-decl nil exponentiation nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (expt_plus formula-decl nil exponentiation nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (exp_of_exists 0 (exp_of_exists-1 nil 3237052399 ("" (skosimp*) (("" (lemma "lub_int") (("" (case "py!1<1") (("1" (inst - "{i|b!1^i<=py!1}" "-1") (("1" (prop) (("1" (expand "least_upper_bound?") (("1" (skosimp*) (("1" (hide -2) (("1" (inst + "j!1") (("1" (assert) (("1" (expand "upper_bound?") (("1" (inst - "j!1+1") (("1" (assert) nil nil) ("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upper_bound?") (("2" (skolem-typepred) (("2" (expand "extend") (("2" (case "s!1>=0") (("1" (lemma "expt_ge1") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (prop) (("2" (assert) (("2" (case "EXISTS (x:int): 0 > x & x > -1") (("1" (skosimp) (("1" (assert) nil nil)) nil) ("2" (inst 1 "s!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nonempty_exists") (("2" (lemma "axiom_of_archimedes") (("2" (inst - "1/py!1") (("2" (skosimp*) (("2" (inst + "-i!1") (("2" (rewrite "expt_inverse") (("2" (rewrite "div_mult_pos_le1") (("2" (lemma "pos_expt_gt") (("2" (inst?) (("1" (rewrite "div_mult_pos_lt1") (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst - "py!1" "i!1" "b!1^i!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "axiom_of_archimedes") (("2" (inst?) (("2" (skosimp*) (("2" (inst - "{i|b!1^i<=py!1}" "i!1") (("1" (prop) (("1" (expand "least_upper_bound?") (("1" (skosimp*) (("1" (hide -2) (("1" (inst + "j!1") (("1" (assert) (("1" (expand "upper_bound?") (("1" (inst - "j!1+1") (("1" (assert) nil nil) ("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upper_bound?") (("2" (skolem-typepred) (("2" (expand "extend") (("2" (prop) (("2" (lemma "pos_expt_gt") (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nonempty_exists") (("2" (inst + "0") (("2" (rewrite "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lub_int formula-decl nil integer_props nil) (expt_x0 formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (j!1 skolem-const-decl "({i | b!1 ^ i <= py!1})" exponentiation nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE]({i | b!1 ^ i <= py!1}))" exponentiation nil) (py!1 skolem-const-decl "posreal" exponentiation nil) (b!1 skolem-const-decl "above(1)" exponentiation nil) (above nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (expt_ge1 formula-decl nil exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (s!1 skolem-const-decl "(extend[real, int, bool, FALSE]({i | b!1 ^ i <= py!1}))" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_upper_bound? const-decl "bool" bounded_real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "({i | b!1 ^ i <= py!1})" exponentiation nil) (upper_bound? const-decl "bool" bounded_real_defs nil) (axiom_of_archimedes formula-decl nil real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_inverse formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (pos_expt_gt formula-decl nil exponentiation nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_le1 formula-decl nil real_props nil) (i!1 skolem-const-decl "int" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nonempty_exists formula-decl nil sets_lemmas nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil)) nil)))(euclidean_division (mod_TCC1 0 (mod_TCC1-1 nil 3237052399 ("" (skolem-typepred) (("" (inst 1 "0") nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (mod existence "" "{i | reals.<(euclidean_division.i, euclidean_division.b)}"))) (euclid_nat 0 (euclid_nat-1 nil 3237052399 ("" (skolem 1 (_ "b!1")) (("" (induct "a") (("1" (inst + "0" "0") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (case "r!1 = b!1-1") (("1" (inst + "q!1+1" "0") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (inst + "q!1" "r!1+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (euclid_int 0 (euclid_int-1 nil 3237052399 ("" (skolem!) (("" (case "n!1 >= 0") (("1" (use "euclid_nat" ("a" "n!1")) (("1" (skolem!) (("1" (inst?) nil nil)) nil)) nil) ("2" (assert) (("2" (use "euclid_nat" ("a" "- n!1")) (("2" (skolem!) (("2" (case "r!1 = 0") (("1" (inst + "-q!1" "0") (("1" (assert) nil nil)) nil) ("2" (inst + "- q!1 - 1" "b!1 - r!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (euclid_nat formula-decl nil euclidean_division nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (r!1 skolem-const-decl "mod(b!1)" euclidean_division nil) (b!1 skolem-const-decl "posnat" euclidean_division nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (unique_quotient 0 (unique_quotient-2 "" 3299962695 ("" (skosimp) (("" (assert) (("" (case "q1!1 > q2!1") (("1" (case "b!1 * (q1!1 - q2!1) = r2!1 - r1!1") (("1" (case "b!1 * (q1!1 - q2!1) >= b!1") (("1" (assert) nil nil) ("2" (lemma "both_sides_times_pos_ge2") (("2" (inst -1 "b!1" "q1!1 - q2!1" "1") (("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "b!1 * (q2!1 - q1!1) = r1!1 - r2!1") (("1" (case "b!1 * (q2!1 - q1!1) >= b!1") (("1" (assert) nil nil) ("2" (lemma "both_sides_times_pos_ge2") (("2" (inst -1 "b!1" "q2!1 - q1!1" "1") (("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) shostak) (unique_quotient-1 nil 3237052399 ("" (skosimp) (("" (assert) (("" (case "q1!1 > q2!1") (("1" (case "b!1 * (q1!1 - q2!1) = r2!1 - r1!1") (("1" (case "b!1 * (q1!1 - q2!1) >= b!1") (("1" (assert) nil nil) ("2" (lemma "both_sides_times_pos_ge2") (("2" (inst -1 "b!1" "q1!1 - q2!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case "b!1 * (q2!1 - q1!1) = r1!1 - r2!1") (("1" (case "b!1 * (q2!1 - q1!1) >= b!1") (("1" (assert) nil nil) ("2" (lemma "both_sides_times_pos_ge2") (("2" (inst -1 "b!1" "q2!1 - q1!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil)) (unique_remainder 0 (unique_remainder-1 nil 3237052399 ("" (lemma "unique_quotient") (("" (skosimp) (("" (inst?) (("" (assert) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (unique_quotient formula-decl nil euclidean_division nil)) nil)) (unique_division 0 (unique_division-1 nil 3237052399 ("" (lemma "unique_quotient") (("" (lemma "unique_remainder") (("" (skosimp) (("" (inst?) (("" (assert) (("" (inst -2 "b!1" "q1!1" "q2!1" "r1!1" "r2!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((unique_remainder formula-decl nil euclidean_division nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (unique_quotient formula-decl nil euclidean_division nil)) nil)))(divides (mult_divides1 0 (mult_divides1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (divides const-decl "bool" divides nil) (divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (mult_divides1 subtype "number_fields.*(divides.n, divides.m)" "(divides.divides(divides.n))"))) (mult_divides2 0 (mult_divides2-1 nil 3237052399 ("" (skosimp) (("" (grind :if-match nil) (("" (inst 1 "n!1") (("" (assert) nil nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (mult_divides2 subtype "number_fields.*(divides.n, divides.m)" "(divides.divides(divides.m))"))) (divides_sum 0 (divides_sum-1 nil 3237052399 ("" (skosimp) (("" (expand "divides") (("" (skosimp) (("" (skosimp) (("" (inst 1 "x!2 + x!3") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (divides_diff 0 (divides_diff-1 nil 3237052399 ("" (skosimp) (("" (expand "divides") (("" (skosimp*) (("" (inst 1 "x!2 - x!3") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (divides_opposite 0 (divides_opposite-1 nil 3237052399 ("" (skosimp*) (("" (prop) (("1" (expand "divides") (("1" (skosimp*) (("1" (inst 1 "-x!2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "divides") (("2" (skosimp*) (("2" (inst 1 "-x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil)) nil)) (opposite_divides 0 (opposite_divides-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (prop) (("1" (skosimp*) (("1" (inst 1 "-x!2") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "-x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (divides_prod1 0 (divides_prod1-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (skosimp*) (("" (inst 1 "x!2 * m!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (divides_prod2 0 (divides_prod2-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (skosimp*) (("" (inst 1 "x!2 * m!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (divides_prod_elim1 0 (divides_prod_elim1-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (prop) (("1" (skosimp*) (("1" (inst 1 "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (divides_prod_elim2 0 (divides_prod_elim2-1 nil 3237052399 ("" (skosimp*) (("" (lemma "divides_prod_elim1") (("" (inst -1 "m!1" "n!1" "nz!1") (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((divides_prod_elim1 formula-decl nil divides nil) (int_times_int_is_int application-judgement "int" integers nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (divides_reflexive 0 (divides_reflexive-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (inst 1 "1") (("" (assert) nil nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (divides_transitive 0 (divides_transitive-1 nil 3237052399 ("" (skosimp*) (("" (expand "divides") (("" (skosimp*) (("" (inst 1 "x!1 * x!2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (product_one 0 (product_one-2 "" 3299962800 ("" (skosimp) (("" (split) (("1" (flatten) (("1" (lemma "eq1_gt") (("1" (lemma "pos_times_lt") (("1" (inst -1 "x!1" "y!1") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (case "x!1 > 1") (("1" (inst -4 "x!1" "y!1") (("1" (assert) (("1" (assert :flush? t) nil nil)) nil)) nil) ("2" (case "y!1 > 1") (("1" (inst -4 "y!1" "x!1") (("1" (assert) (("1" (assert :flush? t) nil nil)) nil)) nil) ("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 < -1") (("1" (inst -4 "-x!1" "-y!1") (("1" (assert) (("1" (assert :flush? t) nil nil)) nil)) nil) ("2" (case "y!1 < -1") (("1" (inst -4 "-y!1" "-x!1") (("1" (assert) (("1" (assert :flush? t) nil nil)) nil)) nil) ("2" (assert) (("2" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ((eq1_gt formula-decl nil real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pos_times_lt formula-decl nil real_props nil)) shostak) (product_one-1 nil 3237052399 ("" (skosimp) (("" (split) (("1" (flatten) (("1" (lemma "eq1_gt") (("1" (lemma "pos_times_lt") (("1" (inst -1 "x!1" "y!1") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (case "x!1 > 1") (("1" (inst -4 "x!1" "y!1") (("1" (assert) nil nil)) nil) ("2" (case "y!1 > 1") (("1" (inst -4 "y!1" "x!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 < -1") (("1" (inst -4 "-x!1" "-y!1") (("1" (assert) nil nil)) nil) ("2" (case "y!1 < -1") (("1" (inst -4 "-y!1" "-x!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) nil nil)) (mutual_divisors 0 (mutual_divisors-1 nil 3237052399 ("" (expand "divides") (("" (skosimp*) (("" (case "n!1 = 0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "both_sides_times1" ("n0z" "n!1" "x" "x!1 * x!2" "y" "1")) (("2" (ground) (("2" (rewrite "product_one") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (product_one formula-decl nil divides nil) (both_sides_times1 formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (divides const-decl "bool" divides nil)) nil)) (mutual_divisors_nat 0 (mutual_divisors_nat-1 nil 3237052399 ("" (skosimp) (("" (forward-chain "mutual_divisors") (("" (assert) nil nil)) nil)) nil) ((mutual_divisors formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_int_is_int application-judgement "int" integers nil)) nil)) (one_divides 0 (one_divides-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil)) nil)) (divides_zero 0 (divides_zero-1 nil 3237052399 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (divides const-decl "bool" divides nil)) nil)) (zero_div_zero 0 (zero_div_zero-1 nil 3237052399 ("" (grind :if-match all) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (divides const-decl "bool" divides nil)) nil)) (divisors_of_one 0 (divisors_of_one-1 nil 3237052399 ("" (auto-rewrite "one_divides" "opposite_divides") (("" (reduce) (("1" (expand "divides") (("1" (skolem!) (("1" (use "product_one") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "divides") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (one_divides formula-decl nil divides nil) (int_times_int_is_int application-judgement "int" integers nil) (product_one formula-decl nil divides nil) (divides const-decl "bool" divides nil)) nil)) (one_div_one 0 (one_div_one-1 nil 3237052399 ("" (skolem!) (("" (rewrite "divisors_of_one") nil nil)) nil) ((divisors_of_one formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (divisor_smaller 0 (divisor_smaller-2 "" 3299962906 ("" (expand "divides") (("" (skosimp*) (("" (assert) (("" (use "pos_times_lt") (("" (ground) (("" (use "both_sides_times_pos_le1" ("pz" "p!1" "x" "1" "y" "x!1")) (("" (assert) (("" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pos_times_lt formula-decl nil real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (divides const-decl "bool" divides nil)) shostak) (divisor_smaller-1 nil 3237052399 ("" (expand "divides") (("" (skosimp*) (("" (assert) (("" (use "pos_times_lt") (("" (ground) (("" (use "both_sides_times_pos_le1" ("pz" "p!1" "x" "1" "y" "x!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (divides_next 0 (divides_next-1 nil 3252309122 ("" (skolem!) (("" (rewrite "divisors_of_one" :dir rl) (("" (expand "divides") (("" (prop) (("1" (skolem!) (("1" (inst + "x!1 - 1") (("1" (assert) nil nil)) nil)) nil) ("2" (skolem!) (("2" (inst + "x!1 + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divisors_of_one formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divides const-decl "bool" divides nil)) shostak)) (divides_plus_1 0 (divides_plus_1-1 nil 3252309151 ("" (skosimp) (("" (lemma "divides_diff") (("" (inst - "nz!1" "nz!1 + 1" "p1!1") (("" (assert) (("" (rewrite "divisors_of_one") nil nil)) nil)) nil)) nil)) nil) ((divides_diff formula-decl nil divides nil) (divisors_of_one formula-decl nil divides nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)))(modulo_arithmetic (nrem_TCC1 0 (nrem_TCC1-1 nil 3717230987 ("" (inst 1 "lambda (i: int, p: posnat): choose! (r: mod(p)): exists q: i = r + p * q") (("" (skeep) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (lemma "euclid_int") (("" (inst -1 "p" "i") (("" (skeep) (("" (inst -2 "r") (("" (inst 1 "q") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (euclid_int formula-decl nil euclidean_division nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak (nrem existence "" "[d: [int, posnat] -> {r: euclidean_division.mod(d`2) | EXISTS q: d`1 = (number_fields.+)(r, number_fields.*(d`2, modulo_arithmetic.q))}]"))) (rem_TCC1 0 (rem_TCC1-1 nil 3237052399 ("" (inst 1 "lambda (b: posnat): lambda (x: int): choose! (r: mod(b)): exists q: x = r + b * q") (("" (lemma "euclid_int") (("" (skeep) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -1 "b" "x") (("" (skeep) (("" (inst -2 "r") (("" (inst 1 "q") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((euclid_int formula-decl nil euclidean_division nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (rem existence "" "[b: integers.posnat -> [x: integers.int -> {r: euclidean_division.mod(b) | EXISTS q: x = (number_fields.+)(r, number_fields.*(b, modulo_arithmetic.q))}]]"))) (rem_def 0 (rem_def-1 nil 3237052399 ("" (skolem!) (("" (case "EXISTS q: x!1 = b!1 * q + rem(b!1)(x!1)") (("1" (ground) (("1" (skosimp*) (("1" (use "unique_remainder") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (typepred "rem(b!1)(x!1)") (("2" (skosimp) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (unique_remainder formula-decl nil euclidean_division nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_def2 0 (rem_def2-1 nil 3237052399 ("" (skolem!) (("" (rewrite "rem_def") (("" (expand "divides") (("" (ground) (("1" (skolem!) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (skolem!) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_def formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_def3 0 (rem_def3-1 nil 3237052399 ("" (skolem!) (("" (rewrite "rem_def2") (("" (ground) (("1" (rewrite "divides_opposite" :dir rl) nil nil) ("2" (rewrite "divides_opposite" :dir rl) nil nil)) nil)) nil)) nil) ((rem_def2 formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (divides_opposite formula-decl nil divides nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_nrem0 0 (rem_nrem0-1 nil 3728617532 ("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) (("" (typepred "rem(x!1)(x!2)") (("" (skeep) (("" (typepred "nrem(x!2, x!1)") (("" (skeep) (("" (name-replace "nr" "nrem(x!2, x!1)") (("" (name-replace "r" "rem(x!1)(x!2)") (("" (lemma "unique_remainder") (("" (inst -1 "x!1" "q!1" "q" "nr" "r") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (unique_remainder formula-decl nil euclidean_division nil) (NOT const-decl "[bool -> bool]" booleans nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (rem_nrem 0 (rem_nrem-1 nil 3728764938 ("" (skeep) (("" (use "rem_nrem0") (("" (assert) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((rem_nrem0 formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (rem_mod 0 (rem_mod-1 nil 3237052399 ("" (auto-rewrite "divides_zero") (("" (skolem!) (("" (rewrite "rem_def2") nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides_zero formula-decl nil divides nil)) nil)) (rem_mod2 0 (rem_mod2-1 nil 3237052399 ("" (skosimp) (("" (assert) (("" (rewrite "rem_mod") nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem_mod formula-decl nil modulo_arithmetic nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_zero 0 (rem_zero-1 nil 3237052399 ("" (auto-rewrite "divides_zero" "rem_def2") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_zero formula-decl nil divides nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (rem_self 0 (rem_self-1 nil 3237052399 ("" (auto-rewrite "divides_reflexive" "rem_def2") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (divides_reflexive formula-decl nil divides nil)) nil)) (rem_multiple1 0 (rem_multiple1-1 nil 3237052399 ("" (auto-rewrite "divides_prod1" "divides_prod2" "divides_reflexive" "rem_def2") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_reflexive formula-decl nil divides nil) (divides_prod1 formula-decl nil divides nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (rem_multiple2 0 (rem_multiple2-1 nil 3237052399 ("" (auto-rewrite "divides_prod1" "divides_prod2" "divides_reflexive" "rem_def2") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_reflexive formula-decl nil divides nil) (divides_prod2 formula-decl nil divides nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (rem_one 0 (rem_one-1 nil 3237052399 ("" (skosimp) (("" (rewrite "rem_def") (("" (inst + "0") (("" (assert) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rem_def formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_minus_one 0 (rem_minus_one-1 nil 3237052399 ("" (skolem!) (("" (rewrite "rem_def") (("" (inst + "-1") (("" (assert) nil nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (same_remainder 0 (same_remainder-1 nil 3237052399 ("" (skolem!) (("" (name-replace "r!1" "rem(b!1)(y!1)" :hide? nil) (("" (rewrite "rem_def2") (("" (rewrite "rem_def2") (("" (ground) (("1" (use "divides_diff" ("n" "x!1 - r!1" "m" "y!1 - r!1")) (("1" (assert) nil nil)) nil) ("2" (use "divides_sum" ("n" "x!1 - y!1" "m" "y!1 - r!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (divides_sum formula-decl nil divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (divides_diff formula-decl nil divides nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_rem 0 (rem_rem-1 nil 3237052399 ("" (skolem!) (("" (rewrite "same_remainder") (("" (name-replace "r!1" "rem(b!1)(x!1)" :hide? nil) (("" (rewrite "rem_def3") nil nil)) nil)) nil)) nil) ((same_remainder formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def3 formula-decl nil modulo_arithmetic nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_sum 0 (rem_sum-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skosimp) (("" (assert) (("" (use "divides_sum" ("n" "x!1 - y!1" "m" "z!1 - t!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_sum formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (rem_sum1 0 (rem_sum1-1 nil 3237052399 ("" (skolem!) (("" (rewrite "same_remainder") (("" (rewrite "rem_def3" :dir rl) nil nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def3 formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_sum2 0 (rem_sum2-1 nil 3237052399 ("" (skolem!) (("" (use "rem_sum1" ("x" "y!1" "y" "x!1")) (("" (assert) nil nil)) nil)) nil) ((rem_sum1 formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_diff 0 (rem_diff-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skosimp) (("" (assert) (("" (use "divides_diff" ("n" "x!1 - y!1" "m" "z!1 - t!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_diff formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil)) (rem_diff1 0 (rem_diff1-1 nil 3237052399 ("" (skolem!) (("" (rewrite "same_remainder") (("" (rewrite "rem_def3" :dir rl) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (rem_def3 formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_diff2 0 (rem_diff2-1 nil 3237052399 ("" (skolem!) (("" (rewrite "same_remainder") (("" (rewrite "rem_def2" :dir rl) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_prod1 0 (rem_prod1-1 nil 3237052399 ("" (skolem!) (("" (rewrite "same_remainder") (("" (use "divides_prod1" ("n" "rem(b!1)(x!1) - x!1" "m" "y!1")) (("" (assert) (("" (rewrite "rem_def3" :dir rl) nil nil)) nil)) nil)) nil)) nil) ((same_remainder formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (rem_def3 formula-decl nil modulo_arithmetic nil) (divides_prod1 formula-decl nil divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_prod2 0 (rem_prod2-1 nil 3237052399 ("" (skolem!) (("" (use "rem_prod1" ("x" "y!1" "y" "x!1")) (("" (assert) nil nil)) nil)) nil) ((rem_prod1 formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_prod 0 (rem_prod-1 nil 3237052399 ("" (skosimp) (("" (auto-rewrite "rem_prod1" "rem_prod2") (("" (case "rem(b!1)(rem(b!1)(x!1) * rem(b!1)(z!1)) = rem(b!1)(y!1 * t!1)") (("1" (assert) nil nil) ("2" (replace*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((rem_prod1 formula-decl nil modulo_arithmetic nil) (rem_prod2 formula-decl nil modulo_arithmetic nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_expt 0 (rem_expt-1 nil 3237052399 ("" (skolem 1 ("b!1" _ "x!1" "y!1")) (("" (induct-and-simplify "n" :exclude "rem" :rewrites ("rem_prod")) nil nil)) nil) ((int_expt application-judgement "int" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (expt def-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rem_prod formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_expt1 0 (rem_expt1-1 nil 3237052399 ("" (skolem!) (("" (rewrite "rem_expt") (("" (rewrite "rem_rem") nil nil)) nil)) nil) ((rem_expt formula-decl nil modulo_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (int_expt application-judgement "int" exponentiation nil) (nat_expt application-judgement "nat" exponentiation nil) (rem_rem formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (rem_sum_elim1 0 (rem_sum_elim1-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil)) nil)) (rem_sum_elim2 0 (rem_sum_elim2-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil)) nil)) (rem_diff_elim1 0 (rem_diff_elim1-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skolem!) (("" (assert) (("" (prop) (("1" (rewrite "divides_opposite" :dir rl) (("1" (assert) nil nil)) nil) ("2" (rewrite "divides_opposite" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (divides_opposite formula-decl nil divides nil) (same_remainder formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (rem_diff_elim2 0 (rem_diff_elim2-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skolem!) (("" (assert) nil nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil)) nil)) (rem_opposite_elim 0 (rem_opposite_elim-1 nil 3237052399 ("" (auto-rewrite "same_remainder") (("" (skolem!) (("" (assert) (("" (rewrite "divides_opposite" :dir rl) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (divides_opposite formula-decl nil divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (ndiv_TCC1 0 (ndiv_TCC1-1 nil 3237052399 ("" (inst 1 "lambda (i: int, p: posnat): choose! (q: int): i = rem(p)(i) + p * q") (("" (skeep) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (lemma "euclid_int") (("" (inst -1 "p" "i") (("" (skeep) (("" (inst -2 "q") (("" (lemma "rem_def") (("" (inst -1 "p" "i" "r") (("" (assert) (("" (inst 1 "q") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (euclid_int formula-decl nil euclidean_division nil) (rem_def formula-decl nil modulo_arithmetic nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (ndiv existence "" "[d: [int, posnat] -> {q: integers.int | d`1 = (number_fields.+)(modulo_arithmetic.rem(d`2)(d`1), number_fields.*(d`2, q))}]"))) (ndiv_lt 0 (ndiv_lt-1 nil 3237052399 ("" (skosimp*) (("" (typepred "ndiv(x!1, b!1)") (("" (case-replace "x!1 - rem(b!1)(x!1) = b!1 * ndiv(x!1, b!1)") (("1" (hide -2) (("1" (case "x!1/b!1 - rem(b!1)(x!1)/b!1 = ndiv(x!1, b!1)") (("1" (hide -2) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "both_sides_div1") (("2" (inst -1 "b!1" "x!1 - rem(b!1)(x!1)" "b!1 * ndiv(x!1, b!1)") (("2" (case-replace "b!1 * ndiv(x!1, b!1) / b!1 = ndiv(x!1, b!1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_div1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil)) nil)) (ndiv_TCC2 0 (ndiv_TCC2-1 nil 3237052399 ("" (skosimp*) (("" (lemma "ndiv_lt") (("" (inst?) (("" (case "n!1/b!1 <= n!1") (("1" (assert) (("1" (hide -1) (("1" (typepred "ndiv(n!1, b!1)") (("1" (case "n!1 < rem(b!1)(n!1)") (("1" (lemma "rem_mod2") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (case "b!1 * ndiv(n!1, b!1) >= 0") (("1" (lemma "both_sides_times_pos_ge1") (("1" (inst -1 "b!1" "ndiv(n!1, b!1)" "0") (("1" (replace -1 2 rl t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -1) (("2" (lemma "le_div_le_pos") (("2" (inst -1 "n!1" "1" "b!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ndiv_lt formula-decl nil modulo_arithmetic nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (rem_mod2 formula-decl nil modulo_arithmetic nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_div_le_pos formula-decl nil real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (ndiv_ subtype "modulo_arithmetic.ndiv(modulo_arithmetic.n, modulo_arithmetic.b)" "naturalnumbers.upto(modulo_arithmetic.n)"))) (rem_floor 0 (rem_floor-1 nil 3252309244 ("" (skolem!) (("" (lemma "rem_def" ("b" "b!1" "x" "x!1" "r" "x!1 - b!1 * floor(x!1 / b!1)")) (("1" (assert) (("1" (inst + "floor(x!1 / b!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "floor(x!1 / b!1)") (("2" (split) (("1" (both-sides "*" "b!1" -1) (("1" (assert) nil nil)) nil) ("2" (both-sides "*" "b!1" -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem_def formula-decl nil modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (rem_base 0 (rem_base-3 "" 3471680077 ("" (skolem!) (("" (expand "divides") (("" (prop) (("1" (typepred "rem(b!1)(x!1)") (("1" (typepred "rem(b!1 + n!1)(x!1 + i!1)") (("1" (skosimp*) (("1" (inst + "q!1 - floor(x!1 / b!1)") (("1" (both-sides "+" "n!1 * floor(x!1 / b!1)") (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst - "floor(x!1 / b!1)" "n!1") (("1" (replace -1) (("1" (assert) (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (lemma "rem_def2") (("2" (inst - "b!1 + n!1" "i!1 + x!1" "rem(b!1)(x!1)") (("1" (assert) (("1" (expand "divides") (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (inst + "x!2 + floor(x!1 / b!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divides const-decl "bool" divides nil) (n!1 skolem-const-decl "nat" modulo_arithmetic nil) (x!1 skolem-const-decl "int" modulo_arithmetic nil) (b!1 skolem-const-decl "posnat" modulo_arithmetic nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (commutative_mult formula-decl nil number_fields nil) (rem_floor formula-decl nil modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak) (rem_base-2 "" 3458163989 ("" (skolem!) (("" (expand "divides") (("" (prop) (("1" (typepred "rem(b!1)(x!1)") (("1" (typepred "rem(b!1 + n!1)(x!1 + i!1)") (("1" (skosimp*) (("1" (inst + "q!1 - floor(x!1 / b!1)") (("1" (both-sides "+" "n!1 * floor(x!1 / b!1)") (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst - "floor(x!1 / b!1)" "n!1") (("1" (replace -1) (("1" (assert) (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (lemma "rem_def2") (("2" (inst - "i!1 + x!1" "b!1 + n!1" "rem(b!1)(x!1)") (("1" (assert) (("1" (expand "divides") (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (inst + "x!2 + floor(x!1 / b!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (rem_base-1 nil 3252309295 ("" (skolem!) (("" (expand "divides") (("" (prop) (("1" (typepred "rem(b!1)(x!1)") (("1" (typepred "rem(b!1 + n!1)(x!1 + i!1)") (("1" (skosimp*) (("1" (inst + "q!1 - floor(x!1 / b!1)") (("1" (both-sides "+" "n!1 * floor(x!1 / b!1)") (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst - "floor(x!1 / b!1)" "n!1") (("1" (replace -1) (("1" (assert) (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (lemma "rem_def2") (("2" (inst - "b!1 + n!1" "i!1 + x!1" "rem(b!1)(x!1)") (("1" (assert) (("1" (expand "divides") (("1" (lemma "rem_floor") (("1" (inst - "b!1" "x!1") (("1" (inst + "x!2 + floor(x!1 / b!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (rem_sum_floor 0 (rem_sum_floor-1 nil 3252309346 ("" (skolem!) (("" (use "rem_def") (("1" (assert) (("1" (inst + "floor(x!1 / b!1) + floor((rem(b!1)(x!1) + i!1) / b!1)") (("1" (assert) (("1" (use "commutative_mult") (("1" (replace -1) (("1" (use "rem_floor") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "floor((rem(b!1)(x!1) + i!1) / b!1)") (("2" (split) (("1" (both-sides "*" "b!1" -1) (("1" (assert) nil nil)) nil) ("2" (both-sides "*" "b!1" -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rem_def formula-decl nil modulo_arithmetic nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (b!1 skolem-const-decl "posnat" modulo_arithmetic nil) (x!1 skolem-const-decl "int" modulo_arithmetic nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (i!1 skolem-const-decl "int" modulo_arithmetic nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (commutative_mult formula-decl nil number_fields nil) (rem_floor formula-decl nil modulo_arithmetic nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (rem_sum_assoc 0 (rem_sum_assoc-1 nil 3252309412 ("" (skolem!) (("" (typepred "rem(b!1)(x!1 + n!1)") (("" (typepred "rem(b!1)(x!1)") (("" (skosimp*) (("" (ground) (("" (use "rem_def2") (("" (assert) (("" (use "rem_floor") (("" (both-sides "-" "rem(b!1)(x!1)" -1) (("" (assert) (("" (replace -1) (("" (expand "divides") (("" (inst + "floor(x!1 / b!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (rem_floor formula-decl nil modulo_arithmetic nil) (divides const-decl "bool" divides nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (rem_add_one 0 (rem_add_one-2 "" 3458164037 ("" (skolem!) (("" (use "rem_sum_assoc") (("" (smash) (("" (lemma "rem_def") (("" (inst - "b!1" "x!1" "b!1 - 1") (("" (assert) (("" (skolem!) (("" (replace -1 3) (("" (assert) (("" (lemma "rem_multiple1") (("" (inst - "b!1" "q!1 + 1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_sum_assoc formula-decl nil modulo_arithmetic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem_def formula-decl nil modulo_arithmetic nil) (rem_multiple1 formula-decl nil modulo_arithmetic nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak) (rem_add_one-1 nil 3252309454 ("" (skolem!) (("" (use "rem_sum_assoc") (("" (smash) (("" (lemma "rem_def") (("" (inst - "b!1" "x!1" "b!1 - 1") (("" (assert) (("" (skolem!) (("" (replace -1 3) (("" (assert) (("" (lemma "rem_multiple1") (("" (inst - "b!1" "q!1 + 1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (rem_wrap 0 (rem_wrap-1 nil 3252309504 ("" (skolem!) (("" (prop) (("1" (use "rem_sum_floor") (("1" (assert) (("1" (lemma "floor_val") (("1" (inst - "rem(b!1)(x!1) + n!1" "b!1" "1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (use "rem_sum_assoc") (("3" (assert) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_val formula-decl nil floor_ceil nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (rem_sum_floor formula-decl nil modulo_arithmetic nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rem_sum_assoc formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (rem_wrap_eq 0 (rem_wrap_eq-1 nil 3252309534 ("" (skolem!) (("" (use "rem_wrap") (("" (lemma "same_remainder") (("" (inst - "b!1" "n!1 + x!1" "x!1") (("" (smash) nil nil)) nil)) nil)) nil)) nil) ((rem_wrap formula-decl nil modulo_arithmetic nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (same_remainder formula-decl nil modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)))(subrange_inductions (subrange_induction_TCC1 0 (subrange_induction_TCC1-1 nil 3237052399 ("" (assert) (("" (typepred "j") (("" (assert) nil nil)) nil)) nil) ((j formal-const-decl "upfrom(i)" subrange_inductions nil) (upfrom nonempty-type-eq-decl nil integers nil) (i formal-const-decl "int" subrange_inductions nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (subrange_induction subtype "subrange_inductions.i" "integers.subrange(subrange_inductions.i, subrange_inductions.j)"))) (subrange_induction_TCC2 0 (subrange_induction_TCC2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (subrange type-eq-decl nil integers nil) (j formal-const-decl "upfrom(i)" subrange_inductions nil) (upfrom nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (i formal-const-decl "int" subrange_inductions nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (subrange_induction subtype "(number_fields.+)(subrange_inductions.k, 1)" "integers.subrange(subrange_inductions.i, subrange_inductions.j)"))) (subrange_induction 0 (subrange_induction-1 nil 3237052399 ("" (lemma "nat_induction") (("" (skosimp*) (("" (inst -1 "lambda (n:nat): n <= j - i IMPLIES p!1(n+i)") (("1" (prop) (("1" (inst -1 "k!1 - i") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (inst -4 "j!1 + i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (j!1 skolem-const-decl "nat" subrange_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i formal-const-decl "int" subrange_inductions nil) (upfrom nonempty-type-eq-decl nil integers nil) (j formal-const-decl "upfrom(i)" subrange_inductions nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)) (SUBRANGE_induction 0 (SUBRANGE_induction-1 nil 3237052399 ("" (skosimp) (("" (skosimp) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): n <= j - i IMPLIES p!1(n+i)") (("1" (split) (("1" (inst -2 "k!1") (("1" (assert) (("1" (skosimp) (("1" (inst -1 "m!1-i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 "j!1+i") (("1" (assert) (("1" (skosimp) (("1" (inst -1 "m!1-i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j formal-const-decl "upfrom(i)" subrange_inductions nil) (upfrom nonempty-type-eq-decl nil integers nil) (i formal-const-decl "int" subrange_inductions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NAT_induction formula-decl nil naturalnumbers nil)) nil)))(bounded_int_inductions (upfrom_induction_TCC1 0 (upfrom_induction_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (upfrom_induction subtype "bounded_int_inductions.m" "integers.upfrom(bounded_int_inductions.m)"))) (upfrom_induction_TCC2 0 (upfrom_induction_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) nil nil (upfrom_induction subtype "(number_fields.+)(bounded_int_inductions.jf, 1)" "integers.upfrom(bounded_int_inductions.m)"))) (upfrom_induction 0 (upfrom_induction-2 "" 3299963135 ("" (lemma "nat_induction") (("" (skosimp*) (("" (inst -1 "lambda (n:nat): (exists (i:int): (m <= i and n = i - m)) IMPLIES pf!1(n+m)") (("" (prop) (("1" (inst -1 "jf!1-m") (("1" (assert) (("1" (assert :flush? t) (("1" (assert :quant-simp? t) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (split) (("1" (inst -5 "j!1+m") (("1" (assert) nil nil)) nil) ("2" (inst 1 "j!1+m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (m formal-const-decl "int" bounded_int_inductions nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil)) shostak) (upfrom_induction-1 nil 3237052399 ("" (lemma "nat_induction") (("" (skosimp*) (("" (inst -1 "lambda (n:nat): (exists (i:int): (m <= i and n = i - m)) IMPLIES pf!1(n+m)") (("" (prop) (("1" (inst -1 "jf!1-m") (("1" (assert) nil nil)) nil) ("2" (hide -1) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (split) (("1" (inst -5 "j!1+m") (("1" (assert) nil nil)) nil) ("2" (inst 1 "j!1+m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (UPFROM_induction 0 (UPFROM_induction-2 "" 3299963189 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m <= i and n = i - m)) IMPLIES pf!1(n+m)") (("" (prop) (("1" (inst -1 "jf!1-m") (("1" (split) (("1" (assert) nil nil) ("2" (inst 1 "jf!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -4 "j!1+m") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "kf!1-m") (("2" (assert :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NAT_induction formula-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (m formal-const-decl "int" bounded_int_inductions nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak) (UPFROM_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m <= i and n = i - m)) IMPLIES pf!1(n+m)") (("" (prop) (("1" (inst -1 "jf!1-m") (("1" (split) (("1" (assert) nil nil) ("2" (inst 1 "jf!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -4 "j!1+m") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "kf!1-m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (above_induction_TCC1 0 (above_induction_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (above_induction subtype "(number_fields.+)(bounded_int_inductions.m, 1)" "integers.above(bounded_int_inductions.m)"))) (above_induction_TCC2 0 (above_induction_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((int_plus_int_is_int application-judgement "int" integers nil)) nil (above_induction subtype "(number_fields.+)(bounded_int_inductions.ja, 1)" "integers.above(bounded_int_inductions.m)"))) (above_induction 0 (above_induction-2 "" 3299963282 ("" (skosimp*) (("" (lemma "nat_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m < i and n = i - m)) IMPLIES pa!1(n+m)") (("1" (prop) (("1" (inst -1 "ja!1-m") (("1" (assert) (("1" (assert :quant-simp? t) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (split) (("1" (inst -5 "j!1+m") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst 1 "j!1+m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (above nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (m formal-const-decl "int" bounded_int_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak) (above_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "nat_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m < i and n = i - m)) IMPLIES pa!1(n+m)") (("1" (prop) (("1" (inst -1 "ja!1-m") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (split) (("1" (inst -5 "j!1+m") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst 1 "j!1+m") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil)) (ABOVE_induction 0 (ABOVE_induction-2 "" 3299963342 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m < i and n = i - m)) IMPLIES pa!1(n+m)") (("1" (prop) (("1" (inst -1 "ja!1-m") (("1" (split) (("1" (assert) nil nil) ("2" (inst 1 "ja!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -4 "j!1+m") (("1" (assert) (("1" (skosimp*) (("1" (inst -1 "ka!1-m") (("1" (assert :quant-simp? t) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((NAT_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (above nonempty-type-eq-decl nil integers nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (m formal-const-decl "int" bounded_int_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak) (ABOVE_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): (exists (i:int): (m < i and n = i - m)) IMPLIES pa!1(n+m)") (("1" (prop) (("1" (inst -1 "ja!1-m") (("1" (split) (("1" (assert) nil nil) ("2" (inst 1 "ja!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -4 "j!1+m") (("1" (assert) (("1" (skosimp*) (("1" (inst -1 "ka!1-m") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil)))(bounded_nat_inductions (upto_induction_TCC1 0 (upto_induction_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (upto_induction subtype "0" "naturalnumbers.upto(bounded_nat_inductions.m)"))) (upto_induction_TCC2 0 (upto_induction_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (upto_induction subtype "(number_fields.+)(bounded_nat_inductions.jt, 1)" "naturalnumbers.upto(bounded_nat_inductions.m)"))) (upto_induction 0 (upto_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "nat_induction") (("" (inst -1 "lambda (n:nat): n <= m IMPLIES pt!1(n)") (("" (prop) (("1" (inst -1 "jt!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst -4 "j!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat_induction formula-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (j!1 skolem-const-decl "nat" bounded_nat_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (UPTO_induction 0 (UPTO_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): n <= m IMPLIES pt!1(n)") (("" (prop) (("1" (inst -1 "jt!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst -3 "j!1") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "kt!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NAT_induction formula-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (below_induction_TCC1 0 (below_induction_TCC1-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (below_induction subtype "0" "naturalnumbers.below(bounded_nat_inductions.m)"))) (below_induction_TCC2 0 (below_induction_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (below type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (below_induction subtype "(number_fields.+)(bounded_nat_inductions.jb, 1)" "naturalnumbers.below(bounded_nat_inductions.m)"))) (below_induction 0 (below_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "nat_induction") (("" (inst -1 "lambda (n:nat): n < m IMPLIES pb!1(n)") (("" (prop) (("1" (inst -2 "jb!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (skosimp*) (("4" (inst -4 "j!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j!1 skolem-const-decl "nat" bounded_nat_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (BELOW_induction 0 (BELOW_induction-1 nil 3237052399 ("" (skosimp*) (("" (lemma "NAT_induction") (("" (inst -1 "lambda (n:nat): n < m IMPLIES pb!1(n)") (("" (prop) (("1" (inst -1 "jb!1") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (inst -3 "j!1") (("2" (assert) (("2" (skosimp*) (("2" (inst -1 "kb!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NAT_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" bounded_nat_inductions nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)))(subrange_type)(int_types)(nat_types)(exp2 (exp2_TCC1 0 (exp2_TCC1-1 nil 3242699046 ("" (skosimp) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (exp2 subtype "(number_fields.-)(exp2.n, 1)" "nat"))) (exp2_TCC2 0 (exp2_TCC2-1 nil 3242699046 ("" (skosimp) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (exp2 termination "exp2.exp2((number_fields.-)(exp2.n, 1))" "nil"))) (exp2_TCC3 0 (exp2_TCC3-1 nil 3242699046 ("" (induct-and-simplify "n") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (exp2_ subtype "exp2.exp2(exp2.n)" "integers.above(exp2.n)"))) (exp2_def 0 (exp2_def-1 nil 3242701800 ("" (induct-and-simplify "n") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (nil application-judgement "above(n)" exp2 nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (exp2_pos 0 (exp2_pos-1 nil 3242701810 ("" (induct-and-simplify "n") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (exp2_n 0 (exp2_n-1 nil 3242701817 ("" (induct-and-simplify "n") nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (nil application-judgement "above(n)" exp2 nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (exp2_sum 0 (exp2_sum-1 nil 3242701824 ("" (induct-and-simplify "n") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (exp2_minus_TCC1 0 (exp2_minus_TCC1-1 nil 3242699046 ("" (skosimp) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (exp2_minus subtype "(number_fields.-)(exp2.n, exp2.k)" "nat"))) (exp2_minus 0 (exp2_minus-1 nil 3242701829 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp) (("2" (induct-and-simplify "k") nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (exp2_strictpos 0 (exp2_strictpos-1 nil 3242701904 ("" (induct-and-simplify "n") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nat_induction formula-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (exp2_lt 0 (exp2_lt-1 nil 3242701912 ("" (induct "m") (("1" (grind) nil nil) ("2" (skosimp) (("2" (induct-and-simplify "n") nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (exp_prop 0 (exp_prop-1 nil 3242701951 ("" (skosimp*) (("" (rewrite "exp2_sum") (("" (lemma "both_sides_times_pos_le1") (("" (inst -1 "exp2(m!1)" "x1!1" "exp2(n!1)-1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (both_sides_times_pos_le1 formula-decl nil real_props nil)) shostak)) (log2_TCC1 0 (log2_TCC1-1 nil 3835419863 ("" (skeep) (("" (use "ndiv_lt") (("" (assert) nil nil)) nil)) nil) ((ndiv_lt formula-decl nil modulo_arithmetic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (int_times_int_is_int application-judgement "int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak (log2 termination "exp2.log2(modulo_arithmetic.ndiv(exp2.n, 2))" "nil"))))(integertypes (uint16_TCC1 0 (uint16_TCC1-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) nil (uint16 subtype "(number_fields.-)(exp2.exp2(16), 1)" "nat"))) (uint32_TCC1 0 (uint32_TCC1-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) nil (uint32 subtype "(number_fields.-)(exp2.exp2(32), 1)" "nat"))) (uint64_TCC1 0 (uint64_TCC1-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) nil (uint64 subtype "(number_fields.-)(exp2.exp2(64), 1)" "nat"))) (max8_TCC1 0 (max8_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2 def-decl "posnat" exp2 nil)) nil (max8 subtype "255" "uint8"))) (max16_TCC1 0 (max16_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2 def-decl "posnat" exp2 nil)) nil (max16 subtype "65535" "uint16"))) (max32_TCC1 0 (max32_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2 def-decl "posnat" exp2 nil)) nil (max32 subtype "4294967295" "uint32"))) (max64_TCC1 0 (max64_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (exp2 def-decl "posnat" exp2 nil)) nil (max64 subtype "(number_fields.+)((number_fields.*(9223372036854775807, 2)), 1)" "uint64"))) (mini8_TCC1 0 (mini8_TCC1-1 nil 3844186117 ("" (grind) nil nil) ((exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (mini8 subtype "(number_fields.-)(exp2.exp2(7))" "int8"))) (mini16_TCC1 0 (mini16_TCC1-1 nil 3844186133 ("" (grind) nil nil) ((exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (mini16 subtype "(number_fields.-)(exp2.exp2(15))" "int16"))) (mini32_TCC1 0 (mini32_TCC1-1 nil 3844186141 ("" (grind) nil nil) ((exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (mini32 subtype "(number_fields.-)(exp2.exp2(31))" "int32"))) (mini64_TCC1 0 (mini64_TCC1-1 nil 3844186149 ("" (grind) nil nil) ((exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (mini64 subtype "(number_fields.-)(exp2.exp2(63))" "int64"))) (maxi8_TCC1 0 (maxi8_TCC1-1 nil 3867803483 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (maxi8 subtype "(number_fields.-)(exp2.exp2(7), 1)" "int8"))) (maxi16_TCC1 0 (maxi16_TCC1-1 nil 3867803483 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (maxi16 subtype "(number_fields.-)(exp2.exp2(15), 1)" "int16"))) (maxi32_TCC1 0 (maxi32_TCC1-1 nil 3867803483 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (maxi32 subtype "(number_fields.-)(exp2.exp2(31), 1)" "int32"))) (maxi64_TCC1 0 (maxi64_TCC1-1 nil 3867803483 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (maxi64 subtype "(number_fields.-)(exp2.exp2(63), 1)" "int64"))) (maxindex_TCC1 0 (maxindex_TCC1-1 nil 3835419865 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (maxindex subtype "(number_fields.-)(exp2.exp2(28), 1)" "uint32"))) (subtype_u8_u16 0 (subtype_u8_u16-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (subtype_u8_u16 subtype "integertypes.x" "uint16"))) (subtype_u8_i16 0 (subtype_u8_i16-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (subtype_u8_i16 subtype "integertypes.x" "int16"))) (subtype_u16_u32 0 (subtype_u16_u32-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (subtype_u16_u32 subtype "integertypes.x" "uint32"))) (subtype_u16_i32 0 (subtype_u16_i32-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (subtype_u16_i32 subtype "integertypes.x" "int32"))) (subtype_u32_u64 0 (subtype_u32_u64-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (subtype_u32_u64 subtype "integertypes.x" "uint64"))) (subtype_u32_i64 0 (subtype_u32_i64-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (subtype_u32_i64 subtype "integertypes.x" "int64"))) (plus_u8_u8 0 (plus_u8_u8-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (plus_u8_u8 subtype "(number_fields.+)(integertypes.ux8, integertypes.uy8)" "uint16"))) (plus_u16_u16 0 (plus_u16_u16-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_u16_u16 subtype "(number_fields.+)(integertypes.ux16, integertypes.uy16)" "uint32"))) (plus_u32_u32 0 (plus_u32_u32-1 nil 3867803483 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_u32_u32 subtype "(number_fields.+)(integertypes.ux32, integertypes.uy32)" "uint64"))) (plus_u8_i8 0 (plus_u8_i8-1 nil 3867803484 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_u8_i8 subtype "(number_fields.+)(integertypes.ux8, integertypes.y8)" "int16"))) (plus_i8_u8 0 (plus_i8_u8-1 nil 3867803484 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (plus_u8_i8 application-judgement "int16" integertypes nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_i8_u8 subtype "(number_fields.+)(integertypes.x8, integertypes.uy8)" "int16"))) (plus_u16_i16 0 (plus_u16_i16-1 nil 3867803484 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_u16_i16 subtype "(number_fields.+)(integertypes.ux16, integertypes.y16)" "int32"))) (plus_i16_u16 0 (plus_i16_u16-1 nil 3867803484 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (plus_u16_i16 application-judgement "int32" integertypes nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_i16_u16 subtype "(number_fields.+)(integertypes.x16, integertypes.uy16)" "int32"))) (plus_u32_i32 0 (plus_u32_i32-1 nil 3867803485 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_u32_i32 subtype "(number_fields.+)(integertypes.ux32, integertypes.y32)" "int64"))) (plus_i32_u32 0 (plus_i32_u32-1 nil 3867803485 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (plus_u32_i32 application-judgement "int64" integertypes nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus_i32_u32 subtype "(number_fields.+)(integertypes.x32, integertypes.uy32)" "int64"))) (u8plus_TCC1 0 (u8plus_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (max8 const-decl "uint8" integertypes nil) (exp2 def-decl "posnat" exp2 nil)) nil (u8plus subtype "(number_fields.-)(integertypes.max8, integertypes.ux8)" "uint8"))) (u8plus_TCC2 0 (u8plus_TCC2-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (plus_u8_u8 application-judgement "uint16" integertypes nil) (max8 const-decl "uint8" integertypes nil) (exp2 def-decl "posnat" exp2 nil)) nil (u8plus subtype "(number_fields.+)(integertypes.ux8, integertypes.uy8)" "uint8"))) (u8plus_TCC3 0 (u8plus_TCC3-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max8 const-decl "uint8" integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (u8plus subtype "(number_fields.-)((number_fields.-)(integertypes.uy8, integertypes.gap), 1)" "uint8"))) (u16plus_TCC1 0 (u16plus_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (max16 const-decl "uint16" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16plus subtype "(number_fields.-)(integertypes.max16, integertypes.ux16)" "uint16"))) (u16plus_TCC2 0 (u16plus_TCC2-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (plus_u16_u16 application-judgement "uint32" integertypes nil) (max16 const-decl "uint16" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16plus subtype "(number_fields.+)(integertypes.ux16, integertypes.uy16)" "uint16"))) (u16plus_TCC3 0 (u16plus_TCC3-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max16 const-decl "uint16" integertypes nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (u16plus subtype "(number_fields.-)((number_fields.-)(integertypes.uy16, integertypes.gap), 1)" "uint16"))) (u32plus_TCC1 0 (u32plus_TCC1-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (max32 const-decl "uint32" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32plus subtype "(number_fields.-)(integertypes.max32, integertypes.ux32)" "uint32"))) (u32plus_TCC2 0 (u32plus_TCC2-1 nil 3750736729 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (plus_u32_u32 application-judgement "uint64" integertypes nil) (max32 const-decl "uint32" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32plus subtype "(number_fields.+)(integertypes.ux32, integertypes.uy32)" "uint32"))) (u32plus_TCC3 0 (u32plus_TCC3-1 nil 3750736729 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max32 const-decl "uint32" integertypes nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (u32plus subtype "(number_fields.-)((number_fields.-)(integertypes.uy32, integertypes.gap), 1)" "uint32"))) (u64plus_TCC1 0 (u64plus_TCC1-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max64 const-decl "uint64" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64plus subtype "(number_fields.-)(integertypes.max64, integertypes.ux64)" "uint64"))) (u64plus_TCC2 0 (u64plus_TCC2-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (max64 const-decl "uint64" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64plus subtype "(number_fields.+)(integertypes.ux64, integertypes.uy64)" "uint64"))) (u64plus_TCC3 0 (u64plus_TCC3-1 nil 3750736730 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max64 const-decl "uint64" integertypes nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (u64plus subtype "(number_fields.-)((number_fields.-)(integertypes.uy64, integertypes.gap), 1)" "uint64"))) (minus_u8_u8 0 (minus_u8_u8-1 nil 3867803490 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (minus_u8_u8 subtype "(number_fields.-)(integertypes.ux8, integertypes.uy8)" "int16"))) (minus_u16_u16 0 (minus_u16_u16-1 nil 3867803491 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_u16_u16 subtype "(number_fields.-)(integertypes.ux16, integertypes.uy16)" "int32"))) (minus_u32_u32 0 (minus_u32_u32-1 nil 3867803491 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_u32_u32 subtype "(number_fields.-)(integertypes.ux32, integertypes.uy32)" "int64"))) (minus_u8_i8 0 (minus_u8_i8-1 nil 3867803492 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_u8_i8 subtype "(number_fields.-)(integertypes.ux8, integertypes.y8)" "int16"))) (minus_i8_u8 0 (minus_i8_u8-1 nil 3867803492 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_i8_u8 subtype "(number_fields.-)(integertypes.x8, integertypes.uy8)" "int16"))) (minus_u16_i16 0 (minus_u16_i16-1 nil 3867803493 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_u16_i16 subtype "(number_fields.-)(integertypes.ux16, integertypes.y16)" "int32"))) (minus_i16_u16 0 (minus_i16_u16-1 nil 3867803493 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_i16_u16 subtype "(number_fields.-)(integertypes.x16, integertypes.uy16)" "int32"))) (minus_u32_i32 0 (minus_u32_i32-1 nil 3867803494 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_u32_i32 subtype "(number_fields.-)(integertypes.ux32, integertypes.y32)" "int64"))) (minus_i32_u32 0 (minus_i32_u32-1 nil 3867803494 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (minus_i32_u32 subtype "(number_fields.-)(integertypes.x32, integertypes.uy32)" "int64"))) (u8minus_TCC1 0 (u8minus_TCC1-1 nil 3750736730 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (minus_u8_u8 application-judgement "int16" integertypes nil) (minus_i32_u32 application-judgement "int64" integertypes nil) (minus_i16_u16 application-judgement "int32" integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (u8minus subtype "(number_fields.-)(integertypes.ux8, integertypes.uy8)" "uint8"))) (u8minus_TCC2 0 (u8minus_TCC2-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max8 const-decl "uint8" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (u8minus subtype "(number_fields.+)((number_fields.+)((number_fields.-)(integertypes.max8, integertypes.uy8), integertypes.ux8), 1)" "uint8"))) (u16minus_TCC1 0 (u16minus_TCC1-1 nil 3750736730 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (minus_u16_u16 application-judgement "int32" integertypes nil) (minus_i32_u32 application-judgement "int64" integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16minus subtype "(number_fields.-)(integertypes.ux16, integertypes.uy16)" "uint16"))) (u16minus_TCC2 0 (u16minus_TCC2-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max16 const-decl "uint16" integertypes nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (u16minus subtype "(number_fields.+)((number_fields.+)((number_fields.-)(integertypes.max16, integertypes.uy16), integertypes.ux16), 1)" "uint16"))) (u32minus_TCC1 0 (u32minus_TCC1-1 nil 3750736730 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (minus_u32_u32 application-judgement "int64" integertypes nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32minus subtype "(number_fields.-)(integertypes.ux32, integertypes.uy32)" "uint32"))) (u32minus_TCC2 0 (u32minus_TCC2-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max32 const-decl "uint32" integertypes nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (u32minus subtype "(number_fields.+)((number_fields.+)((number_fields.-)(integertypes.max32, integertypes.uy32), integertypes.ux32), 1)" "uint32"))) (u64minus_TCC1 0 (u64minus_TCC1-1 nil 3750736730 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64minus subtype "(number_fields.-)(integertypes.ux64, integertypes.uy64)" "uint64"))) (u64minus_TCC2 0 (u64minus_TCC2-1 nil 3750736730 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max64 const-decl "uint64" integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (u64minus subtype "(number_fields.+)((number_fields.+)((number_fields.-)(integertypes.max64, integertypes.uy64), integertypes.ux64), 1)" "uint64"))) (u8pow2_TCC1 0 (u8pow2_TCC1-1 nil 3751239140 ("" (skeep) (("" (rewrite "exp2_lt") nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (exp2_lt formula-decl nil exp2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil)) nil (u8pow2 subtype "exp2.exp2(integertypes.n)" "uint8"))) (u16pow2_TCC1 0 (u16pow2_TCC1-1 nil 3751239140 ("" (skeep) (("" (lemma "exp2_lt") (("" (inst - 16 "n") (("" (ground) nil nil)) nil)) nil)) nil) ((exp2_lt formula-decl nil exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (u16pow2 subtype "exp2.exp2(integertypes.n)" "uint16"))) (u32pow2_TCC1 0 (u32pow2_TCC1-1 nil 3751239140 ("" (skeep) (("" (lemma "exp2_lt") (("" (inst - 32 "n") (("" (ground) nil nil)) nil)) nil)) nil) ((exp2_lt formula-decl nil exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (u32pow2 subtype "exp2.exp2(integertypes.n)" "uint32"))) (u64pow2_TCC1 0 (u64pow2_TCC1-1 nil 3751239140 ("" (skeep) (("" (lemma "exp2_lt") (("" (inst - 64 "n") (("" (ground) nil nil)) nil)) nil)) nil) ((exp2_lt formula-decl nil exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (u64pow2 subtype "exp2.exp2(integertypes.n)" "uint64"))) (u8lshift_TCC1 0 (u8lshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) nil nil (u8lshift subtype "(number_fields.-)(8, integertypes.n)" "nat"))) (u8lshift_TCC2 0 (u8lshift_TCC2-1 nil 3751239140 ("" (skeep) (("" (replace -1 :hide? t) (("" (typepred "nrem(ux8, exp2(8 - n))") (("" (skeep) (("" (lemma "both_sides_times_pos_lt1") (("" (inst - "exp2(n)" "nrem(ux8, exp2(8 - n))" "exp2(8 - n)") (("" (ground) (("" (lemma "exp2_sum") (("" (inst - "8 - n" "n") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (exp2_sum formula-decl nil exp2 nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (u8lshift subtype "number_fields.*(integertypes.x, exp2.exp2(integertypes.n))" "uint8"))) (u8lshift_bound_TCC1 0 (u8lshift_bound_TCC1-1 nil 3867803503 ("" (skeep :preds? t) (("" (case-replace "n = 0") (("1" (grind) nil nil) ("2" (lemma "exp2_lt") (("2" (inst -1 "8" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2 def-decl "posnat" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (exp2_lt formula-decl nil exp2 nil)) shostak (u8lshift_bound_ subtype "(number_fields.-)(exp2.exp2(8), exp2.exp2(integertypes.n))" "nat"))) (u8lshift_bound 0 (u8lshift_bound-1 nil 3844186167 ("" (grind) (("" (typepred "nrem(ux8!1, exp2(8 - n!1))") (("" (name-replace "n" "nrem(ux8!1, exp2(8 - n!1))") (("" (use "exp2_sum" ("n" "8  - n!1" "m" "n!1")) (("" (lemma "both_sides_times_pos_ge1" ("x" "exp2(8 - n!1)" "y" "n + 1" "pz" "exp2(n!1)")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2_sum formula-decl nil exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (u8lshift const-decl "uint8" integertypes nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u8lshift_bound subtype "integertypes.u8lshift(integertypes.ux8, integertypes.n)" "naturalnumbers.upto((number_fields.-)(exp2.exp2(8), exp2.exp2(integertypes.n)))"))) (u16lshift_TCC1 0 (u16lshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) nil nil (u16lshift subtype "(number_fields.-)(16, integertypes.n)" "nat"))) (u16lshift_TCC2 0 (u16lshift_TCC2-1 nil 3751239140 ("" (skeep) (("" (replace -1 :hide? t) (("" (typepred "nrem(ux16, exp2(16 - n))") (("" (skeep) (("" (lemma "both_sides_times_pos_lt1") (("" (inst - "exp2(n)" "nrem(ux16, exp2(16 - n))" "exp2(16 - n)") (("" (ground) (("" (lemma "exp2_sum") (("" (inst - "16 - n" "n") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (exp2_sum formula-decl nil exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (u16lshift subtype "number_fields.*(integertypes.x, exp2.exp2(integertypes.n))" "uint16"))) (u32lshift_TCC1 0 (u32lshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) nil nil (u32lshift subtype "(number_fields.-)(32, integertypes.n)" "nat"))) (u32lshift_TCC2 0 (u32lshift_TCC2-1 nil 3751239140 ("" (skeep) (("" (typepred "nrem(ux32, exp2(32 - n))") (("" (skeep) (("" (lemma "both_sides_times_pos_lt1") (("" (inst - "exp2(n)" "nrem(ux32, exp2(32 - n))" "exp2(32 - n)") (("" (lemma "exp2_sum") (("" (inst - "32 - n" "n") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (uint32 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (exp2_sum formula-decl nil exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (u32lshift subtype "number_fields.*(integertypes.x, exp2.exp2(integertypes.n))" "uint32"))) (u64lshift_TCC1 0 (u64lshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) nil nil (u64lshift subtype "(number_fields.-)(64, integertypes.n)" "nat"))) (u64lshift_TCC2 0 (u64lshift_TCC2-1 nil 3751239140 ("" (skeep) (("" (typepred "nrem(ux64, exp2(64 - n))") (("" (skeep) (("" (lemma "both_sides_times_pos_lt1") (("" (inst - "exp2(n)" "nrem(ux64, exp2(64 - n))" "exp2(64 - n)") (("" (lemma "exp2_sum") (("" (inst - "64 - n" "n") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (uint64 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (nrem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (exp2_sum formula-decl nil exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (u64lshift subtype "number_fields.*(integertypes.x, exp2.exp2(integertypes.n))" "uint64"))) (u8rshift_TCC1 0 (u8rshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "upto(n)" modulo_arithmetic nil)) nil (u8rshift subtype "modulo_arithmetic.ndiv(integertypes.ux8, exp2.exp2(integertypes.n))" "uint8"))) (u8rshift_bound_TCC1 0 (u8rshift_bound_TCC1-1 nil 3844224706 ("" (grind) nil nil) nil shostak (u8rshift_bound_ subtype "(number_fields.-)(8, integertypes.n)" "nat"))) (u8rshift_bound 0 (u8rshift_bound-1 nil 3844224714 ("" (grind :exclude "exp2") (("" (name-replace "nd" "ndiv(ux8!1,  exp2(n!1))") (("" (typepred "nd") (("" (lemma "both_sides_times_pos_ge1" ("x" "nd" "y" "exp2(8 - n!1)" "pz" "exp2(n!1)")) (("" (lemma "exp2_sum" ("n" "8 - n!1" "m" "n!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (u8rshift const-decl "uint8" integertypes nil)) shostak (u8rshift_bound subtype "integertypes.u8rshift(integertypes.ux8, integertypes.n)" "naturalnumbers.below(exp2.exp2((number_fields.-)(8, integertypes.n)))"))) (u16rshift_TCC1 0 (u16rshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16rshift subtype "modulo_arithmetic.ndiv(integertypes.ux16, exp2.exp2(integertypes.n))" "uint16"))) (u16rshift_bound 0 (u16rshift_bound-1 nil 3844274828 ("" (grind :exclude "exp2") (("" (name-replace "nd" "ndiv(ux16!1,  exp2(n!1))") (("" (typepred "nd") (("" (lemma "both_sides_times_pos_ge1" ("x" "nd" "y" "exp2(16 - n!1)" "pz" "exp2(n!1)")) (("" (lemma "exp2_sum" ("n" "16 - n!1" "m" "n!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (u16rshift const-decl "uint16" integertypes nil)) shostak (u16rshift_bound subtype "integertypes.u16rshift(integertypes.ux16, integertypes.n)" "naturalnumbers.below(exp2.exp2((number_fields.-)(16, integertypes.n)))"))) (u32rshift_TCC1 0 (u32rshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32rshift subtype "modulo_arithmetic.ndiv(integertypes.ux32, exp2.exp2(integertypes.n))" "uint32"))) (u32rshift_bound 0 (u32rshift_bound-1 nil 3844274872 ("" (grind :exclude "exp2") (("" (name-replace "nd" "ndiv(ux32!1,  exp2(n!1))") (("" (typepred "nd") (("" (lemma "both_sides_times_pos_ge1" ("x" "nd" "y" "exp2(32 - n!1)" "pz" "exp2(n!1)")) (("" (lemma "exp2_sum" ("n" "32 - n!1" "m" "n!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (u32rshift const-decl "uint32" integertypes nil)) shostak (u32rshift_bound subtype "integertypes.u32rshift(integertypes.ux32, integertypes.n)" "naturalnumbers.below(exp2.exp2((number_fields.-)(32, integertypes.n)))"))) (u64rshift_TCC1 0 (u64rshift_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64rshift subtype "modulo_arithmetic.ndiv(integertypes.ux64, exp2.exp2(integertypes.n))" "uint64"))) (u64rshift_bound 0 (u64rshift_bound-1 nil 3844274893 ("" (grind :exclude "exp2") (("" (name-replace "nd" "ndiv(ux64!1,  exp2(n!1))") (("" (typepred "nd") (("" (lemma "both_sides_times_pos_ge1" ("x" "nd" "y" "exp2(64 - n!1)" "pz" "exp2(n!1)")) (("" (lemma "exp2_sum" ("n" "64 - n!1" "m" "n!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}" modulo_arithmetic nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (u64rshift const-decl "uint64" integertypes nil)) shostak (u64rshift_bound subtype "integertypes.u64rshift(integertypes.ux64, integertypes.n)" "naturalnumbers.below(exp2.exp2((number_fields.-)(64, integertypes.n)))"))) (times_u8_u8 0 (times_u8_u8-1 nil 3867803514 ("" (skeep :preds? t) (("" (lemma "exp2_sum") (("" (inst -1 "8" "8") (("" (assert) (("" (replace -1 :hide? t) (("" (lemma "lt_times_lt_pos1") (("" (case-replace "ux8 = 0") (("1" (assert) nil nil) ("2" (inst -1 "uy8" "ux8" "exp2(8)" "exp2(8)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (times_u8_u8 subtype "number_fields.*(integertypes.ux8, integertypes.uy8)" "uint16"))) (times_u16_u16 0 (times_u16_u16-1 nil 3867803514 ("" (skeep :preds? t) (("" (lemma "exp2_sum") (("" (inst -1 "16" "16") (("" (assert) (("" (replace -1 :hide? t) (("" (lemma "lt_times_lt_pos1") (("" (case-replace "ux16 = 0") (("1" (assert) nil nil) ("2" (inst -1 "uy16" "ux16" "exp2(16)" "exp2(16)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_u16_u16 subtype "number_fields.*(integertypes.ux16, integertypes.uy16)" "uint32"))) (times_u32_u32 0 (times_u32_u32-1 nil 3867803515 ("" (skeep :preds? t) (("" (lemma "exp2_sum") (("" (inst -1 "32" "32") (("" (assert) (("" (replace -1 :hide? t) (("" (lemma "lt_times_lt_pos1") (("" (case-replace "ux32 = 0") (("1" (assert) nil nil) ("2" (inst -1 "uy32" "ux32" "exp2(32)" "exp2(32)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_u32_u32 subtype "number_fields.*(integertypes.ux32, integertypes.uy32)" "uint64"))) (times_u8_i8 0 (times_u8_i8-1 nil 3867803516 ("" (skeep :preds? t) (("" (split 1) (("1" (case "0 <= y8") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "ux8" "y8") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "ux8 * -y8 <= exp2(15)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "exp2_sum") (("2" (inst -1 "7" "8") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "le_times_le_pos") (("2" (inst -1 "ux8" "-y8" "exp2(7)" "exp2(8)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "exp2_sum") (("2" (inst -1 "7" "8") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (case "0 <= y8") (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "ux8" "y8" "exp2(7)" "exp2(8)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "neg_times_le") (("2" (inst -1 "ux8" "y8") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (exp2_sum formula-decl nil exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (le_times_le_pos formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (uint8 type-eq-decl nil integertypes nil) (< const-decl "bool" reals nil) (pos_times_le formula-decl nil real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (neg_times_le formula-decl nil real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (y8 skolem-const-decl "int8" integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_u8_i8 subtype "number_fields.*(integertypes.ux8, integertypes.y8)" "int16"))) (times_i8_u8 0 (times_i8_u8-1 nil 3867803516 ("" (skeep :preds? t) (("" (case "-x8 <= exp2(7)") (("1" (hide -3) (("1" (case "0 <= x8") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "x8" "uy8") (("1" (assert) (("1" (lemma "exp2_sum") (("1" (inst -1 "8" "7") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "x8" "uy8" "exp2(8)" "exp2(7)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "exp2_sum") (("2" (inst -1 "8" "7") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "lt_times_lt_pos2") (("2" (inst -1 "uy8" "-x8" "exp2(7)" "exp2(8)") (("2" (assert) (("2" (lemma "neg_times_le") (("2" (inst -1 "x8" "uy8") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int8 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pos_times_le formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2_sum formula-decl nil exp2 nil) (< const-decl "bool" reals nil) (uint8 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (neg_times_le formula-decl nil real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_i8_u8 subtype "number_fields.*(integertypes.x8, integertypes.uy8)" "int16"))) (times_u16_i16 0 (times_u16_i16-1 nil 3867803517 ("" (skeep :preds? t) (("" (case "-y16 <= exp2(15)") (("1" (hide -3) (("1" (lemma "exp2_sum") (("1" (inst -1 "15" "16") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (case "0 <= y16") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "ux16" "y16") (("1" (assert) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "y16" "ux16" "exp2(16)" "exp2(15)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "neg_times_le") (("2" (inst -1 "y16" "ux16") (("2" (assert) (("2" (lemma "le_times_le_pos") (("2" (inst -1 "-y16" "ux16" "exp2(16)" "exp2(15)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int16 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2_sum formula-decl nil exp2 nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (pos_times_le formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (uint16 type-eq-decl nil integertypes nil) (le_times_le_pos formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_u16_i16 subtype "number_fields.*(integertypes.ux16, integertypes.y16)" "int32"))) (times_i16_u16 0 (times_i16_u16-1 nil 3867803518 ("" (skeep :preds? t) (("" (lemma "exp2_sum") (("" (inst -1 "16" "15") (("" (assert) (("" (replace -1 :hide? t) (("" (case "0 <= x16") (("1" (assert) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "x16" "uy16" "exp2(16)" "exp2(15)") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "x16" "uy16") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "-x16 <= exp2(15)") (("1" (hide -3) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "uy16" "-x16" "exp2(15)" "exp2(16)") (("1" (assert) (("1" (lemma "neg_times_le") (("1" (inst -1 "x16" "uy16") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int16 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pos_times_le formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (uy16 skolem-const-decl "uint16" integertypes nil) (uint16 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (neg_times_le formula-decl nil real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_i16_u16 subtype "number_fields.*(integertypes.x16, integertypes.uy16)" "int32"))) (times_u32_i32 0 (times_u32_i32-1 nil 3867803518 ("" (skeep :preds? t) (("" (case "-y32 <= exp2(31)") (("1" (hide -3) (("1" (lemma "exp2_sum") (("1" (inst -1 "31" "32") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (case "0 <= y32") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "ux32" "y32") (("1" (assert) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "y32" "ux32" "exp2(32)" "exp2(31)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "neg_times_le") (("2" (inst -1 "y32" "ux32") (("2" (assert) (("2" (lemma "le_times_le_pos") (("2" (inst -1 "-y32" "ux32" "exp2(32)" "exp2(31)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int32 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp2_sum formula-decl nil exp2 nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (pos_times_le formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (uint32 type-eq-decl nil integertypes nil) (le_times_le_pos formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_u32_i32 subtype "number_fields.*(integertypes.ux32, integertypes.y32)" "int64"))) (times_i32_u32 0 (times_i32_u32-1 nil 3867803519 ("" (skeep :preds? t) (("" (lemma "exp2_sum") (("" (inst -1 "32" "31") (("" (assert) (("" (replace -1 :hide? t) (("" (case "0 <= x32") (("1" (assert) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "x32" "uy32" "exp2(32)" "exp2(31)") (("1" (assert) (("1" (lemma "pos_times_le") (("1" (inst -1 "x32" "uy32") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "-x32 <= exp2(31)") (("1" (hide -3) (("1" (lemma "lt_times_lt_pos2") (("1" (inst -1 "uy32" "-x32" "exp2(31)" "exp2(32)") (("1" (assert) (("1" (lemma "neg_times_le") (("1" (inst -1 "x32" "uy32") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp2_sum formula-decl nil exp2 nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int32 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pos_times_le formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (uy32 skolem-const-decl "uint32" integertypes nil) (uint32 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (neg_times_le formula-decl nil real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (times_i32_u32 subtype "number_fields.*(integertypes.x32, integertypes.uy32)" "int64"))) (u16times_TCC1 0 (u16times_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (times_u16_u16 application-judgement "uint32" integertypes nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16times subtype "modulo_arithmetic.nrem(integertypes.ux32, exp2.exp2(16))" "uint16"))) (u32times_TCC1 0 (u32times_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (uint64 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (times_u32_u32 application-judgement "uint64" integertypes nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32times subtype "modulo_arithmetic.nrem(integertypes.ux64, exp2.exp2(32))" "uint32"))) (u64times_TCC1 0 (u64times_TCC1-1 nil 3751239140 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64times subtype "modulo_arithmetic.nrem(number_fields.*(integertypes.ux64, integertypes.uy64), exp2.exp2(64))" "uint64"))) (div_u8_u8_TCC1 0 (div_u8_u8_TCC1-1 nil 3867803523 ("" (subtype-tcc) nil nil) nil shostak (div_u8_u8_ subtype "integertypes.nzu8" "posnat"))) (div_u8_u8 0 (div_u8_u8-1 nil 3867803524 ("" (judgement-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (div_u8_u8 subtype "modulo_arithmetic.ndiv(integertypes.ux8, integertypes.nzu8)" "uint8"))) (div_u16_u16_TCC1 0 (div_u16_u16_TCC1-1 nil 3867803525 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (div_u16_u16_ subtype "integertypes.nzu16" "posnat"))) (div_u16_u16 0 (div_u16_u16-1 nil 3867803525 ("" (judgement-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (div_u16_u16 subtype "modulo_arithmetic.ndiv(integertypes.ux16, integertypes.nzu16)" "uint16"))) (div_u32_u32_TCC1 0 (div_u32_u32_TCC1-1 nil 3867803526 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (div_u32_u32_ subtype "integertypes.nzu32" "posnat"))) (div_u32_u32 0 (div_u32_u32-1 nil 3867803527 ("" (judgement-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (div_u32_u32 subtype "modulo_arithmetic.ndiv(integertypes.ux32, integertypes.nzu32)" "uint32"))) (div_u64_u64_TCC1 0 (div_u64_u64_TCC1-1 nil 3867803528 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (div_u64_u64_ subtype "integertypes.nzu64" "posnat"))) (div_u64_u64 0 (div_u64_u64-1 nil 3867803529 ("" (judgement-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (div_u64_u64 subtype "modulo_arithmetic.ndiv(integertypes.ux64, integertypes.nzu64)" "uint64"))) (u8rem_TCC1 0 (u8rem_TCC1-1 nil 3757612809 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (u8rem subtype "modulo_arithmetic.nrem(integertypes.ux8, integertypes.uy8)" "uint8"))) (u16rem_TCC1 0 (u16rem_TCC1-1 nil 3757612809 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u16rem subtype "modulo_arithmetic.nrem(integertypes.ux16, integertypes.uy16)" "uint16"))) (u32rem_TCC1 0 (u32rem_TCC1-1 nil 3757612809 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u32rem subtype "modulo_arithmetic.nrem(integertypes.ux32, integertypes.uy32)" "uint32"))) (u64rem_TCC1 0 (u64rem_TCC1-1 nil 3757612809 ("" (subtype-tcc) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) nil (u64rem subtype "modulo_arithmetic.nrem(integertypes.ux64, integertypes.uy64)" "uint64"))) (u8max_TCC1 0 (u8max_TCC1-1 nil 3835419869 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u8max subtype "real_defs.max(integertypes.ux8, integertypes.uy8)" "uint8"))) (u16max_TCC1 0 (u16max_TCC1-1 nil 3835419869 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16max subtype "real_defs.max(integertypes.ux16, integertypes.uy16)" "uint16"))) (u32max_TCC1 0 (u32max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32max subtype "real_defs.max(integertypes.ux32, integertypes.uy32)" "uint32"))) (u64max_TCC1 0 (u64max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (exp2 def-decl "posnat" exp2 nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64max subtype "real_defs.max(integertypes.ux64, integertypes.uy64)" "uint64"))) (i8max_TCC1 0 (i8max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i8max subtype "real_defs.max(integertypes.x8, integertypes.y8)" "int8"))) (i16max_TCC1 0 (i16max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int16 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i16max subtype "real_defs.max(integertypes.x16, integertypes.y16)" "int16"))) (i32max_TCC1 0 (i32max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int32 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i32max subtype "real_defs.max(integertypes.x32, integertypes.y32)" "int32"))) (i64max_TCC1 0 (i64max_TCC1-1 nil 3835419870 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int64 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i64max subtype "real_defs.max(integertypes.x64, integertypes.y64)" "int64"))) (u8min_TCC1 0 (u8min_TCC1-1 nil 3867803541 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (u8min subtype "real_defs.min(integertypes.ux8, integertypes.uy8)" "uint8"))) (u16min_TCC1 0 (u16min_TCC1-1 nil 3867803541 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint16 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16min subtype "real_defs.min(integertypes.ux16, integertypes.uy16)" "uint16"))) (u32min_TCC1 0 (u32min_TCC1-1 nil 3867803542 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint32 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32min subtype "real_defs.min(integertypes.ux32, integertypes.uy32)" "uint32"))) (u64min_TCC1 0 (u64min_TCC1-1 nil 3867803543 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint64 type-eq-decl nil integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64min subtype "real_defs.min(integertypes.ux64, integertypes.uy64)" "uint64"))) (i8min_TCC1 0 (i8min_TCC1-1 nil 3867803544 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i8min subtype "real_defs.min(integertypes.x8, integertypes.y8)" "int8"))) (i16min_TCC1 0 (i16min_TCC1-1 nil 3867803545 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int16 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i16min subtype "real_defs.min(integertypes.x16, integertypes.y16)" "int16"))) (i32min_TCC1 0 (i32min_TCC1-1 nil 3867803546 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int32 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i32min subtype "real_defs.min(integertypes.x32, integertypes.y32)" "int32"))) (i64min_TCC1 0 (i64min_TCC1-1 nil 3867803547 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int64 type-eq-decl nil integertypes nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nil application-judgement "above(n)" exp2 nil)) shostak (i64min subtype "real_defs.min(integertypes.x64, integertypes.y64)" "int64"))) (u8ceiling_TCC1 0 (u8ceiling_TCC1-1 nil 3844275086 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (max8 const-decl "uint8" integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u8ceiling subtype "floor_ceil.ceiling(integertypes.x)" "uint8"))) (u16ceiling_TCC1 0 (u16ceiling_TCC1-1 nil 3844275092 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (max16 const-decl "uint16" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u16ceiling subtype "floor_ceil.ceiling(integertypes.x)" "uint16"))) (u32ceiling_TCC1 0 (u32ceiling_TCC1-1 nil 3844275097 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (max32 const-decl "uint32" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u32ceiling subtype "floor_ceil.ceiling(integertypes.x)" "uint32"))) (u64ceiling_TCC1 0 (u64ceiling_TCC1-1 nil 3844275103 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (max64 const-decl "uint64" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u64ceiling subtype "floor_ceil.ceiling(integertypes.x)" "uint64"))) (u8floor_TCC1 0 (u8floor_TCC1-1 nil 3844275108 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint8 type-eq-decl nil integertypes nil) (max8 const-decl "uint8" integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u8floor subtype "floor_ceil.floor(integertypes.x)" "uint8"))) (u16floor_TCC1 0 (u16floor_TCC1-1 nil 3844275112 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint16 type-eq-decl nil integertypes nil) (max16 const-decl "uint16" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u16floor subtype "floor_ceil.floor(integertypes.x)" "uint16"))) (u32floor_TCC1 0 (u32floor_TCC1-1 nil 3844275117 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint32 type-eq-decl nil integertypes nil) (max32 const-decl "uint32" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u32floor subtype "floor_ceil.floor(integertypes.x)" "uint32"))) (u64floor_TCC1 0 (u64floor_TCC1-1 nil 3844275122 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (uint64 type-eq-decl nil integertypes nil) (max64 const-decl "uint64" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2 def-decl "posnat" exp2 nil)) shostak (u64floor subtype "floor_ceil.floor(integertypes.x)" "uint64"))) (i8ceiling_TCC1 0 (i8ceiling_TCC1-1 nil 3844275165 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (mini8 const-decl "int8" integertypes nil) (maxi8 const-decl "int8" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i8ceiling subtype "floor_ceil.ceiling(integertypes.x)" "int8"))) (i16ceiling_TCC1 0 (i16ceiling_TCC1-1 nil 3844275172 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int16 type-eq-decl nil integertypes nil) (mini16 const-decl "int16" integertypes nil) (maxi16 const-decl "int16" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i16ceiling subtype "floor_ceil.ceiling(integertypes.x)" "int16"))) (i32ceiling_TCC1 0 (i32ceiling_TCC1-1 nil 3844275177 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int32 type-eq-decl nil integertypes nil) (mini32 const-decl "int32" integertypes nil) (maxi32 const-decl "int32" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i32ceiling subtype "floor_ceil.ceiling(integertypes.x)" "int32"))) (i64ceiling_TCC1 0 (i64ceiling_TCC1-1 nil 3844275182 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int64 type-eq-decl nil integertypes nil) (mini64 const-decl "int64" integertypes nil) (maxi64 const-decl "int64" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i64ceiling subtype "floor_ceil.ceiling(integertypes.x)" "int64"))) (i8floor_TCC1 0 (i8floor_TCC1-1 nil 3844275205 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int8 type-eq-decl nil integertypes nil) (mini8 const-decl "int8" integertypes nil) (maxi8 const-decl "int8" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i8floor subtype "floor_ceil.floor(integertypes.x)" "int8"))) (i16floor_TCC1 0 (i16floor_TCC1-1 nil 3844275209 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int16 type-eq-decl nil integertypes nil) (mini16 const-decl "int16" integertypes nil) (maxi16 const-decl "int16" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i16floor subtype "floor_ceil.floor(integertypes.x)" "int16"))) (i32floor_TCC1 0 (i32floor_TCC1-1 nil 3844275215 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int32 type-eq-decl nil integertypes nil) (mini32 const-decl "int32" integertypes nil) (maxi32 const-decl "int32" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i32floor subtype "floor_ceil.floor(integertypes.x)" "int32"))) (i64floor_TCC1 0 (i64floor_TCC1-1 nil 3844275221 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int64 type-eq-decl nil integertypes nil) (mini64 const-decl "int64" integertypes nil) (maxi64 const-decl "int64" integertypes nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (i64floor subtype "floor_ceil.floor(integertypes.x)" "int64"))))(nat_fun_props (injection_n_to_m 0 (injection_n_to_m-2 "" 3505098781 ("" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (typepred "f!1(0)") (("2" (assert) (("2" (hide -1) (("2" (inst -1 "m!1 - 1") (("2" (assert) (("2" (delete 2) (("2" (inst 1 "LAMBDA (x : below[j!1]) : IF f!1(x) = m!1 - 1 THEN f!1(j!1) ELSE f!1(x) ENDIF") (("1" (expand "injective?") (("1" (skosimp) (("1" (lift-if) (("1" (lift-if) (("1" (inst-cp -2 "x1!1" "j!1") (("1" (inst-cp -2 "x2!1" "j!1") (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (expand "injective?") (("3" (inst -2 "x!1" "j!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (f!1 skolem-const-decl "[below(1 + j!1) -> below(m!1)]" nat_fun_props nil) (m!1 skolem-const-decl "nat" nat_fun_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (j!1 skolem-const-decl "nat" nat_fun_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (injection_n_to_m-1 nil 3242964223 ("" (induct "n") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (typepred "f!1(0)") (("2" (assert) (("2" (hide -1) (("2" (inst -1 "m!1 - 1") (("2" (assert) (("2" (delete 2) (("2" (inst 1 "LAMBDA (x : below[j!1]) : IF f!1(x) = m!1 - 1 THEN f!1(j!1) ELSE f!1(x) ENDIF") (("1" (expand "injective?") (("1" (skosimp) (("1" (lift-if) (("1" (lift-if) (("1" (inst-cp -2 "x1!1" "j!1") (("1" (inst-cp -2 "x2!1" "j!1") (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (expand "injective?") (("3" (inst -2 "x!1" "j!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (injection_n_to_m_var 0 (injection_n_to_m_var-1 nil 3243223197 ("" (skolem!) (("" (ground) (("1" (rewrite "injection_n_to_m") nil nil) ("2" (inst + "lambda (i: below(n!1)): i") (("2" (grind) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (injection_n_to_m formula-decl nil nat_fun_props nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil)) shostak)) (surjection_n_to_m 0 (surjection_n_to_m-1 nil 3242964294 ("" (skosimp*) (("" (rewrite "injection_n_to_m") (("" (expand "surjective?") (("" (inst -1 "0") (("" (skosimp) (("" (assert) (("" (inst 1 "inverse(f!1)") (("1" (rewrite "inj_inv") (("1" (inst 1 "x!1") nil nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((injection_n_to_m formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (inj_inv formula-decl nil function_inverse nil) (inverse const-decl "D" function_inverse nil) (TRUE const-decl "bool" booleans nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (surjective? const-decl "bool" functions nil)) shostak)) (surjection_n_to_m_var 0 (surjection_n_to_m_var-1 nil 3243223295 ("" (skolem!) (("" (apply (then (split) (flatten))) (("1" (forward-chain "surjection_n_to_m") (("1" (assert) (("1" (skosimp) (("1" (typepred "f!1(0)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst + "lambda (i: below(n!1)): IF i < m!1 THEN i ELSE 0 ENDIF") (("1" (grind) nil nil) ("2" (reduce) nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (surjection_n_to_m formula-decl nil nat_fun_props nil) (surjective? const-decl "bool" functions nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (m!1 skolem-const-decl "nat" nat_fun_props nil)) shostak)) (bijection_n_to_m 0 (bijection_n_to_m-1 nil 3242964328 ("" (skolem!) (("" (prop) (("1" (expand "bijective?") (("1" (skosimp) (("1" (lemma "injection_n_to_m" ("n" "n!1" "m" "m!1")) (("1" (lemma "surjection_n_to_m" ("n" "n!1" "m" "m!1")) (("1" (split) (("1" (assert) (("1" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x : below[n!1]) : x") (("1" (grind) nil nil) ("2" (skolem!) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((surjection_n_to_m formula-decl nil nat_fun_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (injection_n_to_m formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (below type-eq-decl nil nat_types nil) (m!1 skolem-const-decl "nat" nat_fun_props nil)) shostak)) (injection_n_to_m2 0 (injection_n_to_m2-1 nil 3243223324 ("" (skolem!) (("" (ground) (("1" (lemma "injection_n_to_m" ("n" "n!1+1" "m" "m!1+1")) (("1" (assert) (("1" (skolem!) (("1" (inst + "lambda (i : below(1 + n!1)) : f!1(i)") (("1" (grind :if-match nil) (("1" (inst? :where +) (("1" (assert) nil nil)) nil)) nil) ("2" (skolem!) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "lambda (i : upto(n!1)): i") (("2" (grind) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (f!1 skolem-const-decl "[upto(n!1) -> upto(m!1)]" nat_fun_props nil) (m!1 skolem-const-decl "nat" nat_fun_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (< const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (injection_n_to_m formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (surjection_n_to_m2 0 (surjection_n_to_m2-1 nil 3243223349 ("" (skolem!) (("" (ground) (("1" (lemma "surjection_n_to_m" ("n" "n!1+1" "m" "m!1+1")) (("1" (assert) (("1" (skolem!) (("1" (inst + "lambda (i: below(1 + n!1)): f!1(i)") (("1" (grind :if-match nil) (("1" (inst? -) (("1" (skolem!) (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "lambda (i : upto(n!1)): IF i <= m!1 THEN i ELSE 0 ENDIF") (("2" (grind) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (f!1 skolem-const-decl "[upto(n!1) -> upto(m!1)]" nat_fun_props nil) (m!1 skolem-const-decl "nat" nat_fun_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (< const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (surjection_n_to_m formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil)) shostak)) (bijection_n_to_m2 0 (bijection_n_to_m2-1 nil 3243223474 ("" (skolem!) (("" (ground) (("1" (expand "bijective?") (("1" (skosimp) (("1" (lemma "injection_n_to_m2" ("n" "n!1" "m" "m!1")) (("1" (lemma "surjection_n_to_m2" ("n" "n!1" "m" "m!1")) (("1" (ground) (("1" (inst?) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "lambda (i : upto(n!1)): i") (("2" (grind) nil nil)) nil)) nil)) nil) ((surjection_n_to_m2 formula-decl nil nat_fun_props nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injection_n_to_m2 formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (surj_equiv_inj 0 (surj_equiv_inj-1 nil 3243223495 ("" (skolem!) (("" (case "n!1 = 0") (("1" (grind) nil nil) ("2" (ground) (("1" (use "surjection_n_to_m" ("n" "n!1 - 1" "m" "n!1")) (("1" (assert) (("1" (expand* "surjective?" "injective?") (("1" (skosimp) (("1" (inst + "lambda (i : below(n!1 - 1)): IF i < x1!1 THEN f!1(i) ELSE f!1(i+1) ENDIF") (("1" (assert) (("1" (skolem!) (("1" (inst - "y!1") (("1" (skolem!) (("1" (case "x!1 = x1!1") (("1" (inst + "IF x2!1 < x!1 THEN x2!1 ELSE x2!1-1 ENDIF") (("1" (smash) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil) ("2" (inst + "IF x!1 < x1!1 THEN x!1 ELSE x!1 - 1 ENDIF") (("1" (smash) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "injection_n_to_m" ("n" "n!1" "m" "n!1-1")) (("2" (assert) (("2" (expand* "injective?" "surjective?") (("2" (skolem!) (("2" (inst + "lambda (i : below(n!1)) : IF f!1(i) = n!1 - 1 THEN y!1 ELSE f!1(i) ENDIF") (("1" (assert) (("1" (skosimp) (("1" (inst? - :where +) (("1" (smash) (("1" (inst + "x2!1") (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (inst? +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injection_n_to_m formula-decl nil nat_fun_props nil) (y!1 skolem-const-decl "below(n!1)" nat_fun_props nil) (f!1 skolem-const-decl "[below(n!1) -> below(n!1)]" nat_fun_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (surjection_n_to_m formula-decl nil nat_fun_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (x1!1 skolem-const-decl "below(n!1)" nat_fun_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (n!1 skolem-const-decl "nat" nat_fun_props nil) (x2!1 skolem-const-decl "below(n!1)" nat_fun_props nil) (x!1 skolem-const-decl "below(n!1)" nat_fun_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (inj_equiv_bij 0 (inj_equiv_bij-1 nil 3243223527 ("" (skolem!) (("" (expand "bijective?") (("" (ground) (("" (rewrite "surj_equiv_inj") nil nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surj_equiv_inj formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (surj_equiv_bij 0 (surj_equiv_bij-1 nil 3243223548 ("" (skolem!) (("" (expand "bijective?") (("" (ground) (("" (rewrite "surj_equiv_inj") nil nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surj_equiv_inj formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (surj_equiv_inj2 0 (surj_equiv_inj2-1 nil 3243223572 ("" (skolem!) (("" (lemma "surj_equiv_inj" ("n" "n!1+1" "f" "lambda (i : below(n!1 + 1)): f!1(i)")) (("1" (expand* "surjective?" "injective?") (("1" (reduce :if-match nil) (("1" (inst? -4 :where +) (("1" (assert) nil nil)) nil) ("2" (inst? -2) (("2" (skolem!) (("2" (inst? +) nil nil)) nil)) nil) ("3" (inst - "y!1") (("3" (skolem!) (("3" (inst + "x!1") nil nil)) nil)) nil) ("4" (inst? - :where +) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (assert) nil nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (surj_equiv_inj formula-decl nil nat_fun_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil)) shostak)) (inj_equiv_bij2 0 (inj_equiv_bij2-1 nil 3243223596 ("" (skolem!) (("" (expand "bijective?") (("" (ground) (("" (rewrite "surj_equiv_inj2") nil nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surj_equiv_inj2 formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (surj_equiv_bij2 0 (surj_equiv_bij2-1 nil 3243223623 ("" (skolem!) (("" (expand "bijective?") (("" (ground) (("" (rewrite "surj_equiv_inj2") nil nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surj_equiv_inj2 formula-decl nil nat_fun_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) shostak)))(finite_sets (finite_set_TCC1 0 (finite_set_TCC1-1 nil 3243832506 ("" (expand "is_finite") (("" (inst 1 "0" "LAMBDA (s: (emptyset[T])): 0") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (FALSE const-decl "bool" booleans nil) (emptyset const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil)) shostak (finite_set subtype "sets[finite_sets.T].emptyset" "finite_set"))) (is_finite_surj 0 (is_finite_surj-1 nil 3243836561 ("" (skosimp*) (("" (prop) (("1" (skosimp) (("1" (grind :if-match nil) (("1" (inst 1 "N!1" "lambda (x: (s!1)): epsilon! (n: below[N!1]): x = f!1(n)") (("1" (skosimp) (("1" (use "epsilon_ax[below[N!1]]" :if-match all) (("1" (prop) (("1" (grind) nil nil) ("2" (inst -2 "x1!1") (("2" (skosimp) (("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst -2 "x2!1") (("3" (skosimp) (("3" (inst 1 "x!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (inst -1 "x1!1") (("4" (skosimp) (("4" (inst 1 "x!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x1!1") (("2" (skosimp) (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil) ("2" (case "empty?(s!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "empty?(s!1)") (("1" (expand "empty?") (("1" (inst 1 "0" "lambda (n: below[0]): epsilon! (x: (s!1)): true") (("1" (hide -2) (("1" (grind :if-match nil) (("1" (inst -2 "y!1") nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (expand "is_finite") (("2" (skosimp) (("2" (grind :if-match nil) (("2" (inst 1 "N!1" "lambda (n : below[N!1]): epsilon!(x : (s!1)) : n = f!1(x)") (("1" (skolem-typepred) (("1" (inst 1 "f!1(y!1)") (("1" (use "epsilon_ax[(s!1)]") (("1" (prop) (("1" (inst -4 "y!1" "epsilon(LAMBDA (x: (s!1)): f!1(y!1) = f!1(x))") (("1" (assert) nil nil) ("2" (inst 1 "y!1") nil nil)) nil) ("2" (inst 1 "y!1") nil nil)) nil) ("2" (inst 1 "y!1") nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (epsilon_ax formula-decl nil epsilons nil) (= const-decl "[T, T -> boolean]" equalities nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (s!1 skolem-const-decl "set[T]" finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N!1 skolem-const-decl "nat" finite_sets nil) (below type-eq-decl nil nat_types nil) (TRUE const-decl "bool" booleans nil) (N!1 skolem-const-decl "nat" finite_sets nil) (FALSE const-decl "bool" booleans nil)) nil)) (finite_subset 0 (finite_subset-3 "" 3658945030 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: (s!1)): f!1(x)") (("1" (skosimp) (("1" (inst? -2) (("1" (assert) nil nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst? -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((s!1 skolem-const-decl "set[T]" finite_sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak) (finite_subset-2 "" 3590856476 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: (s!1)): f!1(x)") (("1" (skosimp) (("1" (inst? -3) (("1" (assert) nil nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst? -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak) (finite_subset-1 nil 3243836755 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: (s!1)): f!1(x)") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "x2!1") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "x1!1") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst? -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak)) (finite_intersection 0 (finite_intersection-1 nil 3243836807 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: (intersection(A!1, B!1))): f!1(x)") (("1" (skolem-typepred) (("1" (inst?) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((intersection const-decl "set" sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (B!1 skolem-const-decl "finite_set" finite_sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak)) (finite_add 0 (finite_add-3 "" 3658945447 ("" (grind :if-match nil) (("" (inst 1 "N!1 + 1" "lambda (x: (add(x!1, A!1))): if x = x!1 then N!1 else f!1(x) endif") (("1" (grind :if-match nil) (("1" (inst -4 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (grind :if-match nil) nil nil) ("3" (grind :if-match nil) nil nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (f!1 skolem-const-decl "[(A!1) -> below[N!1]]" finite_sets nil) (below type-eq-decl nil nat_types nil) (N!1 skolem-const-decl "nat" finite_sets nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak) (finite_add-2 "" 3590856602 ("" (grind :if-match nil) (("" (inst 1 "N!1 + 1" "lambda (x: (add(x!1, A!1))): if x = x!1 then N!1 else f!1(x) endif") (("1" (grind :if-match nil) (("1" (inst -5 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (grind :if-match nil) nil nil) ("3" (grind :if-match nil) nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak) (finite_add-1 nil 3243836836 ("" (grind :if-match nil) (("" (inst 1 "N!1 + 1" "lambda (x: (add(x!1, A!1))): if x = x!1 then N!1 else f!1(x) endif") (("1" (grind :if-match nil) (("1" (inst -4 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (grind :if-match nil) nil nil) ("3" (grind :if-match nil) nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak)) (nonempty_finite_is_nonempty 0 (nonempty_finite_is_nonempty-1 nil 3243832507 ("" (grind) nil nil) ((nonempty? const-decl "bool" sets nil)) shostak (nonempty_finite_is_nonempty subtype "finite_sets.x" "(sets[finite_sets.T].nonempty?)"))) (finite_singleton 0 (finite_singleton-1 nil 3243832507 ("" (skosimp) (("" (expand "is_finite") (("" (inst 1 "1" "LAMBDA (x: (singleton[T](x!1))): 0") (("" (grind) nil nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (finite_singleton subtype "sets[finite_sets.T].singleton(finite_sets.x)" "finite_set"))) (finite_union 0 (finite_union-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (skosimp) (("" (inst 1 "N!1 + N!2" "LAMBDA (x : (union(A!1, B!1))) : IF A!1(x) THEN f!1(x) ELSE N!1 + f!2(x) ENDIF") (("1" (grind) nil nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (delete -) (("3" (grind) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (x1!1 skolem-const-decl "(union[T](A!1, B!1))" finite_sets nil) (x2!1 skolem-const-decl "(union[T](A!1, B!1))" finite_sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (f!2 skolem-const-decl "[(B!1) -> below[N!2]]" finite_sets nil) (union const-decl "set" sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (B!1 skolem-const-decl "finite_set" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N!1 skolem-const-decl "nat" finite_sets nil) (below type-eq-decl nil nat_types nil) (f!1 skolem-const-decl "[(A!1) -> below[N!1]]" finite_sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (N!2 skolem-const-decl "nat" finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_union subtype "sets[finite_sets.T].union(finite_sets.A, finite_sets.B)" "finite_set"))) (finite_intersection1 0 (finite_intersection1-3 nil 3243834683 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x: (intersection[T](s!1, A!1))): f!1(x)") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (expand "intersection") (("1" (expand "member") (("1" (flatten) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "intersection") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((A!1 skolem-const-decl "finite_set" finite_sets nil) (s!1 skolem-const-decl "set[T]" finite_sets nil) (intersection const-decl "set" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (finite_intersection1 subtype "sets[finite_sets.T].intersection(finite_sets.s, finite_sets.A)" "finite_set")) (finite_intersection1-2 nil 3243834664 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x: (intersection[T](S!1, A!1))): f!1(x)") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (expand "intersection") (("1" (expand "member") (("1" (flatten) (("1" (inst?) (("1" (assert) nil))))))))))))) ("2" (skolem-typepred) (("2" (expand "intersection") (("2" (expand "member") (("2" (assert) nil)))))))))))))) nil) nil nil (finite_intersection1 subtype "sets[finite_sets.T].intersection(finite_sets.s, finite_sets.A)" "finite_set")) (finite_intersection1-1 nil 3243832507 ("" (postpone) nil nil) nil shostak (finite_intersection1 subtype "sets[finite_sets.T].intersection(finite_sets.s, finite_sets.A)" "finite_set"))) (finite_intersection2 0 (finite_intersection2-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x: (intersection[T](A!1, s!1))): f!1(x)") (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "x2!1") (("2" (expand "intersection") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "x1!1") (("3" (expand "intersection") (("3" (expand "member") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "intersection") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((s!1 skolem-const-decl "set[T]" finite_sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_intersection2 subtype "sets[finite_sets.T].intersection(finite_sets.A, finite_sets.s)" "finite_set"))) (finite_difference 0 (finite_difference-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x :(difference[T](A!1, s!1))): f!1(x)") (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "x2!1") (("2" (expand "difference") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "x1!1") (("3" (expand "difference") (("3" (expand "member") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "difference") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((s!1 skolem-const-decl "set[T]" finite_sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (difference const-decl "set" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_difference subtype "sets[finite_sets.T].difference(finite_sets.A, finite_sets.s)" "finite_set"))) (nonempty_finite_union1 0 (nonempty_finite_union1-1 nil 3243832507 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (B!1 skolem-const-decl "finite_set" finite_sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (finite_union application-judgement "finite_set" finite_sets nil)) shostak (nonempty_finite_union1 subtype "sets[finite_sets.T].union(finite_sets.NA, finite_sets.B)" "non_empty_finite_set"))) (nonempty_finite_union2 0 (nonempty_finite_union2-1 nil 3243832507 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (finite_union application-judgement "finite_set" finite_sets nil)) shostak (nonempty_finite_union2 subtype "sets[finite_sets.T].union(finite_sets.A, finite_sets.NB)" "non_empty_finite_set"))) (nonempty_add_finite 0 (nonempty_add_finite-2 "" 3505098916 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (split) (("1" (inst 1 "N!1+1" "lambda (x: (add[T](x!1, A!1))): if x = x!1 then N!1 else f!1(x) endif") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lift-if) (("3" (assert) (("3" (prop) (("3" (assert) (("3" (inst -4 "x1!1" "x2!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (assert) (("3" (expand "add") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty?") (("2" (inst -1 "x!1") (("2" (expand "member") (("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N!1 skolem-const-decl "nat" finite_sets nil) (below type-eq-decl nil nat_types nil) (f!1 skolem-const-decl "[(A!1) -> below[N!1]]" finite_sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (A!1 skolem-const-decl "finite_set" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (empty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (nonempty_add_finite subtype "sets[finite_sets.T].add(finite_sets.x, finite_sets.A)" "non_empty_finite_set")) (nonempty_add_finite-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (split) (("1" (inst 1 "N!1+1" "lambda (x: (add[T](x!1, A!1))): if x = x!1 then N!1 else f!1(x) endif") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (inst -4 "x1!1" "x2!1") (("1" (assert) nil nil) ("2" (expand "add") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "add") (("3" (expand "member") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (assert) (("3" (expand "add") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty?") (("2" (inst -1 "x!1") (("2" (expand "member") (("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (empty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (nonempty_add_finite subtype "sets[finite_sets.T].add(finite_sets.x, finite_sets.A)" "non_empty_finite_set"))) (finite_remove 0 (finite_remove-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x: (remove[T](x!1, A!1))): f!1(x)") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (inst?) (("1" (expand "remove") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "remove") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "remove") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((A!1 skolem-const-decl "finite_set" finite_sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (remove const-decl "set" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_remove subtype "sets[finite_sets.T].remove(finite_sets.x, finite_sets.A)" "finite_set"))) (finite_rest 0 (finite_rest-1 nil 3243832507 ("" (skolem-typepred) (("" (expand "is_finite") (("" (skosimp) (("" (inst 1 "N!1" "lambda (x: (rest[T](A!1))): f!1(x)") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (inst?) (("1" (expand "rest") (("1" (assert) (("1" (hide -1) (("1" (prop) (("1" (expand "empty?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "remove") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (assert) (("2" (hide -2) (("2" (prop) (("2" (expand "remove") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "rest") (("2" (assert) (("2" (prop) (("2" (expand "remove") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((A!1 skolem-const-decl "finite_set" finite_sets nil) (rest const-decl "set" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_rest subtype "sets[finite_sets.T].rest(finite_sets.A)" "finite_set"))) (finite_emptyset 0 (finite_emptyset-1 nil 3243832507 ("" (expand "is_finite") (("" (inst 1 "0" "LAMBDA (x:(emptyset[T])): 0") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "emptyset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (FALSE const-decl "bool" booleans nil) (emptyset const-decl "set" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil)) shostak (finite_emptyset subtype "sets[finite_sets.T].emptyset" "finite_set"))) (nonempty_singleton_finite 0 (nonempty_singleton_finite-1 nil 3243832507 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (finite_singleton application-judgement "finite_set" finite_sets nil)) shostak (nonempty_singleton_finite subtype "sets[finite_sets.T].singleton(finite_sets.x)" "non_empty_finite_set"))) (finite_full 0 (finite_full-1 nil 3243836878 ("" (grind :if-match nil) (("1" (inst 1 "N!1" "g!1") (("1" (grind) nil nil)) nil) ("2" (inst 1 "N!1" "f!1") (("2" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (restrict const-decl "R" restrict nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (is_finite_type const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak)) (finite_type_set 0 (finite_type_set-1 nil 3243836911 ("" (grind :if-match nil) (("" (inst 1 "N!1" "g!1") (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (restrict const-decl "R" restrict nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (is_finite_type const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak)) (finite_complement 0 (finite_complement-3 "" 3658945515 ("" (grind :if-match nil) (("" (inst 1 "N!1" "g!1") (("" (grind :if-match nil) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (complement const-decl "set" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (is_finite_type const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak) (finite_complement-2 "" 3590856663 ("" (grind :if-match nil) (("" (inst 1 "N!1" "g!1") (("" (grind :if-match nil) (("" (inst? -3) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (complement const-decl "set" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (is_finite_type const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak) (finite_complement-1 nil 3243836931 ("" (grind :if-match nil) (("" (inst 1 "N!1" "g!1") (("" (grind :if-match nil) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (complement const-decl "set" sets nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil finite_sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (is_finite const-decl "bool" finite_sets nil) (is_finite_type const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak)) (inj_set_TCC1 0 (inj_set_TCC1-1 nil 3243832508 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) shostak (inj_set subtype "{n | EXISTS (f: [(finite_sets.S) -> nat_types[finite_sets.n].below]): functions[(finite_sets.S), below[n]].injective?(f)}" "(sets[nat].nonempty?)"))) (inj_Card 0 (inj_Card-1 nil 3243836968 ("" (skosimp) (("" (expand "Card") (("" (rewrite "min_def") (("" (expand "minimum?") (("" (flatten) (("" (expand "inj_set") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Card const-decl "nat" finite_sets nil) (minimum? const-decl "bool" min_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (inj_set const-decl "(nonempty?[nat])" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (T formal-type-decl nil finite_sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (min_def formula-decl nil min_nat nil)) shostak)) (reduce_inj_TCC1 0 (reduce_inj_TCC1-1 nil 3243832508 ("" (subtype-tcc) nil nil) ((injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil)) shostak (reduce_inj subtype "(number_fields.-)(finite_sets.p, 1)" "nat"))) (reduce_inj 0 (reduce_inj-2 "" 3505099065 ("" (skosimp) (("" (grind :if-match nil) (("" (inst 2 "LAMBDA (x : (S!1)) : IF f!1(x) = p!1 - 1 THEN y!1 ELSE f!1(x) ENDIF") (("1" (skosimp) (("1" (inst -2 "x1!1" "x2!1") (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst 2 "x2!1") (("1" (assert) nil nil)) nil) ("2" (inst 3 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (inst 2 "x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (S!1 skolem-const-decl "finite_set" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (p!1 skolem-const-decl "posnat" finite_sets nil) (f!1 skolem-const-decl "[(S!1) -> below[p!1]]" finite_sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (y!1 skolem-const-decl "below[p!1]" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (reduce_inj-1 nil 3243836998 ("" (skosimp) (("" (grind :if-match nil) (("" (inst 2 "LAMBDA (x : (S!1)) : IF f!1(x) = p!1 - 1 THEN y!1 ELSE f!1(x) ENDIF") (("1" (skosimp) (("1" (inst -2 "x1!1" "x2!1") (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst?) nil nil) ("2" (inst 3 "x2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (inst 2 "x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (Card_injection 0 (Card_injection-1 nil 3243837042 ("" (skosimp*) (("" (expand "Card") (("" (typepred "min(inj_set(S!1))") (("" (inst?) (("" (assert) (("" (expand "inj_set") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Card const-decl "nat" finite_sets nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonempty? const-decl "bool" sets nil) (inj_set const-decl "(nonempty?[nat])" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil)) shostak)) (Card_surjection 0 (Card_surjection-1 nil 3243837068 ("" (skosimp*) (("" (name "CS" "Card(S!1)") (("" (replace -1) (("" (forward-chain "inj_Card") (("" (skolem!) (("" (rewrite "injection_n_to_m") (("" (copy -3) (("" (expand "surjective?" -1) (("" (inst -1 "0") (("" (skosimp*) (("" (inst 1 "f!2 o inverse(f!1)") (("1" (hide -3 2) (("1" (forward-chain "inj_inv[(S!1),below[n!1]]") (("1" (hide -4) (("1" (grind :if-match nil :exclude inverse) (("1" (inst -6 "epsilon! (x: (S!1)): f!1(x) = x1!1" "epsilon! (x: (S!1)): f!1(x) = x2!1") (("1" (inst -3 "x1!1" "x2!1") (("1" (assert) (("1" (expand "inverse") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Card const-decl "nat" finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (inj_Card formula-decl nil finite_sets nil) (injection_n_to_m formula-decl nil nat_fun_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (inj_inv formula-decl nil function_inverse nil) (below type-eq-decl nil naturalnumbers nil) (O const-decl "T3" function_props nil) (inverse const-decl "D" function_inverse nil) (TRUE const-decl "bool" booleans nil) (S!1 skolem-const-decl "finite_set" finite_sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (Card_bijection 0 (Card_bijection-1 nil 3243837106 ("" (skolem!) (("" (prop) (("1" (forward-chain "inj_Card") (("1" (skolem!) (("1" (inst?) (("1" (expand "bijective?") (("1" (assert) (("1" (case "n!1 = 0") (("1" (delete -2 -3) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (forward-chain "reduce_inj") (("2" (forward-chain "Card_injection") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?") (("2" (skosimp) (("2" (lemma "Card_injection" ("S" "S!1" "n" "n!1")) (("2" (split) (("1" (lemma "Card_surjection" ("S" "S!1" "n" "n!1")) (("1" (ground) (("1" (inst?) nil nil)) nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (= const-decl "[T, T -> boolean]" equalities nil) (surjective? const-decl "bool" functions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_inj formula-decl nil finite_sets nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (Card_injection formula-decl nil finite_sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (inj_Card formula-decl nil finite_sets nil) (Card_surjection formula-decl nil finite_sets nil)) shostak)) (Card_disj_union 0 (Card_disj_union-1 nil 3243837140 ("" (skosimp) (("" (name-replace "N1" "Card(S!1)" :hide? nil) (("" (name-replace "N2" "Card(S2!1)" :hide? nil) (("" (auto-rewrite "Card_bijection") (("" (do-rewrite) (("" (skosimp*) (("" (inst 1 "LAMBDA (x : (union(S!1, S2!1))) : IF S!1(x) THEN f!2(x) ELSE N1 + f!1(x) ENDIF") (("1" (expand "bijective?") (("1" (prop) (("1" (delete -2 -4) (("1" (grind) nil nil)) nil) ("2" (delete -1 -3) (("2" (grind :if-match nil) (("2" (inst -3 "y!1") (("1" (skolem!) (("1" (inst? 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "y!1 - N1") (("2" (skolem!) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (delete -1 -2) (("3" (grind) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil finite_sets nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Card const-decl "nat" finite_sets nil) (bijective? const-decl "bool" functions nil) (y!1 skolem-const-decl "below[N1 + N2]" finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (x2!1 skolem-const-decl "(union(S!1, S2!1))" finite_sets nil) (x1!1 skolem-const-decl "(union(S!1, S2!1))" finite_sets nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (f!1 skolem-const-decl "[(S2!1) -> below[N2]]" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (union const-decl "set" sets nil) (S!1 skolem-const-decl "finite_set" finite_sets nil) (S2!1 skolem-const-decl "finite_set" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (N1 skolem-const-decl "nat" finite_sets nil) (below type-eq-decl nil nat_types nil) (f!2 skolem-const-decl "[(S!1) -> below[N1]]" finite_sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (N2 skolem-const-decl "nat" finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (card_TCC1 0 (card_TCC1-1 nil 3243832508 ("" (inst 1 "(LAMBDA S: Card(S))") nil nil) ((Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil)) shostak (card existence "" "[S: finite_sets.finite_set -> {n: naturalnumbers.nat | n = finite_sets.Card(S)}]"))) (card_def 0 (card_def-1 nil 3243837211 ("" (skosimp*) (("" (assert) nil nil)) nil) nil shostak)) (card_emptyset 0 (card_emptyset-1 nil 3242964880 ("" (rewrite "card_def") (("" (rewrite "Card_bijection") (("" (inst 1 "LAMBDA (x : {x: T | FALSE}) : 0") (("1" (expand "bijective?") (("1" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (typepred "x1!1") (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "emptyset") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp*) nil nil)) nil)) nil)) nil) ((Card_bijection formula-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (emptyset const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (card_def formula-decl nil finite_sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) shostak)) (empty_card 0 (empty_card-1 nil 3242964945 ("" (skolem!) (("" (prop) (("1" (rewrite "emptyset_is_empty?[T]") (("1" (replace -1) (("1" (use "card_emptyset") nil nil)) nil)) nil) ("2" (rewrite "card_def") (("2" (rewrite "Card_bijection") (("2" (skolem!) (("2" (delete -) (("2" (grind) (("2" (typepred "f!1(x!1)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_emptyset formula-decl nil finite_sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (T formal-type-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (Card_bijection formula-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (card_def formula-decl nil finite_sets nil)) shostak)) (card_empty? 0 (card_empty?-1 nil 3242964970 ("" (skosimp*) (("" (rewrite "empty_card") nil nil)) nil) ((empty_card formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) shostak)) (card_is_0 0 (card_is_0-1 nil 3242964987 ("" (skosimp*) (("" (rewrite "card_empty?") (("" (rewrite "emptyset_is_empty?") nil nil)) nil)) nil) ((card_empty? formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) shostak)) (nonempty_card 0 (nonempty_card-1 nil 3242965012 ("" (skosimp) (("" (expand "nonempty?") (("" (rewrite "empty_card") (("" (ground) nil nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (empty_card formula-decl nil finite_sets nil)) shostak)) (card_singleton 0 (card_singleton-1 nil 3242965037 ("" (skosimp*) (("" (rewrite "card_def") (("" (rewrite "Card_bijection") (("" (inst 1 "LAMBDA (y : (singleton(x!1))) : 0") (("" (grind) (("" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil) ((nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (card_def formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Card_bijection formula-decl nil finite_sets nil)) shostak)) (card_one 0 (card_one-1 nil 3242965057 ("" (skosimp*) (("" (rewrite "card_def") (("" (prop) (("1" (rewrite "Card_bijection") (("1" (skolem!) (("1" (grind :if-match nil) (("1" (inst -2 "0") (("1" (skolem!) (("1" (inst? 1) (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (ground) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "card_def" :dir rl) (("2" (rewrite "card_singleton") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_def formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (card_singleton formula-decl nil finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (card_disj_union 0 (card_disj_union-1 nil 3242965085 ("" (skosimp*) (("" (rewrite "card_def") (("" (rewrite "card_def") (("" (rewrite "card_def") (("" (rewrite "Card_disj_union") nil nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (card_def formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (Card_disj_union formula-decl nil finite_sets nil)) shostak)) (card_diff_subset 0 (card_diff_subset-1 nil 3242965107 ("" (skosimp) (("" (forward-chain "union_diff_subset") (("" (lemma "card_disj_union") (("" (inst?) (("" (assert) (("" (rewrite "difference_disjoint") nil nil)) nil)) nil)) nil)) nil)) nil) ((union_diff_subset formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (finite_difference application-judgement "finite_set" finite_sets nil) (difference const-decl "set" sets nil) (difference_disjoint formula-decl nil sets_lemmas nil) (finite_union application-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (int_minus_int_is_int application-judgement "int" integers nil) (card_disj_union formula-decl nil finite_sets nil)) shostak)) (card_subset 0 (card_subset-1 nil 3242965128 ("" (skosimp) (("" (forward-chain "card_diff_subset") (("" (assert) nil nil)) nil)) nil) ((card_diff_subset formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_difference application-judgement "finite_set" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (card_plus 0 (card_plus-1 nil 3242965147 ("" (auto-rewrite "union_subset1[T]" "intersection_subset1[T]") (("" (skolem!) (("" (lemma "card_diff_subset") (("" (inst-cp -1 "A!1" "union(A!1, B!1)") (("" (rewrite "diff_union_inter[T]") (("" (inst? -1) (("" (ground) (("" (rewrite "intersection_commutative" 1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (intersection const-decl "set" sets nil) (intersection_commutative formula-decl nil sets_lemmas nil) (intersection_subset1 formula-decl nil sets_lemmas nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (union_subset1 formula-decl nil sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (diff_union_inter formula-decl nil sets_lemmas nil) (card_diff_subset formula-decl nil finite_sets nil)) shostak)) (card_union 0 (card_union-1 nil 3242965170 ("" (skosimp*) (("" (lemma "card_plus") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((card_plus formula-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil)) shostak)) (card_add 0 (card_add-2 "" 3750013914 ("" (skosimp*) (("" (lift-if) (("" (prop) (("1" (rewrite "member_add") (("1" (assert) nil nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "add_as_union") (("2" (rewrite "card_disj_union") (("1" (rewrite "card_singleton") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((add_as_union formula-decl nil sets_lemmas nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (card_singleton formula-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (card_disj_union formula-decl nil finite_sets nil) (member_add formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil)) shostak) (card_add-1 nil 3242965190 ("" (skosimp*) (("" (lift-if) (("" (prop) (("1" (rewrite "member_add") (("1" (assert) nil nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "add_as_union") (("2" (rewrite "singleton" :dir rl) (("2" (rewrite "union_commutative") (("2" (rewrite "card_disj_union") (("1" (rewrite "card_singleton") (("1" (assert) (("1" (expand "singleton") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "singleton_disjoint") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_as_union formula-decl nil sets_lemmas nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (card_singleton formula-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (card_disj_union formula-decl nil finite_sets nil) (member_add formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil)) shostak)) (card_add_gt0 0 (card_add_gt0-1 nil 3299963376 ("" (skosimp) (("" (rewrite "card_add") (("" (lift-if) (("" (prop) (("1" (use "nonempty_card") (("1" (assert) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "x!1") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((card_add formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (nonempty_card formula-decl nil finite_sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (card_remove 0 (card_remove-1 nil 3242965278 ("" (skolem!) (("" (lift-if) (("" (prop) (("1" (rewrite "remove_as_difference") (("1" (rewrite "card_diff_subset") (("1" (rewrite "card_singleton") nil nil) ("2" (lemma "singleton_subset[T]") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "member_remove") (("1" (assert) nil nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((member_remove formula-decl nil sets_lemmas nil) (finite_remove application-judgement "finite_set" finite_sets nil) (remove_as_difference formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_difference application-judgement "finite_set" finite_sets nil) (singleton_subset formula-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (card_singleton formula-decl nil finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (card_diff_subset formula-decl nil finite_sets nil)) shostak)) (card_rest 0 (card_rest-1 nil 3242965301 ("" (skosimp) (("" (expand "rest") (("" (rewrite "card_remove") (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (choose_member formula-decl nil sets_lemmas nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_remove application-judgement "finite_set" finite_sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (card_remove formula-decl nil finite_sets nil)) shostak)) (same_card_subset 0 (same_card_subset-1 nil 3242965321 ("" (skosimp) (("" (case "EXISTS x : member(x, B!1) AND subset?(A!1, remove(x, B!1))") (("1" (skosimp) (("1" (expand "member") (("1" (forward-chain "card_subset") (("1" (rewrite "card_remove") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (grind :exclude "Card" :if-match nil) (("1" (inst? -) (("1" (assert) nil nil)) nil) ("2" (inst? +) (("2" (assert) (("2" (skosimp) (("2" (assert) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove const-decl "set" sets nil) (subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (finite_remove application-judgement "finite_set" finite_sets nil) (card_remove formula-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (card_subset formula-decl nil finite_sets nil) (/= const-decl "boolean" notequal nil)) shostak)) (smaller_card_subset 0 (smaller_card_subset-1 nil 3242965352 ("" (skosimp) (("" (forward-chain "card_subset") (("" (case-replace "A!1 = B!1") (("1" (assert) nil nil) ("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((card_subset formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (card_strict_subset 0 (card_strict_subset-1 nil 3458163415 ("" (skosimp) (("" (expand "strict_subset?") (("" (flatten) (("" (use "same_card_subset") (("" (assert) (("" (use "card_subset") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strict_subset? const-decl "bool" sets nil) (same_card_subset formula-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (card_subset formula-decl nil finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (card_1_has_1 0 (card_1_has_1-1 nil 3242965373 ("" (skosimp*) (("" (use "card_empty?") (("" (iff) (("" (flatten) (("" (assert) (("" (expand "empty?") (("" (skosimp*) (("" (expand "member") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_empty? formula-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (card_2_has_2 0 (card_2_has_2-1 nil 3242965395 ("" (skosimp*) (("" (lemma "card_1_has_1") (("" (inst?) (("" (assert) (("" (skosimp*) (("" (lemma "card_1_has_1") (("" (inst -1 "remove(x!1,S!1)") (("" (rewrite "card_remove") (("" (lift-if) (("" (assert) (("" (skosimp*) (("" (expand "remove") (("" (expand "member") (("" (flatten) (("" (inst 2 "x!1" "x!2") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_1_has_1 formula-decl nil finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (card_remove formula-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (finite_remove application-judgement "finite_set" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil)) shostak)) (card_intersection_le 0 (card_intersection_le-1 nil 3242965417 ("" (skosimp*) (("" (case "subset?(intersection(A!1, B!1),A!1) AND
                    subset?(intersection(A!1, B!1),B!1)") (("1" (flatten) (("1" (lemma "card_subset") (("1" (split 1) (("1" (inst -1 "intersection(A!1, B!1)" "A!1") (("1" (assert) nil nil)) nil) ("2" (inst -1 "intersection(A!1, B!1)" "B!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?") (("2" (expand "intersection") (("2" (expand "member") (("2" (split 1) (("1" (skosimp*) nil nil) ("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (intersection const-decl "set" sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (card_subset formula-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil)) shostak)) (card_bij 0 (card_bij-1 nil 3242965441 ("" (skosimp*) (("" (rewrite "card_def") (("" (rewrite "Card_bijection") nil nil)) nil)) nil) ((card_def formula-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Card_bijection formula-decl nil finite_sets nil)) shostak)) (card_bij_inv 0 (card_bij_inv-3 "" 3658946169 ("" (skosimp*) (("" (lemma "card_bij[T]") (("" (inst?) (("" (split 1) (("1" (flatten) (("1" (assert) (("1" (skolem-typepred) (("1" (lemma "bij_inv_is_bij_alt[(S!1), below[N!1]]") (("1" (inst?) (("1" (lemma "bijective_inverse_exists[(S!1), below[N!1]]") (("1" (inst?) (("1" (expand "exists1") (("1" (flatten) (("1" (skolem-typepred) (("1" (inst -3 "x!1") (("1" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide -2) (("2" (skolem-typepred) (("2" (lemma "bijective_inverse_exists[below[N!1], (S!1)]") (("2" (lemma "bij_inv_is_bij_alt[below[N!1], (S!1)]") (("2" (inst? -2) (("2" (expand "exists1") (("2" (flatten) (("2" (skolem-typepred) (("2" (inst? -) (("2" (inst? -) (("2" (inst 2 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_bij formula-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil) (bijective_inverse_exists formula-decl nil function_inverse_def nil) (exists1 const-decl "bool" exists1 nil) (x!1 skolem-const-decl "[below[N!1] -> (S!1)]" finite_sets nil) (inverse? const-decl "bool" function_inverse_def nil) (S!1 skolem-const-decl "finite_set" finite_sets nil) (N!1 skolem-const-decl "nat" finite_sets nil) (bijective? const-decl "bool" functions nil) (f!1 skolem-const-decl "[(S!1) -> below[N!1]]" finite_sets nil) (x!1 skolem-const-decl "[(S!1) -> below[N!1]]" finite_sets nil) (f!1 skolem-const-decl "[below[N!1] -> (S!1)]" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (card_bij_inv-2 "" 3590857335 ("" (skosimp*) (("" (lemma "card_bij[T]") (("" (inst?) (("" (split 1) (("1" (flatten) (("1" (assert) (("1" (skolem-typepred) (("1" (lemma "bij_inv_is_bij_alt[(S!1), below[N!1]]") (("1" (inst?) (("1" (lemma "bijective_inverse_exists[(S!1), below[N!1]]") (("1" (inst?) (("1" (expand "exists1") (("1" (flatten) (("1" (skolem-typepred) (("1" (inst -4 "x!1") (("1" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide -2) (("2" (skolem-typepred) (("2" (lemma "bijective_inverse_exists[below[N!1], (S!1)]") (("2" (lemma "bij_inv_is_bij_alt[below[N!1], (S!1)]") (("2" (inst? -2) (("2" (expand "exists1") (("2" (flatten) (("2" (skolem-typepred) (("2" (inst? -2) (("2" (inst? -2) (("2" (inst 2 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (card_bij formula-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil) (bijective_inverse_exists formula-decl nil function_inverse_def nil) (exists1 const-decl "bool" exists1 nil) (inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (card_bij_inv-1 nil 3307953160 ("" (skosimp*) (("" (lemma "card_bij[T]") (("" (inst?) (("" (case-replace "N!1 = 0") (("1" (ground) (("1" (inst 1 "LAMBDA (n: below[N!1]): epsilon(S!1)") (("1" (expand "bijective?") (("1" (expand "injective?") (("1" (expand "surjective?") (("1" (split 1) (("1" (skolem-typepred) nil nil) ("2" (skolem-typepred) (("2" (rewrite "card_empty?") (("2" (hide -2) (("2" (expand "empty?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) nil nil) ("3" (skolem-typepred) nil nil)) nil) ("2" (skolem-typepred) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (rewrite "card_empty?") (("2" (expand "empty?" 1) (("2" (expand "member") (("2" (skosimp) (("2" (inst -2 "x!1") (("2" (skolem-typepred) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (hide -2) (("1" (skosimp) (("1" (inst + "inverse(f!1)") (("1" (lemma "bijective_inverse_is_bijective[(S!1),below(N!1)]") (("1" (inst?) nil nil) ("2" (assert) (("2" (use "nonempty_card") (("2" (assert) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skosimp*) (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nonempty_card") (("2" (assert) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp*) (("2" (inst + "inverse(f!1)") (("1" (lemma "bijective_inverse_is_bijective[below(N!1),(S!1)]") (("1" (inst?) nil nil) ("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -2 "choose(S!1)") (("1" (skosimp*) (("1" (inst + "x!1") nil nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_bij formula-decl nil finite_sets nil) (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil) (bijective_inverse_exists formula-decl nil function_inverse_def nil) (exists1 const-decl "bool" exists1 nil) (inverse? const-decl "bool" function_inverse_def nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (bij_exists 0 (bij_exists-1 nil 3242965457 ("" (skosimp*) (("" (lemma "card_bij") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((card_bij formula-decl nil finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (bij_TCC1 0 (bij_TCC1-3 "" 3658946502 ("" (inst + "(LAMBDA (S: finite_set):
       		 choose({f: [(S) -> below(card(S))] |
                                   bijective?(f)}))") (("" (lemma "bij_exists[T]") (("" (skosimp*) (("" (inst?) (("" (skosimp*) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bij_exists formula-decl nil finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) shostak (bij existence "" "[S: finite_sets.finite_set -> {f: [(S) -> naturalnumbers.below(finite_sets.card(S))] | functions[(S), naturalnumbers.below(finite_sets.card(S))].bijective?(f)}]")) (bij_TCC1-2 nil 3510413559 ("" (lemma "bij_exists[T]") (("" (inst + "(LAMBDA (S: finite_set):
     		 choose({f: [(S) -> below(card[T](S))] |
                                 bijective?(f)}))") (("" (skosimp*) (("" (inst?) (("" (skosimp*) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bij_exists formula-decl nil finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil)) nil (bij existence "" "[S: finite_sets.finite_set -> {f: [(S) -> naturalnumbers.below(finite_sets.card(S))] | functions[(S), naturalnumbers.below(finite_sets.card(S))].bijective?(f)}]")) (bij_TCC1-1 nil 3510413341 ("" (existence-tcc) nil nil) nil nil (bij existence "" "[S: finite_sets.finite_set -> {f: [(S) -> naturalnumbers.below(finite_sets.card(S))] | functions[(S), naturalnumbers.below(finite_sets.card(S))].bijective?(f)}]"))) (ibij_TCC1 0 (ibij_TCC1-1 nil 3510413341 ("" (existence-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil)) nil (ibij existence "" "(finite_sets.S)"))) (bij_ibij 0 (bij_ibij-1 nil 3510413649 ("" (skosimp*) (("" (expand "ibij") (("" (lemma "comp_inverse_right[(S!1),below(card(S!1))]") (("1" (inst?) nil nil) ("2" (typepred "S!1") (("2" (expand "empty?") (("2" (skosimp*) (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ibij const-decl "{f: [below(card(S)) -> (S)] | bijective?(f)}" finite_sets nil) (x!1 skolem-const-decl "T" finite_sets nil) (S!1 skolem-const-decl "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil) (bij const-decl "{f: [(S) -> below(card(S))] | bijective?(f)}" finite_sets nil) (bijective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil) (comp_inverse_right formula-decl nil function_inverse nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (below type-eq-decl nil naturalnumbers nil)) nil)) (ibij_bij 0 (ibij_bij-1 nil 3510413669 ("" (skosimp*) (("" (assert) (("" (expand "ibij") (("" (assert) (("" (lemma "bijective_inverse[(S!1),below(card(S!1))]") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((bijective_inverse_is_bijective application-judgement "(bijective?[R, D])" function_inverse nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (bij const-decl "{f: [(S) -> below(card(S))] | bijective?(f)}" finite_sets nil) (bijective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil) (bijective_inverse formula-decl nil function_inverse nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (below type-eq-decl nil naturalnumbers nil) (ibij const-decl "{f: [below(card(S)) -> (S)] | bijective?(f)}" finite_sets nil)) nil)) (is_finite_exists_N 0 (is_finite_exists_N-1 nil 3510413692 ("" (skosimp*) (("" (lemma "is_finite_surj[T]") (("" (inst?) (("" (assert) (("" (hide 2) (("" (inst + "N!1" "(LAMBDA (n: below(N!1)): g!1(n))") (("1" (expand "surjective?") (("1" (skosimp*) (("1" (typepred "y!1") (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite_surj formula-decl nil finite_sets nil) (g!1 skolem-const-decl "[below[N!1] -> T]" finite_sets nil) (below type-eq-decl nil naturalnumbers nil) (N!1 skolem-const-decl "nat" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets nil)) nil)) (finite_pred 0 (finite_pred-1 nil 3307981117 ("" (expand "fullset") (("" (expand "is_finite") (("" (skosimp*) (("" (inst 1 "N!1" "(LAMBDA (x: {x: T | P!1(x)}): f!1(x))") (("" (expand "injective?") (("" (skosimp*) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (fullset const-decl "set" sets nil)) shostak)) (finite_pred2 0 (finite_pred2-1 nil 3307981300 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil)) shostak)) (card_implies_TCC1 0 (card_implies_TCC1-3 "" 3805154630 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: {x: T | P1!1(x)}): f!1(x)") (("" (skeep :preds? t) (("" (inst? -5) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P1(x)}" "finite_set")) (card_implies_TCC1-2 "" 3658947486 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: {x: T | P1!1(x)}): f!1(x)") (("" (skeep :preds? t) (("" (inst? -) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P1(x)}" "finite_set")) (card_implies_TCC1-1 nil 3307950062 ("" (skosimp) (("" (rewrite "finite_pred") nil nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P1(x)}" "finite_set"))) (card_implies_TCC2 0 (card_implies_TCC2-3 "" 3805154657 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: {x: T | P2!1(x)}): f!1(x)") (("" (skeep :preds? t) (("" (inst? -5) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P2(x)}" "finite_set")) (card_implies_TCC2-2 "" 3658947422 ("" (grind :if-match nil) (("" (inst 1 "N!1" "lambda (x: {x: T | P2!1(x)}): f!1(x)") (("" (skeep :preds? t) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P2(x)}" "finite_set")) (card_implies_TCC2-1 nil 3307950062 ("" (skosimp) (("" (rewrite "finite_pred") nil nil)) nil) ((T formal-type-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) shostak (card_implies subtype "{x: finite_sets.T | finite_sets.P2(x)}" "finite_set"))) (card_implies 0 (card_implies-2 "" 3658948213 ("" (skeep :preds? t) (("" (use "card_subset") (("1" (assert) (("1" (expand "subset?") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (skeep :preds? t) (("2" (inst 1 "N" "lambda (x: {x: T | P2(x)}): f(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (skeep :preds? t) (("3" (inst 1 "N" "lambda (x: {x: T | P1(x)}): f(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((card_subset formula-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (P2 skolem-const-decl "pred[T]" finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (pred type-eq-decl nil defined_types nil) (P1 skolem-const-decl "pred[T]" finite_sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (fullset const-decl "set" sets nil)) shostak) (card_implies-1 nil 3307981157 ("" (skosimp*) (("" (case "subset?({x: T | P1!1(x)},{x: T | P2!1(x)})") (("1" (lemma "card_subset[T]") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide -1 -3 2) (("2" (rewrite "finite_pred") nil nil)) nil) ("3" (rewrite "finite_pred") nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "subset?") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((card_subset formula-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (pred type-eq-decl nil defined_types nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (fullset const-decl "set" sets nil)) shostak)) (finite_induction 0 (finite_induction-1 nil 3307981389 ("" (grind) nil nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil)) shostak)))(restrict_set_props (restrict_finite 0 (restrict_finite-1 nil 3249347110 ("" (skosimp) (("" (expand "is_finite") (("" (skolem!) (("" (inst + "N!1" "LAMBDA (x: (restrict[T, S, bool](a!1))): f!1(x)") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (a!1 skolem-const-decl "set[T]" restrict_set_props nil) (set type-eq-decl nil sets nil) (restrict const-decl "R" restrict nil) (bool nonempty-type-eq-decl nil booleans nil) (S formal-subtype-decl nil restrict_set_props nil) (S_pred const-decl "[T -> boolean]" restrict_set_props nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil restrict_set_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil)) nil)) (finite_restrict 0 (finite_restrict-1 nil 3249347110 ("" (skolem!) (("" (use "restrict_finite") (("" (assert) nil nil)) nil)) nil) ((restrict_finite formula-decl nil restrict_set_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil restrict_set_props nil)) nil (finite_restrict subtype "restrict[restrict_set_props.T, S, booleans.bool].restrict(restrict_set_props.a)" "finite_set[S]"))) (empty_restrict 0 (empty_restrict-1 nil 3249347110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil restrict_set_props nil) (set type-eq-decl nil sets nil) (S formal-subtype-decl nil restrict_set_props nil) (S_pred const-decl "[T -> boolean]" restrict_set_props nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil (empty_restrict subtype "restrict[restrict_set_props.T, S, booleans.bool].restrict(restrict_set_props.a)" "(sets[S].empty?)"))) (card_restrict 0 (card_restrict-2 "Fix for 3.2" 3307984009 ("" (skolem!) (("" (case "empty?(restrict[T, S, bool](a!1))") (("1" (rewrite "empty_card[S]") (("1" (assert) nil nil)) nil) ("2" (expand* "empty?" "member") (("2" (skolem!) (("2" (use "injection_n_to_m_var") (("2" (use "card_bij[S]") (("2" (lemma "card_bij[T]" ("N" "card(a!1)" "S" "a!1")) (("2" (assert) (("2" (skosimp*) (("2" (use "bij_inv_is_bij[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]]") (("1" (assert) (("1" (inst + "LAMBDA (x: below(card(restrict[T, S, bool](a!1)))): f!1(inverse(f!2)(x))") (("1" (expand "bijective?" (-1 -2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst - "x1!1" "x2!1") (("1" (inst - "inverse(f!2)(x1!1)" "inverse(f!2)(x2!1)") (("1" (assert) nil nil) ("2" (typepred "inverse[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]](f!2)(x2!1)") (("1" (expand "restrict") (("1" (inst + "x!1") nil nil)) nil) ("2" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (typepred "inverse[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]](f!2)(x!2)") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (inst + "x!1") nil nil)) nil)) nil) ("3" (skolem!) (("3" (inst + "x!1") nil nil)) nil)) nil)) nil) ("2" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (restrict const-decl "R" restrict nil) (empty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (S formal-subtype-decl nil restrict_set_props nil) (S_pred const-decl "[T -> boolean]" restrict_set_props nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil restrict_set_props nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_card formula-decl nil finite_sets nil) (card_bij formula-decl nil finite_sets nil) (TRUE const-decl "bool" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bij_inv_is_bij formula-decl nil function_inverse nil) (a!1 skolem-const-decl "finite_set[T]" restrict_set_props nil) (below type-eq-decl nil naturalnumbers nil) (inverse const-decl "D" function_inverse nil) (f!2 skolem-const-decl "[(restrict[T, S, bool](a!1)) -> below[card(restrict[T, S, bool](a!1))]]" restrict_set_props nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (injection_n_to_m_var formula-decl nil nat_fun_props nil) (member const-decl "bool" sets nil)) shostak) (card_restrict-1 nil 3249390068 ("" (skolem!) (("" (case "empty?(restrict[T, S, bool](a!1))") (("1" (rewrite "empty_card[S]") (("1" (assert) nil nil)) nil) ("2" (expand* "empty?" "member") (("2" (skolem!) (("2" (use "injection_n_to_m_var") (("2" (use "card_bij[S]") (("2" (lemma "card_bij[T]" ("N" "card(a!1)" "S" "a!1")) (("2" (assert) (("2" (skosimp*) (("2" (use "bij_inv_is_bij[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]]") (("1" (assert) (("1" (inst + "LAMBDA (x: below(card(restrict[T, S, bool](a!1)))): f!1(inverse(f!2)(x))") (("1" (expand "bijective?" (-1 -2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst - "x1!1" "x2!1") (("1" (inst - "inverse(f!2)(x1!1)" "inverse(f!2)(x2!1)") (("1" (assert) nil nil) ("2" (typepred "inverse[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]](f!2)(x2!1)") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (inst + "x!1") nil nil)) nil) ("3" (typepred "inverse[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]](f!2)(x1!1)") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (inst + "x!1") nil nil)) nil) ("4" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (typepred "inverse[(restrict[T, S, bool](a!1)), below[card(restrict[T, S, bool](a!1))]](f!2)(x!2)") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (inst + "x!1") nil nil)) nil)) nil) ("3" (skolem!) (("3" (inst + "x!1") nil nil)) nil)) nil)) nil) ("2" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)))(extend_set_props (finite_extension 0 (finite_extension-1 nil 3249327215 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil extend_set_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (set type-eq-decl nil sets nil) (a!1 skolem-const-decl "set[S]" extend_set_props nil) (FALSE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (extend const-decl "R" extend nil)) nil)) (finite_extend 0 (finite_extend-1 nil 3249327215 ("" (lemma "finite_extension") (("" (skolem-typepred) (("" (inst?) (("" (prop) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_extension formula-decl nil extend_set_props nil)) nil (finite_extend subtype "extend[extend_set_props.T, S, booleans.bool, booleans.FALSE].extend(extend_set_props.a)" "finite_set[T]"))) (empty_extend 0 (empty_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "empty?" "member" "extend") (("" (skolem!) (("" (prop) (("" (inst?) nil nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (extend const-decl "R" extend nil) (empty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (S formal-subtype-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (T formal-type-decl nil extend_set_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (empty_extend subtype "extend[extend_set_props.T, S, booleans.bool, booleans.FALSE].extend(extend_set_props.a)" "(sets[extend_set_props.T].empty?)"))) (nonempty_extend 0 (nonempty_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "nonempty?" "empty?" "member" "extend") (("" (skolem-typepred) (("" (inst?) (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (S formal-subtype-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (T formal-type-decl nil extend_set_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (nonempty_extend subtype "extend[extend_set_props.T, S, booleans.bool, booleans.FALSE].extend(extend_set_props.a)" "(sets[extend_set_props.T].nonempty?)"))) (singleton_extend 0 (singleton_extend-1 nil 3249327215 ("" (skolem-typepred) (("" (expand* "extend" "singleton?") (("" (skolem!) (("" (inst + "x!1") (("" (skolem-typepred) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((extend const-decl "R" extend nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (singleton? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (S formal-subtype-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (T formal-type-decl nil extend_set_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (singleton_extend subtype "extend[extend_set_props.T, S, booleans.bool, booleans.FALSE].extend(extend_set_props.a)" "(sets[extend_set_props.T].singleton?)"))) (card_extend 0 (card_extend-1 nil 3249389673 ("" (skolem!) (("" (use "bij_exists[S]") (("" (use "card_bij[T]") (("" (assert) (("" (skolem!) (("" (inst + "f!1") (("1" (expand* "bijective?" "injective?" "surjective?") (("1" (prop) (("1" (skosimp :preds? t) (("1" (expand "extend") (("1" (prop) (("1" (assert) (("1" (inst - "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst -2 "y!1") (("2" (skolem!) (("2" (inst + "x!1") (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skolem!) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bij_exists formula-decl nil finite_sets nil) (T formal-type-decl nil extend_set_props nil) (boolean nonempty-type-decl nil booleans nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (a!1 skolem-const-decl "finite_set[S]" extend_set_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!1 skolem-const-decl "(a!1)" extend_set_props nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (card_bij formula-decl nil finite_sets nil)) shostak)) (empty?_extend 0 (empty?_extend-1 nil 3362459601 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) shostak)) (nonempty?_extend 0 (nonempty?_extend-1 nil 3362459616 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) shostak)) (singleton?_extend 0 (singleton?_extend-1 nil 3362459622 ("" (grind-with-ext :polarity? t) (("1" (inst? 1) (("1" (skosimp) (("1" (inst?) nil nil)) nil)) nil) ("2" (inst? 1) (("2" (skolem-typepred) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((y!1 skolem-const-decl "(extend[T, S, bool, FALSE](a!1))" extend_set_props nil) (a!1 skolem-const-decl "set[S]" extend_set_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil)) shostak)) (subset_extend 0 (subset_extend-1 nil 3362459879 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) shostak)) (union_extend 0 (union_extend-1 nil 3362459887 ("" (grind-with-ext) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (union const-decl "set" sets nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (T formal-type-decl nil extend_set_props nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (intersection_extend 0 (intersection_extend-1 nil 3362459893 ("" (grind-with-ext) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (intersection const-decl "set" sets nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (T formal-type-decl nil extend_set_props nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (difference_extend 0 (difference_extend-1 nil 3362459902 ("" (grind-with-ext) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (difference const-decl "set" sets nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (T formal-type-decl nil extend_set_props nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (add_extend 0 (add_extend-1 nil 3362459907 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (set type-eq-decl nil sets nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (member const-decl "bool" sets nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil)) shostak)) (remove_extend 0 (remove_extend-1 nil 3362459912 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil extend_set_props nil) (S_pred const-decl "[T -> boolean]" extend_set_props nil) (S formal-subtype-decl nil extend_set_props nil) (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil)) shostak)))(function_image_aux (finite_image 0 (finite_image-1 nil 3249929301 ("" (skolem-typepred) (("" (expand* "image" "is_finite") (("" (skolem!) (("" (inst + "N!1" "LAMBDA (z: ({y: R | EXISTS (x: (S!1)): y = f!1(x)})): f!2(choose({d: (S!1) | f!1(d) = z}))") (("1" (expand "injective?") (("1" (skosimp* :preds? t) (("1" (inst - "choose({d: (S!1) | f!1(d) = x1!1})" "choose({d: (S!1) | f!1(d) = x2!1})") (("1" (assert) nil nil) ("2" (expand* "nonempty?" "empty?" "member") (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "nonempty?" "empty?" "member") (("3" (inst - "x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "nonempty?" "empty?" "member") (("2" (skosimp* :preds? t) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((image const-decl "set[R]" function_image nil) (nonempty? const-decl "bool" sets nil) (f!1 skolem-const-decl "[D -> R]" function_image_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (S!1 skolem-const-decl "finite_set[D]" function_image_aux nil) (R formal-type-decl nil function_image_aux nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (choose const-decl "(p)" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (x2!1 skolem-const-decl "({y: R | EXISTS (x: (S!1)): y = f!1(x)})" function_image_aux nil) (x1!1 skolem-const-decl "({y: R | EXISTS (x: (S!1)): y = f!1(x)})" function_image_aux nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (D formal-type-decl nil function_image_aux nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (finite_image subtype "function_image[function_image_aux.D, function_image_aux.R].image(function_image_aux.f, function_image_aux.S)" "finite_set[R]"))) (card_image 0 (card_image-2 nil 3250016405 ("" (skolem!) (("" (use "injection_n_to_m_var") (("" (use "card_bij[R]") (("" (lemma "card_bij[D]" ("N" "card(S!1)" "S" "S!1")) (("" (assert) (("" (case "EXISTS (f: [(image(f!1, S!1)) -> (S!1)]): injective?(f)") (("1" (skosimp*) (("1" (lemma "composition_injective[below(card(image(f!1, S!1))), (image(f!1, S!1)), (S!1)]") (("1" (inst - "LAMBDA (x: below[card(image(f!1, S!1))]): choose({r: (image(f!1, S!1)) | f!4(r) = x})" "f!2") (("1" (lemma "composition_injective[below(card(image(f!1, S!1))), (S!1), below(card(S!1))]") (("1" (inst - "f!2 o (LAMBDA (x: below[card(image(f!1, S!1))]): choose({r: (image(f!1, S!1)) | f!4(r) = x}))" "f!3") (("1" (inst + "f!3 o (f!2 o (LAMBDA (x: below[card(image(f!1, S!1))]): choose({r: (image(f!1, S!1)) | f!4(r) = x})))") (("1" (expand "bijective?" -5) (("1" (skosimp) (("1" (expand* "nonempty?" "empty?" "member" "surjective?") (("1" (inst -7 "x!1") (("1" (skolem!) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) nil nil)) nil) ("3" (expand "bijective?" -4) (("3" (skosimp) (("3" (expand* "nonempty?" "empty?" "member" "surjective?") (("3" (inst -6 "x!1") (("3" (skolem!) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "injective?" 1) (("2" (skosimp :preds? t) (("2" (typepred "choose[(image(f!1, S!1))]({r: (image[D, R](f!1, S!1)) | f!4(r) = x1!1})") (("1" (typepred "choose[(image(f!1, S!1))]({r: (image[D, R](f!1, S!1)) | f!4(r) = x2!1})") (("1" (expand "image" (-1 -3)) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "bijective?" -8) (("2" (flatten) (("2" (expand* "nonempty?" "empty?" "member" "surjective?") (("2" (inst -10 "x2!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -6) (("2" (flatten) (("2" (expand* "nonempty?" "empty?" "member" "surjective?") (("2" (inst -8 "x1!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "bijective?" -3) (("3" (skosimp) (("3" (expand* "nonempty?" "empty?" "member" "surjective?") (("3" (inst -5 "x!1") (("3" (skolem!) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "LAMBDA (r: (image(f!1, S!1))): choose({d: (S!1) | f!1(d) = r})") (("1" (expand "injective?" 1) (("1" (skosimp :preds? t) (("1" (expand "image" -) (("1" (skosimp*) (("1" (typepred "choose({d: (S!1) | f!1(d) = x1!1})") (("1" (typepred "choose({d: (S!1) | f!1(d) = x2!1})") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (expand* "nonempty?" "empty?" "member") (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "nonempty?" "empty?" "member") (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand* "image" "nonempty?" "empty?" "member") (("2" (skolem!) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((injection_n_to_m_var formula-decl nil nat_fun_props nil) (image const-decl "set[R]" function_image nil) (R formal-type-decl nil function_image_aux nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (D formal-type-decl nil function_image_aux nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) (injective? const-decl "bool" functions nil) (composition_injective judgement-tcc nil function_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (surjective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (f!3 skolem-const-decl "[(S!1) -> below[card(S!1)]]" function_image_aux nil) (O const-decl "T3" function_props nil) (choose const-decl "(p)" sets nil) (f!4 skolem-const-decl "[(image(f!1, S!1)) -> below[card(image(f!1, S!1))]]" function_image_aux nil) (nonempty? const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (f!2 skolem-const-decl "[(image(f!1, S!1)) -> (S!1)]" function_image_aux nil) (S!1 skolem-const-decl "finite_set[D]" function_image_aux nil) (f!1 skolem-const-decl "[D -> R]" function_image_aux nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (card_bij formula-decl nil finite_sets nil)) nil)) (card_injective_image 0 (card_injective_image-1 nil 3250016633 ("" (skolem-typepred) (("" (use "card_image") (("" (lemma "injection_n_to_m_var") (("" (inst - "card(image(inj!1, S!1))" "card(S!1)") (("" (assert) (("" (case "EXISTS (f: [below(card(S!1)) -> (S!1)]): injective?(f)") (("1" (use "bij_exists[R]") (("1" (expand "bijective?") (("1" (skosimp*) (("1" (lemma "composition_injective[below(card(S!1)), (S!1), (image(inj!1, S!1))]") (("1" (inst - "f!2" "restrict[D, (S!1), R](inj!1)") (("1" (use "composition_injective[below(card(S!1)), (image(inj!1, S!1)), below(card(image(inj!1, S!1)))]") (("1" (inst?) (("1" (skolem!) (("1" (expand* "restrict" "image") (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (expand* "restrict" "image") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (skolem!) (("1" (expand* "restrict" "image") (("1" (inst?) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "injective?" (-5 1)) (("2" (skosimp) (("2" (inst - "x1!1" "x2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "bij_exists[D]") (("2" (skolem!) (("2" (expand "bijective?") (("2" (flatten) (("2" (inst + "LAMBDA (n: below(card(S!1))): choose({d: (S!1) | f!1(d) = n})") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (typepred "choose({d: (S!1) | f!1(d) = x1!1})") (("1" (typepred "choose({d: (S!1) | f!1(d) = x2!1})") (("1" (assert) nil nil) ("2" (expand* "nonempty?" "empty?" "member" "surjective?") (("2" (inst -7 "x2!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* "nonempty?" "empty?" "member" "surjective?") (("2" (inst -5 "x1!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (expand* "nonempty?" "empty?" "member" "surjective?") (("2" (inst -3 "n!1") (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_image formula-decl nil function_image_aux nil) (finite_image application-judgement "finite_set[R]" function_image_aux nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (image const-decl "set[R]" function_image nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (composition_injective judgement-tcc nil function_props nil) (O const-decl "T3" function_props nil) (inj!1 skolem-const-decl "(injective?[D, R])" function_image_aux nil) (f!1 skolem-const-decl "[(image(inj!1, S!1)) -> below(card(image(inj!1, S!1)))]" function_image_aux nil) (restrict const-decl "R" restrict nil) (f!2 skolem-const-decl "[below(card(S!1)) -> (S!1)]" function_image_aux nil) (S!1 skolem-const-decl "finite_set[D]" function_image_aux nil) (restrict_of_inj_is_inj application-judgement "(injective?[S, R])" restrict nil) (bij_exists formula-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (choose const-decl "(p)" sets nil) (f!1 skolem-const-decl "[(S!1) -> below(card(S!1))]" function_image_aux nil) (nonempty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injection_n_to_m_var formula-decl nil nat_fun_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (injective? const-decl "bool" functions nil) (R formal-type-decl nil function_image_aux nil) (D formal-type-decl nil function_image_aux nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (bijective_image_TCC1 0 (bijective_image_TCC1-1 nil 3249929500 ("" (expand* "fullset" "image") (("" (skosimp*) (("" (inst?) nil nil)) nil)) nil) ((D formal-type-decl nil function_image_aux nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (image const-decl "set[R]" function_image nil)) shostak (bijective_image subtype "function_image_aux.inj" "[function_image_aux.D -> (function_image[function_image_aux.D, function_image_aux.R].image(function_image_aux.inj, sets[function_image_aux.D].fullset))]"))) (bijective_image 0 (bijective_image-1 nil 3249929533 ("" (skolem-typepred) (("" (expand* "bijective?" "injective?" "surjective?") (("" (smash) (("" (skolem-typepred) (("" (expand* "fullset" "image") (("" (skolem!) (("" (inst?) (("" (inst? +) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (set type-eq-decl nil sets nil) (image const-decl "set[R]" function_image nil) (fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (R formal-type-decl nil function_image_aux nil) (D formal-type-decl nil function_image_aux nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)))(function_iterate (iterate_TCC1 0 (iterate_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (iterate subtype "(number_fields.-)(function_iterate.n, 1)" "nat"))) (iterate_TCC2 0 (iterate_TCC2-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (iterate termination "function_iterate.iterate(function_iterate.f, (number_fields.-)(function_iterate.n, 1))" "nil"))) (iterate_add 0 (iterate_add-1 nil 3237052399 ("" (induct "m") (("1" (skosimp) (("1" (expand "iterate" 1 1) (("1" (expand "o") (("1" (apply-extensionality) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (expand "iterate" 1 1) (("2" (expand "iterate" 1 3) (("2" (inst -1 "f!1" "n!1") (("2" (expand "o") (("2" (apply-extensionality) (("2" (replace -1 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (iterate def-decl "T" function_iterate nil) (O const-decl "T3" function_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil function_iterate nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil)) (iterate_add_applied 0 (iterate_add_applied-1 nil 3237052399 ("" (induct-and-simplify "m") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (iterate def-decl "T" function_iterate nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (iterate_add_one 0 (iterate_add_one-1 nil 3237052399 ("" (induct-and-simplify "n") nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (iterate def-decl "T" function_iterate nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (iterate_mult 0 (iterate_mult-2 "" 3564901423 ("" (induct "m") (("1" (induct "n") (("1" (skosimp) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst?) (("2" (expand "iterate" 1 1) (("2" (apply-extensionality) (("2" (replace -1) (("2" (expand "iterate" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (induct "n" :name "NAT_induction") (("2" (skosimp) (("2" (skosimp) (("2" (case "j!2 = 0") (("1" (replace -1) (("1" (expand "iterate" 1 1) (("1" (expand "iterate" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "iterate" 2 1) (("2" (expand "iterate" 2 4) (("2" (apply-extensionality 2) (("1" (hide 3) (("1" (inst-cp -1 "j!2-1") (("1" (assert) (("1" (inst? -2) (("1" (replace -2) (("1" (lemma "iterate_add") (("1" (inst -1 "f!1" "1+j!1" "-1 - j!1 + j!1 * j!2 + j!2") (("1" (expand "o") (("1" (case "iterate(f!1, 1 + j!1)(iterate(f!1, -1 - j!1 + j!1 * j!2 + j!2)(x!1)) = iterate(f!1, j!1 * j!2 + j!2)(x!1)") (("1" (hide -2) (("1" (replace -1) (("1" (expand "iterate" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (beta) (("2" (assert) nil nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 2) (("3" (case "j!1 * j!2 >= j!1") (("1" (assert) nil nil) ("2" (assert) (("2" (case "j!1 = 0") (("1" (assert) nil nil) ("2" (lemma "div_mult_pos_ge2") (("2" (inst -1 "j!1" "j!2" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (case "j!1 * j!2 >= j!1") (("1" (assert) nil nil) ("2" (lemma "div_mult_pos_ge2") (("2" (inst -1 "j!1" "j!2" "j!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (nil application-judgement "above(n)" exp2 nil) (O const-decl "T3" function_props nil) (iterate_add formula-decl nil function_iterate nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (j!2 skolem-const-decl "nat" function_iterate nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "nat" function_iterate nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (NAT_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil function_iterate nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak) (iterate_mult-1 nil 3237052399 ("" (induct "m") (("1" (induct "n") (("1" (skosimp) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst?) (("2" (expand "iterate" 1 1) (("2" (apply-extensionality) (("2" (replace -1) (("2" (expand "iterate" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (induct "n" :name "NAT_induction") (("2" (skosimp) (("2" (skosimp) (("2" (case "j!2 = 0") (("1" (replace -1) (("1" (expand "iterate" 1 1) (("1" (expand "iterate" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "iterate" 2 1) (("2" (expand "iterate" 2 4) (("2" (apply-extensionality 2) (("2" (hide 3) (("2" (inst-cp -1 "j!2-1") (("2" (assert) (("2" (inst? -2) (("2" (replace -2) (("2" (lemma "iterate_add") (("2" (inst -1 "f!1" "1+j!1" "-1 - j!1 + j!1 * j!2 + j!2") (("1" (expand "o") (("1" (case "iterate(f!1, 1 + j!1)(iterate(f!1, -1 - j!1 + j!1 * j!2 + j!2)(x!1)) = iterate(f!1, j!1 * j!2 + j!2)(x!1)") (("1" (hide -2) (("1" (replace -1) (("1" (expand "iterate" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (beta) (("2" (propax) nil nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 2) (("3" (case "j!1 * j!2 >= j!1") (("1" (assert) nil nil) ("2" (assert) (("2" (case "j!1 = 0") (("1" (assert) nil nil) ("2" (lemma "div_mult_pos_ge2") (("2" (inst -1 "j!1" "j!2" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (case "j!1 * j!2 >= j!1") (("1" (assert) nil nil) ("2" (lemma "div_mult_pos_ge2") (("2" (inst -1 "j!1" "j!2" "j!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (O const-decl "T3" function_props nil) (iterate_add formula-decl nil function_iterate nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (NAT_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil function_iterate nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil)) (iterate_invariant 0 (iterate_invariant-1 nil 3237052399 ("" (induct "n") (("1" (skosimp*) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil function_iterate nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)))(sequences (insert_TCC1 0 (insert_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (insert subtype "(number_fields.-)(sequences.i, 1)" "nat"))) (insert_delete 0 (insert_delete-1 nil 3237052399 ("" (skolem 1 ("n!1" "seq!1")) (("" (expand "insert") (("" (apply-extensionality 1) (("1" (delete 2) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "delete") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "delete") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (apply-extensionality 4) nil nil)) nil)) nil)) nil)) nil) ((insert const-decl "sequence" sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (n!1 skolem-const-decl "nat" sequences nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sequence type-eq-decl nil sequences nil) (delete const-decl "sequence" sequences nil) (nth const-decl "T" sequences nil) (T formal-type-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (add_first_rest 0 (add_first_rest-1 nil 3237052399 ("" (skolem 1 ("seq!1")) (("" (expand "add") (("" (expand "insert") (("" (apply-extensionality 1) (("1" (delete 2) (("1" (lift-if) (("1" (prop) (("1" (expand "first") (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "rest") (("2" (expand "suffix") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (apply-extensionality 3) nil nil)) nil)) nil)) nil)) nil)) nil) ((add const-decl "sequence" sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sequences nil) (rest const-decl "sequence" sequences nil) (first const-decl "T" sequences nil) (sequence type-eq-decl nil sequences nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (suffix const-decl "sequence" sequences nil) (nth const-decl "T" sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (insert const-decl "sequence" sequences nil)) nil)) (sequence_induction 0 (sequence_induction-1 nil 3237052399 ("" (lemma "nat_induction") (("" (skosimp) (("" (inst -1 "(lambda (n:nat): p!1(nth(seq!1, n)))") (("" (assert) (("" (split) (("1" (assert) (("1" (expand "every") (("1" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (every const-decl "bool" sequences nil) (nth const-decl "T" sequences nil) (sequence type-eq-decl nil sequences nil) (T formal-type-decl nil sequences nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)))(seq_functions)(finite_sequences (empty_seq_TCC1 0 (empty_seq_TCC1-1 nil 3237052399 ("" (existence-tcc) nil nil) nil nil (empty_seq existence "" "finite_sequences.T"))) (oh_TCC1 0 (oh_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)) nil (oh subtype "finite_sequences.n" "below[fs1`length]"))) (oh_TCC2 0 (oh_TCC2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)) nil (oh subtype "(number_fields.-)(finite_sequences.n, finite_sequences.l1)" "below[fs2`length]"))) (caret_TCC1 0 (caret_TCC1-1 nil 3237052399 ("" (grind :if-match nil) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (caret subtype "finite_sequences.len" "nat"))) (caret_TCC2 0 (caret_TCC2-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (caret subtype "(number_fields.+)(finite_sequences.x, finite_sequences.m)" "below[fs`length]"))) (doublecaret_TCC1 0 (doublecaret_TCC1-1 nil 3458163332 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (doublecaret subtype "finite_sequences.len" "nat"))) (doublecaret_TCC2 0 (doublecaret_TCC2-1 nil 3458163332 ("" (subtype-tcc) nil nil) nil shostak (doublecaret subtype "(number_fields.+)(finite_sequences.x, finite_sequences.m)" "below[fs`length]"))) (extract1_TCC1 0 (extract1_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (extract1 subtype "0" "below[fs`length]"))) (o_assoc 0 (o_assoc-1 nil 3237052399 ("" (skosimp) (("" (expand "o") (("" (apply-extensionality) (("1" (hide 2) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (O const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (fs3!1 skolem-const-decl "finseq" finite_sequences nil) (fs2!1 skolem-const-decl "finseq" finite_sequences nil) (fs1!1 skolem-const-decl "finseq" finite_sequences nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)))(more_finseq (prefix?_TCC1 0 (prefix?_TCC1-1 nil 3458163333 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (seq type-eq-decl nil more_finseq nil) (T formal-type-decl nil more_finseq nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (prefix? subtype "more_finseq.i" "below[ss`length]"))) (add_TCC1 0 (add_TCC1-1 nil 3458163333 ("" (subtype-tcc) nil nil) nil shostak (add subtype "more_finseq.rr`length" "below[1 + rr`length]"))) (add_TCC2 0 (add_TCC2-1 nil 3726081087 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil more_finseq nil) (seq type-eq-decl nil more_finseq nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (add subtype "more_finseq.x1" "below[rr`length]"))))(ordstruct)(ordinals (lessp_TCC1 0 (lessp_TCC1-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[ordstruct -> nat]" ordstruct_adt nil) (size const-decl "[ordstruct -> nat]" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (lessp termination "(ordinals.<(ordinals.u, ordinals.z))" "nil"))) (lessp_TCC2 0 (lessp_TCC2-1 nil 3237052399 ("" (skeep*) (("" (replace -1) (("" (expand "size") (("" (assert) (("" (expand "reduce_nat" 3 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[ordstruct -> nat]" ordstruct_adt nil) (size const-decl "[ordstruct -> nat]" ordinals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (lessp termination "(ordinals.<(ordinals.v, ordinals.w))" "nil"))) (ordinal?_TCC1 0 (ordinal?_TCC1-1 nil 3743354465 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[ordstruct -> nat]" ordstruct_adt nil) (size const-decl "[ordstruct -> nat]" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (ordinal? termination "ordinals.ordinal?(ordinals.u)" "nil"))) (ordinal?_TCC2 0 (ordinal?_TCC2-2 "" 3802910040 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[ordstruct -> nat]" ordstruct_adt nil) (size const-decl "[ordstruct -> nat]" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (ordinal? termination "ordinals.ordinal?(ordinals.v)" "nil")) (ordinal?_TCC2-1 nil 3237052399 ("" (skeep) (("" (replace -2) (("" (expand "size") (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[ordstruct -> nat]" ordstruct_adt nil) (size const-decl "[ordstruct -> nat]" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (ordinal? termination "ordinals.ordinal?(ordinals.v)" "nil"))) (ordinal_TCC1 0 (ordinal_TCC1-1 nil 3237052399 ("" (inst 1 "zero") (("" (assert) (("" (expand "ordinal?") (("" (propax) nil nil)) nil)) nil)) nil) ((zero adt-constructor-decl "(zero?)" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (ordinal? def-decl "bool" ordinals nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil)) nil (ordinal existence "" "{x: ordstruct_adt.ordstruct | ordinals.ordinal?(x)}"))) (ordinal_irreflexive 0 (ordinal_irreflexive-1 nil 3237052399 ("" (induct "r") (("1" (assert) nil nil) ("2" (flatten) (("2" (expand "<") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (expand "<" -4) (("3" (split -4) (("1" (assert) (("1" (expand "ordinal?" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "ordinal?" -4) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordinal nonempty-type-eq-decl nil ordinals nil) (ordstruct_induction formula-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (NOT const-decl "[bool -> bool]" booleans nil) (ordinal? def-decl "bool" ordinals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil)) nil)) (ordinal_antisym 0 (ordinal_antisym-1 nil 3237052399 ("" (induct "r") (("1" (assert) nil nil) ("2" (flatten) (("2" (skosimp*) (("2" (expand "<") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "ordinal?" -3) (("3" (flatten) (("3" (assert) (("3" (induct "s") (("1" (assert) nil nil) ("2" (flatten) (("2" (expand "<" -2) (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "ordinal?" -3) (("3" (flatten) (("3" (assert) (("3" (expand "<" -6) (("3" (split -6) (("1" (inst -8 "add2_var!2") (("1" (assert) (("1" (expand "<" -7) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "<" -8) (("2" (assert) (("2" (replace -1) (("2" (lemma "ordinal_irreflexive") (("2" (inst -1 "add2_var!2") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (expand "<" -9) (("3" (replace -1) (("3" (replace -2) (("3" (lemma "ordinal_irreflexive") (("3" (inst-cp -1 "add2_var!2") (("3" (assert) (("3" (inst -12 "add3_var!2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (ordinal_irreflexive formula-decl nil ordinals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordstruct_induction formula-decl nil ordstruct_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (< def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil)) nil)) (ordinal_antisymmetric 0 (ordinal_antisymmetric-1 nil 3237052399 ("" (skosimp) (("" (expand "<=") (("" (split) (("1" (split) (("1" (lemma "ordinal_antisym") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((<= const-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal_antisym formula-decl nil ordinals nil)) nil)) (ordinal_transitive 0 (ordinal_transitive-1 nil 3237052399 ("" (induct "s") (("1" (assert) nil nil) ("2" (flatten) (("2" (skosimp) (("2" (expand "<" -2) (("2" (lift-if -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "ordinal?" -3) (("3" (flatten) (("3" (assert) (("3" (hide -3 -4) (("3" (skosimp) (("3" (expand "<" -4) (("3" (lift-if) (("3" (split -4) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "<" -5) (("2" (lift-if) (("2" (split) (("1" (split) (("1" (flatten) (("1" (expand "<" 2) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "<" 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (assert) (("1" (prop) (("1" (assert) (("1" (expand "<" 4) (("1" (flatten) (("1" (assert) (("1" (inst -4 "exp(r!1)" "exp(t!1)") (("1" (assert) nil nil) ("2" (assert) (("2" (typepred "t!1") (("2" (expand "ordinal?" -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "r!1") (("3" (expand "ordinal?" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<" 4) (("2" (assert) nil nil)) nil) ("3" (expand "<" 4) (("3" (assert) nil nil)) nil) ("4" (expand "<" 5) (("4" (assert) (("4" (inst -4 "exp(r!1)" "exp(t!1)") (("1" (assert) nil nil) ("2" (typepred "t!1") (("2" (expand "ordinal?" -1) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "r!1") (("3" (expand "ordinal?" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "<" 5) (("5" (assert) nil nil)) nil) ("6" (expand "<" 5) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (split -5) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide -6) (("2" (prop) (("1" (assert) (("1" (expand "<" 4) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "<" 4) (("2" (assert) nil nil)) nil) ("3" (expand "<" 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "<" 3) (("3" (assert) (("3" (hide -4) (("3" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -8 "rest(r!1)" "rest(t!1)") (("1" (assert) nil nil) ("2" (typepred "t!1") (("2" (expand "ordinal?" -1) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "r!1") (("3" (expand "ordinal?" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (t!1 skolem-const-decl "ordinal" ordinals nil) (r!1 skolem-const-decl "ordinal" ordinals nil) (exp adt-accessor-decl "[(nonzero?) -> ordstruct]" ordstruct_adt nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest adt-accessor-decl "[(nonzero?) -> ordstruct]" ordstruct_adt nil) (ordstruct_induction formula-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil)) nil)) (ordinal_trichotomy 0 (ordinal_trichotomy-1 nil 3237052399 ("" (induct "r") (("1" (assert) nil nil) ("2" (flatten) (("2" (induct "s") (("1" (assert) nil nil) ("2" (skosimp) (("2" (expand "ordinal?" -3) (("2" (flatten) (("2" (assert) (("2" (expand "<" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "ordinal?" -3) (("3" (flatten) (("3" (assert) (("3" (induct "s") (("1" (assert) nil nil) ("2" (flatten) (("2" (expand "<" 3) (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (assert) (("3" (expand "ordinal?" -3) (("3" (flatten) (("3" (assert) (("3" (expand "<" 1) (("3" (flatten) (("3" (expand "<" 5) (("3" (flatten) (("3" (inst -6 "add2_var!2") (("3" (assert) (("3" (replace -6) (("3" (assert) (("3" (hide -3 -4 1 5) (("3" (hide -6 -7) (("3" (inst -5 "add3_var!2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero adt-constructor-decl "(zero?)" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (ordstruct_induction formula-decl nil ordstruct_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (< def-decl "bool" ordinals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil)) nil)) (well_founded_le 0 (well_founded_le-1 nil 3237052399 ("" (expand "well_founded?") (("" (lemma "ordinal_induction") (("" (skosimp) (("" (skosimp) (("" (inst -1 "LAMBDA (x:ordinal): NOT p!1(x)") (("" (split) (("1" (inst -1 "y!1") nil nil) ("2" (skosimp) (("2" (inst 1 "r!1") (("2" (skosimp) (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordinal_induction formula-decl nil ordinals nil) (p!1 skolem-const-decl "pred[(ordinal?)]" ordinals nil) (r!1 skolem-const-decl "ordinal" ordinals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ordstruct type-decl nil ordstruct_adt nil) (well_founded? const-decl "bool" orders nil)) nil)))(lex2 (lex2_TCC1 0 (lex2_TCC1-1 nil 3237052399 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((ordinal? def-decl "bool" ordinals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (lex2 subtype "ordstruct_adt.zero" "ordinal"))) (lex2_TCC2 0 (lex2_TCC2-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (lex2 subtype "lex2.n" "posnat"))) (lex2_TCC3 0 (lex2_TCC3-1 nil 3237052399 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((ordinal? def-decl "bool" ordinals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (lex2 subtype "ordstruct_adt.add(lex2.n, ordstruct_adt.zero, ordstruct_adt.zero)" "ordinal"))) (lex2_TCC4 0 (lex2_TCC4-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (lex2 subtype "lex2.m" "posnat"))) (lex2_TCC5 0 (lex2_TCC5-1 nil 3237052399 ("" (grind) nil nil) ((ordinal? def-decl "bool" ordinals nil)) nil (lex2 subtype "ordstruct_adt.add(lex2.m, ordstruct_adt.add(1, ordstruct_adt.zero, ordstruct_adt.zero), ordstruct_adt.zero)" "ordinal"))) (lex2_TCC6 0 (lex2_TCC6-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (lex2 subtype "lex2.m" "posnat"))) (lex2_TCC7 0 (lex2_TCC7-1 nil 3237052399 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (lex2 subtype "lex2.n" "posnat"))) (lex2_TCC8 0 (lex2_TCC8-1 nil 3237052399 ("" (grind) nil nil) ((ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil)) nil (lex2 subtype "ordstruct_adt.add(lex2.m, ordstruct_adt.add(1, ordstruct_adt.zero, ordstruct_adt.zero), ordstruct_adt.add(lex2.n, ordstruct_adt.zero, ordstruct_adt.zero))" "ordinal"))) (lex2_lt 0 (lex2_lt-1 nil 3237052399 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< def-decl "bool" ordinals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lex2 const-decl "ordinal" lex2 nil)) nil)))(lex3 (lex3_TCC1 0 (lex3_TCC1-1 nil 3768751962 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (lex3 subtype "lex3.m" "posnat"))) (lex3_TCC2 0 (lex3_TCC2-1 nil 3768751962 ("" (skeep) (("" (expand "ordinal?") (("" (grind) nil nil)) nil)) nil) ((ordinal? def-decl "bool" ordinals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (lex2 const-decl "ordinal" lex2 nil) (< def-decl "bool" ordinals nil)) nil (lex3 subtype "ordstruct_adt.add(lex3.m, ordstruct_adt.add(2, ordstruct_adt.add(2, ordstruct_adt.zero, ordstruct_adt.zero), ordstruct_adt.zero), lex2.lex2(lex3.n, lex3.p))" "ordinal"))) (wtf? 0 (wtf?-1 nil 3768765387 ("" (decompose-equality) nil nil) ((rest adt-accessor-decl "[(nonzero?) -> ordstruct]" ordstruct_adt nil) (exp adt-accessor-decl "[(nonzero?) -> ordstruct]" ordstruct_adt nil) (zero adt-constructor-decl "(zero?)" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (coef adt-accessor-decl "[(nonzero?) -> posnat]" ordstruct_adt nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (ordstruct type-decl nil ordstruct_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (lex3_lt 0 (lex3_lt-1 nil 3768752051 ("" (skeep) (("" (grind-with-ext) (("1" (name "A" "add(1, zero, zero)") (("1" (name "B" "add(2, add(2, zero, zero), zero)") (("1" (replace -1 * LR) (("1" (replace -2 * LR) (("1" (case "1 = 2") (("1" (assert) nil nil) ("2" (hide 2 3 4 5 6) (("2" (hide -7 -5 -4 -3) (("2" (case "coef(A) = 1") (("1" (case "coef(B) = 2") (("1" (replace -5 -1 LR) (("1" (assert) nil nil)) nil) ("2" (grind) (("2" (replace -2 1 RL) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -2 1 RL) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "wtf?") (("2" (propax) nil nil)) nil) ("3" (lemma "wtf?") (("3" (propax) nil nil)) nil) ("4" (lemma "wtf?") (("4" (propax) nil nil)) nil) ("5" (lemma "wtf?") (("5" (propax) nil nil)) nil) ("6" (lemma "wtf?") (("6" (propax) nil nil)) nil) ("7" (lemma "wtf?") (("7" (propax) nil nil)) nil) ("8" (lemma "wtf?") (("8" (propax) nil nil)) nil)) nil)) nil) ((< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (lex3 const-decl "ordinal" lex3 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (coef adt-accessor-decl "[(nonzero?) -> posnat]" ordstruct_adt nil) (ordstruct type-decl nil ordstruct_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (zero adt-constructor-decl "(zero?)" ordstruct_adt nil) (wtf? formula-decl nil lex3 nil)) shostak)))(lex4 (lex4_TCC1 0 (lex4_TCC1-1 nil 3768930415 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (lex4 subtype "lex4.m" "posnat"))) (lex4_TCC2 0 (lex4_TCC2-1 nil 3768930415 ("" (skeep) (("" (expand "lex3") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex3 const-decl "ordinal" lex3 nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lex4 subtype "ordstruct_adt.add(lex4.m, ordstruct_adt.add(3, ordstruct_adt.add(2, ordstruct_adt.add(1, ordstruct_adt.zero, ordstruct_adt.zero), ordstruct_adt.zero), ordstruct_adt.zero), lex3.lex3(lex4.n, lex4.p, lex4.q))" "ordinal"))) (wtf? 0 (wtf?-1 nil 3768930878 ("" (case "coef(add(1, zero, zero)) = 1") (("1" (case "coef(add(3, add(2, add(1, zero, zero), zero), zero)) = 3") (("1" (replace -3 -2 RL) (("1" (replace -1 -2 LR) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (ordstruct type-decl nil ordstruct_adt nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (coef adt-accessor-decl "[(nonzero?) -> posnat]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (zero adt-constructor-decl "(zero?)" ordstruct_adt nil)) shostak)) (same_coefs 0 (same_coefs-1 nil 3768931344 ("" (skeep) (("" (grind) nil nil)) nil) nil shostak)) (lex4_lt 0 (lex4_lt-1 nil 3768930553 ("" (skeep) (("" (grind) (("1" (hide -1 -2 -3 -4 -5 -7 1 2 3 4 5) (("1" (name-replace "B" "add(1, zero, zero)") (("1" (name-replace "A" "add(3, add(2, B, zero), zero)") (("1" (case "coef(A) = 3") (("1" (case "coef(B) = 1") (("1" (replace -3 -2 LR) (("1" (assert) nil nil)) nil) ("2" (grind) (("2" (reveal -2) (("2" (replace -1 1 RL) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (replace -1 1 RL) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "same_coefs") (("2" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "same_coefs") (("3" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "same_coefs") (("4" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "same_coefs") (("5" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("5" (assert) nil nil)) nil)) nil) ("6" (lemma "same_coefs") (("6" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("6" (assert) nil nil)) nil)) nil) ("7" (lemma "same_coefs") (("7" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("7" (assert) nil nil)) nil)) nil) ("8" (lemma "same_coefs") (("8" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("8" (assert) nil nil)) nil)) nil) ("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("9" (assert) (("9" (lemma "same_coefs") (("9" (assert) (("9" (lemma "same_coefs") (("9" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (lemma "same_coefs") (("10" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("10" (assert) nil nil)) nil)) nil) ("11" (lemma "same_coefs") (("11" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("11" (assert) nil nil)) nil)) nil) ("12" (lemma "same_coefs") (("12" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("12" (assert) nil nil)) nil)) nil) ("13" (lemma "same_coefs") (("13" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("13" (assert) (("13" (lemma "same_coefs") (("13" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("13" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("14" (lemma "same_coefs") (("14" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("14" (assert) nil nil)) nil)) nil) ("15" (lemma "same_coefs") (("15" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("15" (assert) nil nil)) nil)) nil) ("16" (lemma "same_coefs") (("16" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("16" (assert) nil nil)) nil)) nil) ("17" (lemma "same_coefs") (("17" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("17" (assert) (("17" (lemma "same_coefs") (("17" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("17" (assert) (("17" (lemma "same_coefs") (("17" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("17" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("18" (lemma "same_coefs") (("18" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("18" (assert) nil nil)) nil)) nil) ("19" (lemma "same_coefs") (("19" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("19" (assert) nil nil)) nil)) nil) ("20" (lemma "same_coefs") (("20" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("20" (assert) nil nil)) nil)) nil) ("21" (lemma "same_coefs") (("21" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("21" (assert) nil nil)) nil)) nil) ("22" (lemma "same_coefs") (("22" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("22" (assert) (("22" (lemma "same_coefs") (("22" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("22" (assert) (("22" (lemma "same_coefs") (("22" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("22" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("23" (lemma "same_coefs") (("23" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("23" (assert) (("23" (lemma "same_coefs") (("23" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("23" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("24" (lemma "same_coefs") (("24" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("24" (assert) nil nil)) nil)) nil) ("25" (lemma "same_coefs") (("25" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("25" (assert) (("25" (lemma "same_coefs") (("25" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("25" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("26" (lemma "same_coefs") (("26" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("26" (assert) nil nil)) nil)) nil) ("27" (lemma "same_coefs") (("27" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("27" (assert) nil nil)) nil)) nil) ("28" (lemma "same_coefs") (("28" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("28" (assert) nil nil)) nil)) nil) ("29" (lemma "same_coefs") (("29" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("29" (assert) nil nil)) nil)) nil) ("30" (lemma "same_coefs") (("30" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("30" (assert) nil nil)) nil)) nil) ("31" (lemma "same_coefs") (("31" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("31" (assert) (("31" (lemma "same_coefs") (("31" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("31" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("32" (lemma "same_coefs") (("32" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("32" (assert) (("32" (lemma "same_coefs") (("32" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("32" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("33" (lemma "same_coefs") (("33" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("33" (assert) nil nil)) nil)) nil) ("34" (lemma "same_coefs") (("34" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("34" (assert) (("34" (lemma "same_coefs") (("34" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("34" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("35" (lemma "same_coefs") (("35" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("35" (assert) nil nil)) nil)) nil) ("36" (lemma "same_coefs") (("36" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("36" (assert) nil nil)) nil)) nil) ("37" (lemma "same_coefs") (("37" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("37" (assert) nil nil)) nil)) nil) ("38" (lemma "same_coefs") (("38" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("38" (assert) nil nil)) nil)) nil) ("39" (lemma "same_coefs") (("39" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("39" (assert) nil nil)) nil)) nil) ("40" (lemma "same_coefs") (("40" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("40" (assert) nil nil)) nil)) nil) ("41" (lemma "same_coefs") (("41" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("41" (assert) nil nil)) nil)) nil) ("42" (lemma "same_coefs") (("42" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("42" (assert) (("42" (lemma "same_coefs") (("42" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("42" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("43" (lemma "same_coefs") (("43" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("43" (assert) (("43" (lemma "same_coefs") (("43" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("43" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("44" (lemma "same_coefs") (("44" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("44" (assert) (("44" (lemma "same_coefs") (("44" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("44" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("45" (lemma "same_coefs") (("45" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("45" (assert) nil nil)) nil)) nil) ("46" (lemma "same_coefs") (("46" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("46" (assert) (("46" (lemma "same_coefs") (("46" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("46" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("47" (lemma "same_coefs") (("47" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("47" (assert) (("47" (lemma "same_coefs") (("47" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("47" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("48" (lemma "same_coefs") (("48" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("48" (assert) (("48" (lemma "same_coefs") (("48" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("48" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("49" (lemma "same_coefs") (("49" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("49" (assert) (("49" (lemma "same_coefs") (("49" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("49" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("50" (lemma "same_coefs") (("50" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("50" (assert) nil nil)) nil)) nil) ("51" (lemma "same_coefs") (("51" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("51" (assert) nil nil)) nil)) nil) ("52" (lemma "same_coefs") (("52" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("52" (assert) (("52" (lemma "same_coefs") (("52" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("52" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("53" (lemma "same_coefs") (("53" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("53" (assert) (("53" (lemma "same_coefs") (("53" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("53" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("54" (lemma "same_coefs") (("54" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("54" (assert) (("54" (lemma "same_coefs") (("54" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("54" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("55" (lemma "same_coefs") (("55" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("55" (assert) nil nil)) nil)) nil) ("56" (lemma "same_coefs") (("56" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(2, add(2, zero, zero), zero)") (("56" (assert) nil nil)) nil)) nil) ("57" (lemma "same_coefs") (("57" (inst -1 "add(3, add(2, add(1, zero, zero), zero), zero)" "add(1, zero, zero)") (("57" (assert) nil nil)) nil)) nil)) nil)) nil) ((< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (lex3 const-decl "ordinal" lex3 nil) (lex4 const-decl "ordinal" lex4 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ordstruct type-decl nil ordstruct_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonzero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (add adt-constructor-decl "[[posnat, ordstruct, ordstruct] -> (nonzero?)]" ordstruct_adt nil) (zero? adt-recognizer-decl "[ordstruct -> boolean]" ordstruct_adt nil) (zero adt-constructor-decl "(zero?)" ordstruct_adt nil) (coef adt-accessor-decl "[(nonzero?) -> posnat]" ordstruct_adt nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (same_coefs formula-decl nil lex4 nil)) shostak)))(list)(list_props (length_TCC1 0 (length_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[list -> nat]" list_adt nil)) nil (length termination "list_props.length(list_props.y)" "nil"))) (member_TCC1 0 (member_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (member termination "list_props.member(list_props.x, list_props.tl)" "nil"))) (member_null 0 (member_null-1 nil 3237052399 ("" (grind :if-match nil) nil nil) ((member def-decl "bool" list_props nil)) nil)) (nth_TCC1 0 (nth_TCC1-1 nil 3237052399 ("" (skosimp) (("" (typepred "n!1") (("" (expand "length") (("" (assert) nil nil)) nil)) nil)) nil) ((below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth subtype "list_props.l" "(list_adt[list_props.T].cons?)"))) (nth_TCC2 0 (nth_TCC2-1 nil 3237052399 ("" (skosimp) (("" (typepred "n!1") (("" (expand "length") (("" (assert) nil nil)) nil)) nil)) nil) ((below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth subtype "list_props.l" "(list_adt[list_props.T].cons?)"))) (nth_TCC3 0 (nth_TCC3-1 nil 3237052399 ("" (induct "l") (("1" (skosimp*) (("1" (typepred "n!1") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (typepred "n!1") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (typepred "n!1") (("3" (expand "length" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (nth subtype "(number_fields.-)(list_props.n, 1)" "below[length(cdr[T](l))]"))) (nth_TCC4 0 (nth_TCC4-1 nil 3237052399 ("" (induct "l") (("1" (skosimp*) (("1" (typepred "n!1") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "length" 2 2) (("2" (assert) (("2" (expand "<") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (typepred "n!1") (("3" (expand "length" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (nth termination "list_props.nth(list_adt[list_props.T].cdr(list_props.l), (number_fields.-)(list_props.n, 1))" "nil"))) (append_TCC1 0 (append_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (append termination "list_props.append(list_props.y, list_props.l2)" "nil"))) (append_null 0 (append_null-1 nil 3237052399 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp) (("2" (expand "append" +) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) nil)) (append_assoc 0 (append_assoc-1 nil 3237052399 ("" (induct-and-simplify "l1") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (reverse_append 0 (reverse_append-1 nil 3237052399 ("" (induct-and-simplify "l1") (("1" (rewrite "append_null") nil nil) ("2" (replace -1) (("2" (rewrite "append_assoc" :dir rl) nil nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append_assoc formula-decl nil list_props nil) (append_null formula-decl nil list_props nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (reverse_reverse 0 (reverse_reverse-1 nil 3237052399 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp) (("2" (expand "reverse" 1 2) (("2" (rewrite "reverse_append") (("2" (expand "reverse" 1 1) (("2" (replace -1) (("2" (expand "reverse" 1 1) (("2" (expand "append" 1 2) (("2" (expand "append" 1 1) (("2" (expand "append" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reverse_append formula-decl nil list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (append def-decl "list[T]" list_props nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (reverse def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) nil)) (length_append 0 (length_append-1 nil 3237052399 ("" (induct-and-simplify "l1") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (append def-decl "list[T]" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (length_reverse 0 (length_reverse-1 nil 3237052399 ("" (induct-and-simplify "l") (("" (rewrite "length_append") (("" (assert) nil nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (member_nth 0 (member_nth-1 nil 3726208660 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "member" +) (("2" (expand "nth" +) (("2" (prop) (("1" (inst 1 "0") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (inst? -2) (("2" (assert) (("2" (skeep) (("2" (inst 1 "i + 1") (("1" (assert) nil nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lift-if) (("3" (prop) (("3" (inst?) (("3" (assert) (("3" (inst 4 "i - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons2_var skolem-const-decl "list[T]" list_props nil) (cons1_var skolem-const-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below(length(cons2_var))" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (nth_append_TCC1 0 (nth_append_TCC1-1 nil 3728604386 ("" (skeep :preds? t) (("" (use "length_append") (("" (assert) nil nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (nth_append subtype "(number_fields.-)(list_props.i, list_props.length(list_props.l1))" "below[length(l2)]"))) (nth_append 0 (nth_append-1 nil 3726090057 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "append" 1 1) (("2" (expand "nth" 1 1) (("2" (expand "length" 1) (("2" (expand "nth" 1 2) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (inst?) (("1" (assert) (("1" (lift-if) (("1" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (rewrite "length_append") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons1_var skolem-const-decl "T" list_props nil) (cons2_var skolem-const-decl "list[T]" list_props nil) (l2 skolem-const-decl "list[T]" list_props nil) (i skolem-const-decl "below(length(append(cons(cons1_var, cons2_var), l2)))" list_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (append def-decl "list[T]" list_props nil) (below type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (nth_reverse_TCC1 0 (nth_reverse_TCC1-1 nil 3737147970 ("" (skeep) (("" (rewrite "length_reverse") (("" (assert) nil nil)) nil)) nil) ((length_reverse formula-decl nil list_props nil) (T formal-type-decl nil list_props nil) (list type-decl nil list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (nth_reverse subtype "list_props.i" "below[length(reverse(l1))]"))) (nth_reverse_TCC2 0 (nth_reverse_TCC2-1 nil 3737147970 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak (nth_reverse subtype "(number_fields.-)((number_fields.-)(list_props.length(list_props.l1), list_props.i), 1)" "below[length(l1)]"))) (nth_reverse 0 (nth_reverse-1 nil 3743356767 ("" (induct "l1") (("1" (skeep :preds? t) (("1" (expand "length" -) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep :preds? t) (("2" (expand "reverse" 1) (("2" (expand "length" -1) (("2" (expand "length" 1) (("2" (expand "nth" 1 2) (("2" (lift-if) (("2" (assert) (("2" (split 1) (("1" (flatten) (("1" (use "nth_append") (("1" (replace -1 :hide? t) (("1" (rewrite "length_reverse") (("1" (assert) (("1" (expand "nth" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "i") (("1" (use "nth_append") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lift-if) (("1" (rewrite "length_reverse") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite "length_reverse") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((nth_append formula-decl nil list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (append def-decl "list[T]" list_props nil) (length_reverse formula-decl nil list_props nil) (cons1_var skolem-const-decl "T" list_props nil) (cons2_var skolem-const-decl "list[T]" list_props nil) (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (reverse def-decl "list[T]" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (list_rep 0 (list_rep-1 nil 3237052399 ("" (assert) nil nil) nil nil)) (every_unc_eq_cur 0 (every_unc_eq_cur-1 nil 3726081149 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) shostak)) (every_append 0 (every_append-1 nil 3237052399 ("" (induct-and-simplify "l1") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (append def-decl "list[T]" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (every_disjunct1 0 (every_disjunct1-1 nil 3237052399 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (every_disjunct2 0 (every_disjunct2-1 nil 3237052399 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (every_conjunct 0 (every_conjunct-1 nil 3237052399 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (every_conjunct2 0 (every_conjunct2-1 nil 3563249664 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp) (("2" (skosimp) (("2" (expand "every" 1) (("2" (inst? -1) (("2" (assert) (("2" (expand "every" (-2 -3)) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (every_member 0 (every_member-1 nil 3237052399 ("" (induct-and-simplify "l") (("" (rewrite "every_disjunct2") nil nil)) nil) ((every_disjunct2 formula-decl nil list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil list_props nil) (list_induction formula-decl nil list_adt nil)) nil)) (every_nth 0 (every_nth-1 nil 3413400046 ("" (induct "l") (("1" (expand "every") (("1" (skosimp*) (("1" (typepred "i!1") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (expand "nth" 1) (("2" (inst?) (("2" (ground) (("1" (skosimp*) (("1" (inst - "i!1 - 1") (("1" (assert) nil nil) ("2" (ground) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "0") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil) ("3" (inst - "0") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst - "i!1 + 1") (("1" (assert) nil nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons1_var!1 skolem-const-decl "T" list_props nil) (cons2_var!1 skolem-const-decl "list[T]" list_props nil) (i!1 skolem-const-decl "below(length(cons(cons1_var!1, cons2_var!1)))" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i!1 skolem-const-decl "below(length(cons2_var!1))" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every adt-def-decl "boolean" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)))(map_props (map_list_composition 0 (map_list_composition-1 nil 3237052399 ("" (induct "l") (("1" (skosimp) (("1" (expand "map") (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst?) (("2" (expand "map" +) (("2" (replace -1) (("2" (expand "o" 1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil map_props nil) (O const-decl "T3" function_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (= const-decl "[T, T -> boolean]" equalities nil) (T3 formal-type-decl nil map_props nil) (T2 formal-type-decl nil map_props nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) nil)) (map_seq_composition 0 (map_seq_composition-1 nil 3237052399 ("" (skosimp) (("" (expand "map") (("" (apply-extensionality) (("" (hide 2) (("" (expand "o") (("" (case "nth((LAMBDA (n: nat): f1!1(nth(s!1, n))), x!1) = f1!1(nth(s!1, x!1))") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (expand "nth" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((map const-decl "sequence[R]" seq_functions nil) (= const-decl "[T, T -> boolean]" equalities nil) (T2 formal-type-decl nil map_props nil) (sequence type-eq-decl nil sequences nil) (nth const-decl "T" sequences nil) (T1 formal-type-decl nil map_props nil) (O const-decl "T3" function_props nil) (T3 formal-type-decl nil map_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)))(more_map_props (map_length 0 (map_length-1 nil 3332188055 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "length" +) (("2" (expand "map" 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil more_map_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (T2 formal-type-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (map_nth_rw_TCC1 0 (map_nth_rw_TCC1-1 nil 3425150436 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "map" 1) (("2" (expand "length" 1) (("2" (typepred "i!1") (("2" (expand "length" -1) (("2" (inst -2 "f!1" "i!1 - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "below(length[T1](cons(cons1_var!1, cons2_var!1)))" more_map_props nil) (cons2_var!1 skolem-const-decl "list[T1]" more_map_props nil) (cons1_var!1 skolem-const-decl "T1" more_map_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil more_map_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (T2 formal-type-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak (map_nth_rw subtype "more_map_props.i" "below[length[T2](map[T1, T2](f)(l))]"))) (map_nth_rw 0 (map_nth_rw-1 nil 3413399995 ("" (induct "l") (("1" (skosimp*) (("1" (typepred "i!1") (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (inst - "i!1-1") (("1" (expand "map" 1) (("1" (expand "nth" 1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (split) (("1" (assert) (("1" (case "i!1=0") (("1" (replace -1) (("1" (expand "map") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred "i!1") (("2" (assert) (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (rewrite "map_length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((map_length formula-decl nil more_map_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons1_var!1 skolem-const-decl "T1" more_map_props nil) (cons2_var!1 skolem-const-decl "list[T1]" more_map_props nil) (i!1 skolem-const-decl "below(length(cons(cons1_var!1, cons2_var!1)))" more_map_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil more_map_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (T2 formal-type-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (map adt-def-decl "list[T1]" list_adt_map nil)) shostak)) (map_unc_eq_cur 0 (map_unc_eq_cur-1 nil 3726088287 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (T2 formal-type-decl nil more_map_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (map adt-def-decl "list[T1]" list_adt_map nil) (map adt-def-decl "list[T1]" list_adt_map nil) (T1 formal-type-decl nil more_map_props nil) (list_induction formula-decl nil list_adt nil)) shostak)) (every_map 0 (every_map-1 nil 3726087213 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "every" +) (("2" (lift-if) (("2" (expand "map" 1 1) (("2" (iff) (("2" (prop) (("1" (expand "map" -1) (("1" (expand "o" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "map" -2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "map" +) (("3" (expand "o" -1) (("3" (propax) nil nil)) nil)) nil) ("4" (expand "map" +) (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil more_map_props nil) (O const-decl "T3" function_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (T2 formal-type-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (map_append 0 (map_append-1 nil 3728789957 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "append" 1 1) (("2" (expand "map" 1 1) (("2" (expand "map" 1 2) (("2" (expand "append" 1 2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T1 formal-type-decl nil more_map_props nil) (append def-decl "list[T]" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (= const-decl "[T, T -> boolean]" equalities nil) (T2 formal-type-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)))(filters (filter_TCC1 0 (filter_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (filter termination "filters.filter(filters.y, filters.p)" "nil"))) (filter_TCC2 0 (filter_TCC2-1 nil 3237052399 ("" (skosimp) (("" (replace -1) (("" (expand "length" 2 2) (("" (expand "<") (("" (assert) (("" (expand "restrict") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (filter termination "filters.filter(filters.y, filters.p)" "nil"))))(list2finseq (finseq2list_rec_TCC1 0 (finseq2list_rec_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (finseq2list_rec subtype "(number_fields.-)(length(list2finseq.fs), list2finseq.n)" "below[fs`length]"))) (finseq2list_rec_TCC2 0 (finseq2list_rec_TCC2-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (finseq2list_rec subtype "(number_fields.-)(list2finseq.n, 1)" "{n: naturalnumbers.nat | reals.<=(n, length(list2finseq.fs))}"))) (finseq2list_rec_TCC3 0 (finseq2list_rec_TCC3-1 nil 3237052399 ("" (tcc :defs !) nil nil) nil nil (finseq2list_rec termination "list2finseq.finseq2list_rec(list2finseq.fs, (number_fields.-)(list2finseq.n, 1))" "nil"))) (finseq2list_TCC1 0 (finseq2list_TCC1-1 nil 3237052399 ("" (tcc :defs explicit) nil nil) nil nil (finseq2list subtype "length(list2finseq.fs)" "{n: naturalnumbers.nat | reals.<=(n, length(list2finseq.fs))}"))) (finseq2list_length_rec 0 (finseq2list_length_rec-1 nil 3703275952 ("" (induct n) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil list2finseq nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (finseq2list_length 0 (finseq2list_length-1 nil 3726081197 ("" (skeep) (("" (expand "finseq2list") (("" (use "finseq2list_length_rec") (("" (assert) nil nil)) nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (finseq2list_length_rec formula-decl nil list2finseq nil)) shostak)) (finseq2list_nth_rec_TCC1 0 (finseq2list_nth_rec_TCC1-1 nil 3717231008 ("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "finseq2list_rec" +) (("2" (expand "length" 1 1) (("2" (inst -1 "fs" "i - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil list2finseq nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (finseq2list_nth_rec subtype "list2finseq.i" "below[length[T](finseq2list_rec(fs, n))]"))) (finseq2list_nth_rec_TCC2 0 (finseq2list_nth_rec_TCC2-1 nil 3717231008 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (finseq2list_nth_rec subtype "(number_fields.+)((number_fields.-)(list2finseq.fs`length, list2finseq.n), list2finseq.i)" "below[fs`length]"))) (finseq2list_nth_rec 0 (finseq2list_nth_rec-1 nil 3728793728 ("" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "finseq2list_rec" 1) (("2" (expand "nth" 1) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (inst -1 "fs" "i - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (hide 2) (("4" (induct "n") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "finseq2list_rec" 1) (("2" (expand "length" 1 1) (("2" (inst -1 "fs" "i - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "nat" list2finseq nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "nat" list2finseq nil) (nat_induction formula-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (finseq2list_nth_TCC1 0 (finseq2list_nth_TCC1-1 nil 3717231008 ("" (skeep) (("" (expand "finseq2list") (("" (lemma "finseq2list_nth_rec_TCC1") (("" (inst -1 "fs" _ "fs`length") (("" (typepred "i") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (finseq2list_nth_rec_TCC1 subtype-tcc nil list2finseq nil)) shostak (finseq2list_nth subtype "list2finseq.i" "below[length[T](finseq2list(fs))]"))) (finseq2list_nth 0 (finseq2list_nth-1 nil 3728794623 ("" (skeep) (("" (expand "finseq2list") (("" (use "finseq2list_nth_rec") (("" (assert) nil nil)) nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (finseq2list_nth_rec formula-decl nil list2finseq nil)) shostak)) (list2finseq_finseq2list 0 (list2finseq_finseq2list-1 nil 3728795134 ("" (skeep) (("" (apply-extensionality :hide? t) (("1" (expand "list2finseq") (("1" (use "finseq2list_length") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (expand "list2finseq") (("2" (use "finseq2list_nth") nil nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (finseq2list_length formula-decl nil list2finseq nil) (finseq2list_nth formula-decl nil list2finseq nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (list2finseq_inj 0 (list2finseq_inj-1 nil 3728832271 ("" (induct l1) (("1" (skeep) (("1" (iff) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (iff) (("2" (split) (("1" (flatten) (("1" (decompose-equality +) (("1" (case-replace "car(l2) = list2finseq(l2)`seq(0)") (("1" (replace -2 :dir RL) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (inst -2 "cdr(l2)") (("2" (replace -2 :dir RL) (("2" (delete -2) (("2" (decompose-equality) (("1" (case "cons?(l2)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (case "cons?(l2)") (("1" (decompose-equality) (("1" (expand list2finseq) (("1" (expand nth -) (("1" (flatten) (("1" (grind) (("1" (decompose-equality) (("1" (inst -1 "x!1 + 1") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (l2 skolem-const-decl "list[T]" list2finseq nil) (nth def-decl "T" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (cons2_var skolem-const-decl "list[T]" list2finseq nil) (x!1 skolem-const-decl "below[list2finseq(cons2_var)`length]" list2finseq nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (finseq2list_list2finseq 0 (finseq2list_list2finseq-1 nil 3728842466 ("" (skeep) (("" (case "list2finseq(finseq2list(list2finseq(l))) = list2finseq(l)") (("1" (rewrite list2finseq_inj) nil nil) ("2" (rewrite list2finseq_finseq2list) nil nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil list2finseq nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list2finseq_inj formula-decl nil list2finseq nil) (list2finseq_finseq2list formula-decl nil list2finseq nil)) shostak)) (fseq_lem 0 (fseq_lem-1 nil 3835459233 ("" (induct "l1") (("1" (induct "l2") (("1" (grind) nil nil)) nil) ("2" (skosimp) (("2" (skosimp) (("2" (inst -1 "cdr(l2!1)") (("1" (iff) (("1" (prop) (("1" (assert) (("1" (apply-extensionality) (("1" (expand "list2finseq" -1) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (expand "list2finseq" -1) (("3" (expand "list2finseq" 3) (("3" (flatten) (("3" (split) (("1" (expand "length" -1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality) (("1" (decompose-equality -2) (("1" (inst -1 "x!1+1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "length" -1) (("2" (lift-if) (("2" (split -1) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil) ("2" (iff) (("2" (prop) (("1" (expand "list2finseq") (("1" (flatten) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (l2!1 skolem-const-decl "list[T]" list2finseq nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons1_var!1 skolem-const-decl "T" list2finseq nil) (cons2_var!1 skolem-const-decl "list[T]" list2finseq nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "below[length(cons2_var!1)]" list2finseq nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (cons_lem 0 (cons_lem-1 nil 3835459706 ("" (grind :if-match nil) (("1" (decompose-equality -) nil nil) ("2" (decompose-equality -) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil list2finseq nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)) shostak)))(list2set (list2set_TCC1 0 (list2set_TCC1-1 nil 3237052399 ("" (tcc :defs !) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (list2set termination "list2set.list2set(list2set.y)" "nil"))))(disjointness (pairwise_disjoint?_TCC1 0 (pairwise_disjoint?_TCC1-1 nil 3237052399 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (pairwise_disjoint? termination "disjointness.pairwise_disjoint?(disjointness.y)" "nil"))))(character)(strings (char_lem 0 (char_lem-1 nil 3237052399 ("" (grind :if-match nil) (("" (apply-extensionality :hide? t) nil nil)) nil) ((character_char_extensionality formula-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil)) nil)))(gen_strings (length_empty 0 (length_empty-1 nil 3835500565 ("" (grind) nil nil) ((empty const-decl "string" gen_strings nil)) shostak)) (length_unit 0 (length_unit-1 nil 3835500580 ("" (grind) nil nil) ((unit const-decl "string" gen_strings nil)) shostak)) (unit_ax_TCC1 0 (unit_ax_TCC1-1 nil 3820375898 ("" (skeep) (("" (rewrite "length_unit") (("" (assert) nil nil)) nil)) nil) ((length_unit formula-decl nil gen_strings nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (unit_ax subtype "0" "naturalnumbers.below(length(gen_strings.unit(gen_strings.c)))"))) (unit_ax 0 (unit_ax-1 nil 3835500600 ("" (grind) nil nil) ((unit const-decl "string" gen_strings nil) (get const-decl "char" gen_strings nil)) shostak)) (extensionality_TCC1 0 (extensionality_TCC1-1 nil 3820375898 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (extensionality subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s2))"))) (extensionality 0 (extensionality-1 nil 3835500627 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (below type-eq-decl nil naturalnumbers nil) (get const-decl "char" gen_strings nil)) shostak)) (length_concat 0 (length_concat-1 nil 3835502626 ("" (grind) nil nil) ((O const-decl "finseq" finite_sequences nil)) shostak)) (char_concat_TCC1 0 (char_concat_TCC1-1 nil 3820376026 ("" (skeep :preds? t) (("" (rewrite "length_concat") nil nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_concat formula-decl nil gen_strings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil)) nil (char_concat subtype "gen_strings.i" "naturalnumbers.below(length(finite_sequences[char].o(gen_strings.s1, gen_strings.s2)))"))) (char_concat_TCC2 0 (char_concat_TCC2-1 nil 3820376026 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (char_concat subtype "(number_fields.-)(gen_strings.i, length(gen_strings.s1))" "naturalnumbers.below(length(gen_strings.s2))"))) (char_concat 0 (char_concat-1 nil 3835502648 ("" (grind) nil nil) ((O const-decl "finseq" finite_sequences nil) (get const-decl "char" gen_strings nil)) shostak)) (strdiff_rec_TCC1 0 (strdiff_rec_TCC1-1 nil 3835419903 ("" (subtype-tcc) nil nil) ((nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil)) shostak (strdiff_rec subtype "(number_fields.-)(real_defs.min(length(gen_strings.s1), length(gen_strings.s2)), gen_strings.i)" "naturalnumber"))) (strdiff_rec_TCC2 0 (strdiff_rec_TCC2-1 nil 3835419903 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s1))"))) (strdiff_rec_TCC3 0 (strdiff_rec_TCC3-1 nil 3835419903 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s2))"))) (strdiff_rec_TCC4 0 (strdiff_rec_TCC4-1 nil 3835419903 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec subtype "(number_fields.+)(gen_strings.i, 1)" "naturalnumbers.upto(real_defs.min(length(gen_strings.s1), length(gen_strings.s2)))"))) (strdiff_rec_TCC5 0 (strdiff_rec_TCC5-1 nil 3835419903 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "char" gen_strings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec termination "gen_strings.strdiff_rec(gen_strings.s1, gen_strings.s2, (number_fields.+)(gen_strings.i, 1))" "nil"))) (strdiff_TCC1 0 (strdiff_TCC1-1 nil 3835419903 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (strdiff subtype "0" "naturalnumbers.upto(real_defs.min(length(gen_strings.s1), length(gen_strings.s2)))"))) (strdiff_eq_TCC1 0 (strdiff_eq_TCC1-1 nil 3820376026 ("" (skeep :preds? t) (("" (typepred "strdiff(s1, s2)") (("" (grind) nil nil)) nil)) nil) ((strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil)) nil (strdiff_eq subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.s1))"))) (strdiff_eq_TCC2 0 (strdiff_eq_TCC2-1 nil 3820376026 ("" (skeep :preds? t) (("" (typepred "strdiff(s1, s2)") (("" (grind) nil nil)) nil)) nil) ((strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil)) nil (strdiff_eq subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.s2))"))) (strdiff_eq 0 (strdiff_eq-1 nil 3835469973 ("" (skeep :preds? t) (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
       i < strdiff_rec(s1, s2, i) => get(s1, i) = get(s2, i)") (("1" (inst?) (("1" (assert) (("1" (expand "strdiff") (("1" (case "LET i = strdiff_rec(s1, s2, 0)
      IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (induct "k") (("2" (skeep :preds? t) (("2" (expand "strdiff_rec" -3 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (expand "strdiff_rec") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (typepred "strdiff_rec(s1, s2, i)") (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((get const-decl "char" gen_strings nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (strdiff_rec def-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pred type-eq-decl nil defined_types nil) (below_induction formula-decl nil bounded_nat_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (j skolem-const-decl "below(strdiff(s1, s2))" gen_strings nil) (s2 skolem-const-decl "string" gen_strings nil) (s1 skolem-const-decl "string" gen_strings nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (strdiff_neq_TCC1 0 (strdiff_neq_TCC1-1 nil 3820376026 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil)) nil (strdiff_neq subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s1))"))) (strdiff_neq_TCC2 0 (strdiff_neq_TCC2-1 nil 3820376026 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil)) nil (strdiff_neq subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s2))"))) (strdiff_neq 0 (strdiff_neq-1 nil 3835643325 ("" (skeep) (("" (beta) (("" (name-replace "i" "strdiff(s1, s2)") (("" (flatten) (("" (expand "get") (("" (reveal -1) (("" (expand "strdiff") (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
       i = strdiff_rec(s1, s2, 0) =>
         i = strdiff_rec(s1, s2, i)") (("1" (inst -1 "i") (("1" (assert) (("1" (expand "strdiff_rec" -1) (("1" (lift-if) (("1" (assert) (("1" (expand "get") (("1" (case "FORALL (i: upto(min(length(s1), length(s2)))):
       i <= strdiff_rec(s1, s2, i)") (("1" (inst -1 "i+1") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "min(length(s1), length(s2)) - i" ("i")) (("2" (expand "strdiff_rec" 1) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (inst -2 "x!1 + 1") (("1" (assert) nil nil) ("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "i") (("1" (flatten) nil nil) ("2" (skeep) (("2" (case "LET i = strdiff_rec(s1, s2, 0)
      IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (let-name-replace) (("1" (ground) (("1" (replace -2 :dir rl) (("1" (inst -3 "jt") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (inst -2 "jt") (("2" (assert) (("2" (expand "strdiff_rec" -2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1 :actuals? t) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (typepred "strdiff_rec(s1, s2, 0)") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (beta) (("2" (induct "k") (("1" (skeep :preds? t) (("1" (expand "strdiff_rec" -3 1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep :preds? t) (("2" (typepred "strdiff_rec(s1, s2, 0)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (strdiff_rec def-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (wf_nat formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (s1 skolem-const-decl "string" gen_strings nil) (s2 skolem-const-decl "string" gen_strings nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (i_1 skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (below_induction formula-decl nil bounded_nat_inductions nil) (get const-decl "char" gen_strings nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (strcmp_TCC1 0 (strcmp_TCC1-1 nil 3820376026 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (strcmp subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s1))"))) (strcmp_TCC2 0 (strcmp_TCC2-1 nil 3835419903 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil)) shostak (strcmp subtype "gen_strings.i" "naturalnumbers.below(length(gen_strings.s2))"))) (strcmp_eq 0 (strcmp_eq-1 nil 3835719256 ("" (skeep) (("" (expand "strcmp") (("" (lift-if) (("" (ground) (("" (apply-extensionality 3 :hide? t) (("" (apply-extensionality :hide? t) (("" (lemma "strdiff_eq") (("" (expand "get") (("" (inst?) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strcmp const-decl "subrange(-1, 1)" gen_strings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (get const-decl "char" gen_strings nil) (s1 skolem-const-decl "string" gen_strings nil) (x!1 skolem-const-decl "below[s1`length]" gen_strings nil) (s2 skolem-const-decl "string" gen_strings nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (below type-eq-decl nil naturalnumbers nil) (strdiff_eq formula-decl nil gen_strings nil) (string type-eq-decl nil strings nil) (char type-eq-decl nil strings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (boolean nonempty-type-decl nil booleans nil) (character type-decl nil character_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (strcmp_lt 0 (strcmp_lt-1 nil 3835719717 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (get const-decl "char" gen_strings nil) (below type-eq-decl nil naturalnumbers nil) (code adt-accessor-decl "[character -> below[0x110000]]" character_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" gen_strings nil)) shostak)) (strcmp_gt 0 (strcmp_gt-1 nil 3835720023 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (ground) (("2" (replace -2 :dir rl) (("2" (case "code(get(s2, i)) = code(get(s1, i))") (("1" (lemma "strdiff_neq") (("1" (inst?) (("1" (let-name-replace) (("1" (replace -1 :hide? t) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (lemma "character_char_extensionality") (("1" (expand "get" -3) (("1" (inst?) (("1" (expand "get") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (get const-decl "char" gen_strings nil) (below type-eq-decl nil naturalnumbers nil) (code adt-accessor-decl "[character -> below[0x110000]]" character_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (character_char_extensionality formula-decl nil character_adt nil) (i_1 skolem-const-decl "upto(min(length(s1), length(s2)))" gen_strings nil) (/= const-decl "boolean" notequal nil) (strdiff_neq formula-decl nil gen_strings nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" gen_strings nil)) shostak)) (prefix_TCC1 0 (prefix_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) nil shostak (prefix subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.s))"))) (length_prefix 0 (length_prefix-1 nil 3835721909 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil) (prefix const-decl "string" gen_strings nil)) shostak)) (prefix_ax_TCC1 0 (prefix_ax_TCC1-1 nil 3820376026 ("" (skeep :preds? t) (("" (rewrite "length_prefix") nil nil)) nil) ((length_prefix formula-decl nil gen_strings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) nil (prefix_ax subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.prefix(gen_strings.s, gen_strings.i)))"))) (prefix_ax_TCC2 0 (prefix_ax_TCC2-1 nil 3820376026 ("" (subtype-tcc) nil nil) nil nil (prefix_ax subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.s))"))) (prefix_ax 0 (prefix_ax-1 nil 3835721931 ("" (grind) nil nil) ((get const-decl "char" gen_strings nil) (prefix const-decl "string" gen_strings nil)) shostak)) (suffix_TCC1 0 (suffix_TCC2-1 nil 3835419904 ("" (subtype-tcc) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) nil shostak (suffix subtype "(number_fields.-)(length(gen_strings.s), gen_strings.i)" "nat"))) (suffix_TCC2 0 (suffix_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) nil shostak (suffix subtype "(number_fields.+)(gen_strings.i, gen_strings.j)" "naturalnumbers.below(length(gen_strings.s))"))) (length_suffix 0 (length_suffix-1 nil 3835722960 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil) (suffix const-decl "string" gen_strings nil)) shostak)) (suffix_ax_TCC1 0 (suffix_ax_TCC1-1 nil 3820376026 ("" (skeep :preds? t) (("" (rewrite "length_suffix") nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_suffix formula-decl nil gen_strings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) nil (suffix_ax subtype "gen_strings.j" "naturalnumbers.below(length(gen_strings.suffix(gen_strings.s, gen_strings.i)))"))) (suffix_ax_TCC2 0 (suffix_ax_TCC2-1 nil 3820376026 ("" (subtype-tcc) nil nil) nil nil (suffix_ax subtype "(number_fields.+)(gen_strings.i, gen_strings.j)" "naturalnumbers.below(length(gen_strings.s))"))) (suffix_ax 0 (suffix_ax-1 nil 3835722986 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "char" gen_strings nil) (suffix const-decl "string" gen_strings nil)) shostak)) (substr_TCC1 0 (substr_TCC1-1 nil 3820376026 ("" (skeep :preds? t) (("" (rewrite "length_suffix") (("" (assert) nil nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (length_suffix formula-decl nil gen_strings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (substr subtype "(number_fields.-)(gen_strings.j, gen_strings.i)" "naturalnumbers.upto(length(gen_strings.suffix(gen_strings.s, gen_strings.i)))"))) (substr_TCC2 0 (substr_TCC2-1 nil 3820376919 ("" (skeep :preds? t) (("" (rewrite "length_prefix") nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_prefix formula-decl nil gen_strings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (boolean nonempty-type-decl nil booleans nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (suffix const-decl "string" gen_strings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil)) nil (substr subtype "gen_strings.prefix(gen_strings.suffix(gen_strings.s, gen_strings.i), (number_fields.-)(gen_strings.j, gen_strings.i))" "{s1 | length(gen_strings.s1) = (number_fields.-)(gen_strings.j, gen_strings.i)}"))))(charstrings (charstring_bound_TCC1 0 (charstring_bound_TCC1-1 nil 3867803591 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (charstring_bound subtype "exp2.exp2(28)" "uint32"))) (null_TCC1 0 (null_TCC1-1 nil 3867803591 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (null subtype "0" "index"))) (length_null 0 (length_null-1 nil 3835723054 ("" (grind) nil nil) ((null const-decl "charstring" charstrings nil)) shostak)) (addchar_TCC1 0 (addchar_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (addchar subtype "(number_fields.+)(charstrings.s`length, 1)" "index"))) (addchar_TCC2 0 (addchar_TCC2-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (charstring type-eq-decl nil charstrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (addchar subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s))"))) (unit_TCC1 0 (unit_TCC1-1 nil 3867803591 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (unit subtype "1" "index"))) (length_unit 0 (length_unit-1 nil 3835723070 ("" (grind) nil nil) ((unit const-decl "charstring" charstrings nil)) shostak)) (unit_ax_TCC1 0 (unit_ax_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((unit const-decl "charstring" charstrings nil)) shostak (unit_ax subtype "0" "naturalnumbers.below(length(charstrings.unit(charstrings.c)))"))) (unit_ax 0 (unit_ax-1 nil 3835723087 ("" (grind) nil nil) ((unit const-decl "charstring" charstrings nil) (cget const-decl "char" charstrings nil)) shostak)) (extensionality_TCC1 0 (extensionality_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((charstring type-eq-decl nil charstrings nil) (char type-eq-decl nil strings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (extensionality subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s2))"))) (extensionality 0 (extensionality-1 nil 3835723198 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) nil nil)) nil)) nil) ((char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (cget const-decl "char" charstrings nil)) shostak)) (mk_charstring_TCC1 0 (mk_charstring_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (mk_charstring subtype "charstrings.cs`length" "index"))) (doubleplus_TCC1 0 (doubleplus_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) nil shostak (doubleplus subtype "(number_fields.+)(charstrings.s1`length, charstrings.s2`length)" "naturalnumbers.below(exp2.exp2(28))"))) (doubleplus_TCC2 0 (doubleplus_TCC2-1 nil 3867803591 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (doubleplus subtype "charstrings.n" "index"))) (doubleplus_TCC3 0 (doubleplus_TCC2-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (doubleplus subtype "(number_fields.-)(charstrings.i, charstrings.s1`length)" "naturalnumbers.below(length(charstrings.s2))"))) (length_concat_TCC1 0 (length_concat_TCC1-1 nil 3835419904 ("" (subtype-tcc) (("" (postpone) nil nil)) nil) nil shostak (length_concat subtype "charstrings.s2" "{s2 | reals.<((number_fields.+)(charstrings.s1`length, charstrings.s2`length), exp2.exp2(28))}"))) (length_concat 0 (length_concat-1 nil 3835727461 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (++ const-decl "charstring" charstrings nil)) shostak)) (char_concat_TCC1 0 (char_concat_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (O const-decl "finseq" finite_sequences nil)) shostak (char_concat subtype "finite_sequences[char].o(charstrings.s1, charstrings.s2)" "charstring"))) (char_concat_TCC2 0 (char_concat_TCC2-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((O const-decl "finseq" finite_sequences nil)) shostak (char_concat subtype "charstrings.i" "naturalnumbers.below(length(finite_sequences[char].o(charstrings.s1, charstrings.s2)))"))) (char_concat_TCC3 0 (char_concat_TCC3-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (char_concat subtype "(number_fields.-)(charstrings.i, length(charstrings.s1))" "naturalnumbers.below(length(charstrings.s2))"))) (char_concat 0 (char_concat-1 nil 3835727487 ("" (grind) nil nil) ((O const-decl "finseq" finite_sequences nil) (cget const-decl "char" charstrings nil)) shostak)) (strdiff_rec_TCC1 0 (strdiff_rec_TCC1-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil)) shostak (strdiff_rec subtype "(number_fields.-)(real_defs.min(length(charstrings.s1), length(charstrings.s2)), charstrings.i)" "naturalnumber"))) (strdiff_rec_TCC2 0 (strdiff_rec_TCC2-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s1))"))) (strdiff_rec_TCC3 0 (strdiff_rec_TCC3-1 nil 3835419904 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s2))"))) (strdiff_rec_TCC4 0 (strdiff_rec_TCC4-1 nil 3835419905 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cget const-decl "char" charstrings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec subtype "(number_fields.+)(charstrings.i, 1)" "naturalnumbers.upto(real_defs.min(length(charstrings.s1), length(charstrings.s2)))"))) (strdiff_rec_TCC5 0 (strdiff_rec_TCC5-1 nil 3835419905 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (cget const-decl "char" charstrings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec termination "charstrings.strdiff_rec(charstrings.s1, charstrings.s2, (number_fields.+)(charstrings.i, 1))" "nil"))) (strdiff_TCC1 0 (strdiff_TCC1-1 nil 3835419905 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (strdiff subtype "0" "naturalnumbers.upto(real_defs.min(length(charstrings.s1), length(charstrings.s2)))"))) (strdiff_eq_TCC1 0 (strdiff_eq_TCC1-1 nil 3835419905 ("" (grind) (("" (typepred "strdiff_rec(s1!1, s2!1, 0)") (("" (grind) nil nil)) nil)) nil) ((strdiff_rec def-decl "upto(min(length(s1), length(s2)))" charstrings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strdiff_eq subtype "charstrings.j" "naturalnumbers.below(length(charstrings.s1))"))) (strdiff_eq_TCC2 0 (strdiff_eq_TCC2-1 nil 3835419905 ("" (grind) (("" (typepred "strdiff_rec(s1!1, s2!1, 0)") (("" (grind) nil nil)) nil)) nil) ((strdiff_rec def-decl "upto(min(length(s1), length(s2)))" charstrings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strdiff_eq subtype "charstrings.j" "naturalnumbers.below(length(charstrings.s2))"))) (strdiff_eq 0 (strdiff_eq-1 nil 3835727745 ("" (skeep :preds? t) (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
              i < strdiff_rec(s1, s2, i) => cget(s1, i) = cget(s2, i)") (("1" (inst?) (("1" (assert) (("1" (expand "strdiff") (("1" (case "LET i = strdiff_rec(s1, s2, 0)
                 IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (induct "k") (("2" (skeep :preds? t) (("2" (expand "strdiff_rec" -3 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (expand "strdiff_rec") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (typepred "strdiff_rec(s1, s2, i)") (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((cget const-decl "char" charstrings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (character type-decl nil character_adt nil) (strdiff_rec def-decl "upto(min(length(s1), length(s2)))" charstrings nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (charstring type-eq-decl nil charstrings nil) (char type-eq-decl nil strings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pred type-eq-decl nil defined_types nil) (below_induction formula-decl nil bounded_nat_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (j skolem-const-decl "below(strdiff(s1, s2))" charstrings nil) (s2 skolem-const-decl "charstring" charstrings nil) (s1 skolem-const-decl "charstring" charstrings nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (strdiff_neq_TCC1 0 (strdiff_neq_TCC1-1 nil 3835419905 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strdiff_neq subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s1))"))) (strdiff_neq_TCC2 0 (strdiff_neq_TCC2-1 nil 3835419905 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strdiff_neq subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s2))"))) (strdiff_neq 0 (strdiff_neq-1 nil 3835728510 ("" (skeep) (("" (beta) (("" (name-replace "i" "strdiff(s1, s2)") (("" (flatten) (("" (expand "cget") (("" (reveal -1) (("" (expand "strdiff") (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
              i = strdiff_rec(s1, s2, 0) =>
                i = strdiff_rec(s1, s2, i)") (("1" (inst -1 "i") (("1" (assert) (("1" (expand "strdiff_rec" -1) (("1" (lift-if) (("1" (assert) (("1" (expand "cget") (("1" (case "FORALL (i: upto(min(length(s1), length(s2)))):
                i <= strdiff_rec(s1, s2, i)") (("1" (inst -1 "i+1") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "min(length(s1), length(s2)) - i" ("i")) (("2" (expand "strdiff_rec" 1) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (inst -2 "x!1 + 1") (("1" (assert) nil nil) ("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "i") (("1" (flatten) nil nil) ("2" (skeep) (("2" (case "LET i = strdiff_rec(s1, s2, 0)
                 IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (let-name-replace) (("1" (ground) (("1" (replace -2 :dir rl) (("1" (inst -3 "jt") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (inst -2 "jt") (("2" (assert) (("2" (expand "strdiff_rec" -2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1 :actuals? t) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (typepred "strdiff_rec(s1, s2, 0)") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (beta) (("2" (induct "k") (("1" (skeep :preds? t) (("1" (expand "strdiff_rec" -3 1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep :preds? t) (("2" (typepred "strdiff_rec(s1, s2, 0)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (strdiff_rec def-decl "upto(min(length(s1), length(s2)))" charstrings nil) (nil application-judgement "above(n)" exp2 nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (wf_nat formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (s1 skolem-const-decl "charstring" charstrings nil) (s2 skolem-const-decl "charstring" charstrings nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (NOT const-decl "[bool -> bool]" booleans nil) (i_1 skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (below_induction formula-decl nil bounded_nat_inductions nil) (cget const-decl "char" charstrings nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (charstring type-eq-decl nil charstrings nil) (char type-eq-decl nil strings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (strcmp_TCC1 0 (strcmp_TCC1-1 nil 3835419905 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strcmp subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s1))"))) (strcmp_TCC2 0 (strcmp_TCC2-1 nil 3835419906 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil)) shostak (strcmp subtype "charstrings.i" "naturalnumbers.below(length(charstrings.s2))"))) (strcmp_eq 0 (strcmp_eq-1 nil 3835729150 ("" (skeep) (("" (expand "strcmp") (("" (lift-if) (("" (ground) (("" (apply-extensionality 3 :hide? t) (("" (apply-extensionality :hide? t) (("" (lemma "strdiff_eq") (("" (expand "cget") (("" (inst?) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strcmp const-decl "subrange(-1, 1)" charstrings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (cget const-decl "char" charstrings nil) (s2 skolem-const-decl "charstring" charstrings nil) (x!1 skolem-const-decl "below(s1`length)" charstrings nil) (s1 skolem-const-decl "charstring" charstrings nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (strdiff_eq formula-decl nil charstrings nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil)) shostak)) (strcmp_lt 0 (strcmp_lt-1 nil 3835729751 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (cget const-decl "char" charstrings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (code adt-accessor-decl "[character -> below[0x110000]]" character_adt nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" charstrings nil)) shostak)) (strcmp_gt 0 (strcmp_gt-1 nil 3835730096 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (ground) (("2" (replace -2 :dir rl) (("2" (case "code(cget(s2, i)) = code(cget(s1, i))") (("1" (lemma "strdiff_neq") (("1" (inst?) (("1" (let-name-replace) (("1" (replace -1 :hide? t) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (lemma "character_char_extensionality") (("1" (expand "cget" -3) (("1" (inst?) (("1" (expand "cget") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (cget const-decl "char" charstrings nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (code adt-accessor-decl "[character -> below[0x110000]]" character_adt nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (i skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (character_char_extensionality formula-decl nil character_adt nil) (i_1 skolem-const-decl "upto(min(length(s1), length(s2)))" charstrings nil) (/= const-decl "boolean" notequal nil) (strdiff_neq formula-decl nil charstrings nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" charstrings nil)) shostak)) (prefix_TCC1 0 (prefix_TCC1-1 nil 3835419906 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (prefix subtype "charstrings.i" "index"))) (prefix_TCC2 0 (prefix_TCC2-1 nil 3835419906 ("" (subtype-tcc) nil nil) nil shostak (prefix subtype "charstrings.j" "naturalnumbers.below(length(charstrings.s))"))) (length_prefix 0 (length_prefix-1 nil 3835730303 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (prefix const-decl "charstring" charstrings nil)) shostak)) (prefix_ax_TCC1 0 (prefix_ax_TCC1-1 nil 3835419906 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (prefix const-decl "charstring" charstrings nil)) shostak (prefix_ax subtype "charstrings.j" "naturalnumbers.below(length(charstrings.prefix(charstrings.s, charstrings.i)))"))) (prefix_ax_TCC2 0 (prefix_ax_TCC2-1 nil 3835419958 ("" (subtype-tcc) nil nil) nil shostak (prefix_ax subtype "charstrings.j" "naturalnumbers.below(length(charstrings.s))"))) (prefix_ax 0 (prefix_ax-1 nil 3835730349 ("" (grind) nil nil) ((cget const-decl "char" charstrings nil) (prefix const-decl "charstring" charstrings nil)) shostak)) (suffix_TCC1 0 (suffix_TCC1-1 nil 3835419958 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (suffix subtype "(number_fields.-)(length(charstrings.s), charstrings.i)" "index"))) (suffix_TCC2 0 (suffix_TCC2-1 nil 3835419958 ("" (subtype-tcc) nil nil) nil shostak (suffix subtype "(number_fields.+)(charstrings.i, charstrings.j)" "naturalnumbers.below(length(charstrings.s))"))) (length_suffix 0 (length_suffix-1 nil 3835731453 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (suffix const-decl "charstring" charstrings nil)) shostak)) (suffix_ax_TCC1 0 (suffix_ax_TCC1-1 nil 3835419958 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (cget const-decl "char" charstrings nil) (suffix const-decl "charstring" charstrings nil)) shostak (suffix_ax subtype "charstrings.j" "naturalnumbers.below(length(charstrings.suffix(charstrings.s, charstrings.i)))"))) (suffix_ax_TCC2 0 (suffix_ax_TCC2-1 nil 3835419958 ("" (subtype-tcc) nil nil) nil shostak (suffix_ax subtype "(number_fields.+)(charstrings.i, charstrings.j)" "naturalnumbers.below(length(charstrings.s))"))) (suffix_ax 0 (suffix_ax-1 nil 3835731593 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (suffix const-decl "charstring" charstrings nil)) shostak)) (substr_TCC1 0 (substr_TCC1-1 nil 3835419958 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cget const-decl "char" charstrings nil) (suffix const-decl "charstring" charstrings nil)) shostak (substr subtype "(number_fields.-)(charstrings.j, charstrings.i)" "naturalnumbers.upto(length(charstrings.suffix(charstrings.s, charstrings.i)))"))) (substr_TCC2 0 (substr_TCC2-1 nil 3835419958 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (char type-eq-decl nil strings nil) (charstring type-eq-decl nil charstrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (cget const-decl "char" charstrings nil) (suffix const-decl "charstring" charstrings nil) (prefix const-decl "charstring" charstrings nil)) shostak (substr subtype "charstrings.prefix(charstrings.suffix(charstrings.s, charstrings.i), (number_fields.-)(charstrings.j, charstrings.i))" "{s1 | length(charstrings.s1) = (number_fields.-)(charstrings.j, charstrings.i)}"))))(bytestrings (byte_TCC1 0 (byte_TCC1-1 nil 3835419958 ("" (inst 1 "0") nil nil) ((exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (byte existence "" "{s: naturalnumbers.nat | reals.<(s, exp2.exp2(8))}"))) (bytestring_bound_TCC1 0 (bytestring_bound_TCC1-1 nil 3867803597 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil)) shostak (bytestring_bound subtype "exp2.exp2(28)" "uint32"))) (null_TCC1 0 (null_TCC1-1 nil 3867803597 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (null subtype "0" "index"))) (length_null 0 (length_null-1 nil 3835731821 ("" (grind) nil nil) ((null const-decl "bytestring" bytestrings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (unit_TCC1 0 (unit_TCC1-1 nil 3867803597 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (unit subtype "1" "index"))) (length_unit 0 (length_unit-1 nil 3835731831 ("" (grind) nil nil) ((unit const-decl "bytestring" bytestrings nil)) shostak)) (unit_ax_TCC1 0 (unit_ax_TCC1-1 nil 3835419958 ("" (subtype-tcc) nil nil) ((unit const-decl "bytestring" bytestrings nil)) shostak (unit_ax subtype "0" "naturalnumbers.below(length(bytestrings.unit(bytestrings.b)))"))) (unit_ax 0 (unit_ax-1 nil 3835731853 ("" (grind) nil nil) ((unit const-decl "bytestring" bytestrings nil) (get const-decl "byte" bytestrings nil)) shostak)) (extensionality_TCC1 0 (extensionality_TCC1-1 nil 3835419958 ("" (subtype-tcc) nil nil) ((bytestring type-eq-decl nil bytestrings nil) (byte nonempty-type-eq-decl nil bytestrings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (extensionality subtype "bytestrings.i" "naturalnumbers.below(length(bytestrings.s2))"))) (extensionality 0 (extensionality-1 nil 3835731869 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) nil nil)) nil)) nil) ((exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (get const-decl "byte" bytestrings nil)) shostak)) (mk_bytestring_TCC1 0 (mk_bytestring_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (mk_bytestring subtype "bytestrings.cs`length" "index"))) (mk_bytestring_TCC2 0 (mk_bytestring_TCC2-1 nil 3835419959 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (character type-decl nil character_adt nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (char type-eq-decl nil strings nil) (string type-eq-decl nil strings nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (code adt-accessor-decl "[character -> below[0x110000]]" character_adt nil) (bstring type-eq-decl nil bytestrings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (get const-decl "char" gen_strings nil) (exp2 def-decl "posnat" exp2 nil)) shostak (mk_bytestring subtype "character_adt.code(gen_strings.get(bytestrings.cs, bytestrings.i))" "byte"))) (doubleplus_TCC1 0 (doubleplus_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) nil shostak (doubleplus subtype "(number_fields.+)(bytestrings.s1`length, bytestrings.s2`length)" "naturalnumbers.below(exp2.exp2(28))"))) (doubleplus_TCC2 0 (doubleplus_TCC2-1 nil 3867803597 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (doubleplus subtype "bytestrings.n" "index"))) (doubleplus_TCC3 0 (doubleplus_TCC2-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (doubleplus subtype "(number_fields.-)(bytestrings.i, bytestrings.s1`length)" "naturalnumbers.below(length(bytestrings.s2))"))) (length_concat 0 (length_concat-1 nil 3835732507 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (++ const-decl "bytestring" bytestrings nil)) shostak)) (char_concat_TCC1 0 (char_concat_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (O const-decl "finseq" finite_sequences nil)) shostak (char_concat subtype "finite_sequences[byte].o(bytestrings.s1, bytestrings.s2)" "bytestring"))) (char_concat_TCC2 0 (char_concat_TCC2-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((O const-decl "finseq" finite_sequences nil)) shostak (char_concat subtype "bytestrings.i" "naturalnumbers.below(length(finite_sequences[byte].o(bytestrings.s1, bytestrings.s2)))"))) (char_concat_TCC3 0 (char_concat_TCC3-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (char_concat subtype "(number_fields.-)(bytestrings.i, length(bytestrings.s1))" "naturalnumbers.below(length(bytestrings.s2))"))) (char_concat 0 (char_concat-1 nil 3835732523 ("" (grind) nil nil) ((O const-decl "finseq" finite_sequences nil) (get const-decl "byte" bytestrings nil)) shostak)) (strdiff_rec_TCC1 0 (strdiff_rec_TCC1-1 nil 3835419959 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec subtype "(number_fields.-)(real_defs.min(length(bytestrings.s1), length(bytestrings.s2)), bytestrings.i)" "naturalnumber"))) (strdiff_rec_TCC2 0 (strdiff_rec_TCC2-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "bytestrings.i" "naturalnumbers.below(length(bytestrings.s1))"))) (strdiff_rec_TCC3 0 (strdiff_rec_TCC3-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (strdiff_rec subtype "bytestrings.i" "naturalnumbers.below(length(bytestrings.s2))"))) (strdiff_rec_TCC4 0 (strdiff_rec_TCC4-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (strdiff_rec subtype "(number_fields.+)(bytestrings.i, 1)" "{i: naturalnumbers.upto(length(bytestrings.s1)) | reals.<=(i, length(bytestrings.s2))}"))) (strdiff_rec_TCC5 0 (strdiff_rec_TCC5-1 nil 3835419959 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "byte" bytestrings nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak (strdiff_rec termination "bytestrings.strdiff_rec(bytestrings.s1, bytestrings.s2, (number_fields.+)(bytestrings.i, 1))" "nil"))) (strdiff_TCC1 0 (strdiff_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (strdiff subtype "0" "{i: naturalnumbers.upto(length(bytestrings.s1)) | reals.<=(i, length(bytestrings.s2))}"))) (strdiff_eq_TCC1 0 (strdiff_eq_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (strdiff_eq subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.s1))"))) (strdiff_eq_TCC2 0 (strdiff_eq_TCC2-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (strdiff_eq subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.s2))"))) (strdiff_eq 0 (strdiff_eq-1 nil 3835732642 ("" (skeep :preds? t) (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
              i < strdiff_rec(s1, s2, i) => get(s1, i) = get(s2, i)") (("1" (inst?) (("1" (assert) (("1" (expand "strdiff") (("1" (case "LET i = strdiff_rec(s1, s2, 0)
                 IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (induct "k") (("2" (skeep :preds? t) (("2" (expand "strdiff_rec" -3 1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (expand "strdiff_rec") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (typepred "strdiff_rec(s1, s2, i)") (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ((get const-decl "byte" bytestrings nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (strdiff_rec def-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bytestring type-eq-decl nil bytestrings nil) (byte nonempty-type-eq-decl nil bytestrings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pred type-eq-decl nil defined_types nil) (below_induction formula-decl nil bounded_nat_inductions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (j skolem-const-decl "below(strdiff(s1, s2))" bytestrings nil) (s2 skolem-const-decl "bytestring" bytestrings nil) (s1 skolem-const-decl "bytestring" bytestrings nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (strdiff_neq_TCC1 0 (strdiff_neq_TCC1-1 nil 3835419959 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil)) shostak (strdiff_neq subtype "bytestrings.i" "naturalnumbers.below(length(bytestrings.s1))"))) (strdiff_neq_TCC2 0 (strdiff_neq_TCC2-1 nil 3835419960 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil)) shostak (strdiff_neq subtype "bytestrings.i" "naturalnumbers.below(length(bytestrings.s2))"))) (strdiff_neq 0 (strdiff_neq-1 nil 3835732968 ("" (skeep) (("" (beta) (("" (name-replace "i" "strdiff(s1, s2)") (("" (flatten) (("" (expand "get") (("" (reveal -1) (("" (expand "strdiff") (("" (case "FORALL (i: upto(min(length(s1), length(s2)))):
              i = strdiff_rec(s1, s2, 0) =>
                i = strdiff_rec(s1, s2, i)") (("1" (inst -1 "i") (("1" (assert) (("1" (expand "strdiff_rec" -1) (("1" (lift-if) (("1" (assert) (("1" (expand "get") (("1" (case "FORALL (i: upto(min(length(s1), length(s2)))):
                i <= strdiff_rec(s1, s2, i)") (("1" (inst -1 "i+1") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "min(length(s1), length(s2)) - i" ("i")) (("2" (expand "strdiff_rec" 1) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (inst -2 "x!1 + 1") (("1" (assert) nil nil) ("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (induct "i") (("1" (flatten) nil nil) ("2" (skeep) (("2" (case "LET i = strdiff_rec(s1, s2, 0)
                 IN FORALL (k: below(i)): strdiff_rec(s1, s2, k) = i") (("1" (let-name-replace) (("1" (ground) (("1" (replace -2 :dir rl) (("1" (inst -3 "jt") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (inst -2 "jt") (("2" (assert) (("2" (expand "strdiff_rec" -2) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1 :actuals? t) (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (typepred "strdiff_rec(s1, s2, 0)") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (beta) (("2" (induct "k") (("1" (skeep :preds? t) (("1" (expand "strdiff_rec" -3 1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep :preds? t) (("2" (typepred "strdiff_rec(s1, s2, 0)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (grind) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strdiff_rec def-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "upto(min(length(s1), length(s2)))" bytestrings nil) (wf_nat formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (s2 skolem-const-decl "bytestring" bytestrings nil) (s1 skolem-const-decl "bytestring" bytestrings nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (NOT const-decl "[bool -> bool]" booleans nil) (i_1 skolem-const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (below_induction formula-decl nil bounded_nat_inductions nil) (get const-decl "byte" bytestrings nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (bytestring type-eq-decl nil bytestrings nil) (byte nonempty-type-eq-decl nil bytestrings nil) (below type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (strcmp_eq 0 (strcmp_eq-1 nil 3835734250 ("" (skeep) (("" (expand "strcmp") (("" (lift-if) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) (("" (lemma "strdiff_eq") (("" (expand "get") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strcmp const-decl "subrange(-1, 1)" bytestrings nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (strdiff_eq formula-decl nil bytestrings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (s1 skolem-const-decl "bytestring" bytestrings nil) (x!1 skolem-const-decl "below(s1`length)" bytestrings nil) (s2 skolem-const-decl "bytestring" bytestrings nil) (get const-decl "byte" bytestrings nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (strcmp_lt 0 (strcmp_lt-1 nil 3835734858 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (get const-decl "byte" bytestrings nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (i skolem-const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" bytestrings nil)) shostak)) (strcmp_gt 0 (strcmp_gt-1 nil 3835734996 ("" (skeep) (("" (let-name-replace) (("" (expand "strcmp") (("" (lift-if) (("" (assert) (("" (split -2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (ground) (("2" (replace -2 :dir rl) (("2" (expand "get") (("2" (lemma "strdiff_neq") (("2" (inst?) (("2" (let-name-replace) (("1" (replace -1 :hide? t) (("1" (replace -3 :dir rl) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (strdiff const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (get const-decl "byte" bytestrings nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (i skolem-const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (i_1 skolem-const-decl "{i: upto(length(s1)) | i <= length(s2)}" bytestrings nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (/= const-decl "boolean" notequal nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (strdiff_neq formula-decl nil bytestrings nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strcmp const-decl "subrange(-1, 1)" bytestrings nil)) shostak)) (prefix_TCC1 0 (prefix_TCC1-1 nil 3835419960 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (prefix subtype "bytestrings.i" "index"))) (prefix_TCC2 0 (prefix_TCC2-1 nil 3835419960 ("" (subtype-tcc) nil nil) nil shostak (prefix subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.s))"))) (length_prefix 0 (length_prefix-1 nil 3835735281 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (prefix const-decl "bytestring" bytestrings nil)) shostak)) (prefix_ax_TCC1 0 (prefix_ax_TCC1-1 nil 3835419960 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (prefix const-decl "bytestring" bytestrings nil)) shostak (prefix_ax subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.prefix(bytestrings.s, bytestrings.i)))"))) (prefix_ax_TCC2 0 (prefix_ax_TCC2-1 nil 3835419962 ("" (subtype-tcc) nil nil) nil shostak (prefix_ax subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.s))"))) (prefix_ax 0 (prefix_ax-1 nil 3835735315 ("" (grind) nil nil) ((get const-decl "byte" bytestrings nil) (prefix const-decl "bytestring" bytestrings nil)) shostak)) (suffix_TCC1 0 (suffix_TCC1-1 nil 3835419962 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (suffix subtype "(number_fields.-)(bytestrings.s`length, bytestrings.i)" "index"))) (suffix_TCC2 0 (suffix_TCC2-1 nil 3835419962 ("" (subtype-tcc) nil nil) nil shostak (suffix subtype "(number_fields.+)(bytestrings.i, bytestrings.j)" "naturalnumbers.below(length(bytestrings.s))"))) (length_suffix 0 (length_suffix-1 nil 3835735384 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (suffix const-decl "bytestring" bytestrings nil)) shostak)) (suffix_ax_TCC1 0 (suffix_ax_TCC1-1 nil 3835419962 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "byte" bytestrings nil) (suffix const-decl "bytestring" bytestrings nil)) shostak (suffix_ax subtype "bytestrings.j" "naturalnumbers.below(length(bytestrings.suffix(bytestrings.s, bytestrings.i)))"))) (suffix_ax_TCC2 0 (suffix_ax_TCC2-1 nil 3835419962 ("" (subtype-tcc) nil nil) nil shostak (suffix_ax subtype "(number_fields.+)(bytestrings.i, bytestrings.j)" "naturalnumbers.below(length(bytestrings.s))"))) (suffix_ax 0 (suffix_ax-1 nil 3835735414 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (suffix const-decl "bytestring" bytestrings nil)) shostak)) (substr_TCC1 0 (substr_TCC1-1 nil 3835419962 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "byte" bytestrings nil) (suffix const-decl "bytestring" bytestrings nil)) shostak (substr subtype "(number_fields.-)(bytestrings.j, bytestrings.i)" "naturalnumbers.upto(length(bytestrings.suffix(bytestrings.s, bytestrings.i)))"))) (substr_TCC2 0 (substr_TCC2-1 nil 3835419962 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index type-eq-decl nil integertypes nil) (below type-eq-decl nil naturalnumbers nil) (byte nonempty-type-eq-decl nil bytestrings nil) (bytestring type-eq-decl nil bytestrings nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "byte" bytestrings nil) (suffix const-decl "bytestring" bytestrings nil) (prefix const-decl "bytestring" bytestrings nil)) shostak (substr subtype "bytestrings.prefix(bytestrings.suffix(bytestrings.s, bytestrings.i), (number_fields.-)(bytestrings.j, bytestrings.i))" "{s1 | length(bytestrings.s1) = (number_fields.-)(bytestrings.j, bytestrings.i)}"))))(lift)(union)(tostring)(file (max_file_size_TCC1 0 (max_file_size_TCC1-1 nil 3867803602 ("" (inst 1 "0") nil nil) ((int32 type-eq-decl nil integertypes nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (max_file_size existence "" "int32"))))(mucalculus (lfp_induction 0 (lfp_induction-1 nil 3252401360 ("" (grind :if-match nil) (("" (inst -3 "p!1") (("" (assert) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil mucalculus nil) (pred type-eq-decl nil defined_types nil) (predicate_transformer type-eq-decl nil mucalculus nil) (monotonic? const-decl "bool" mucalculus nil) (glb const-decl "pred[T]" mucalculus nil) (member const-decl "bool" sets nil) (lfp const-decl "pred[T]" mucalculus nil) (<= const-decl "bool" mucalculus nil)) shostak)) (gfp_induction 0 (gfp_induction-1 nil 3252401454 ("" (grind :if-match nil) (("" (inst 1 "p!1") (("" (assert) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil mucalculus nil) (pred type-eq-decl nil defined_types nil) (predicate_transformer type-eq-decl nil mucalculus nil) (monotonic? const-decl "bool" mucalculus nil) (lub const-decl "pred[T]" mucalculus nil) (member const-decl "bool" sets nil) (gfp const-decl "pred[T]" mucalculus nil) (<= const-decl "bool" mucalculus nil)) shostak)))(ctlops (EG_TCC1 0 (EG_TCC1-1 nil 3242699046 ("" (grind) nil nil) ((state formal-type-decl nil ctlops nil) (EX const-decl "bool" ctlops nil) (<= const-decl "bool" mucalculus nil) (monotonic? const-decl "bool" mucalculus nil)) shostak (EG subtype "LAMBDA Q: (LAMBDA (s: ctlops.state): booleans.AND(ctlops.f(s), ctlops.EX(ctlops.N, ctlops.Q)(s)))" "(mucalculus[ctlops.state].monotonic?)"))) (EU_TCC1 0 (EU_TCC1-1 nil 3242699046 ("" (grind :if-match nil) (("" (inst 2 "v!1") (("" (assert) (("" (inst -1 "v!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((state formal-type-decl nil ctlops nil) (monotonic? const-decl "bool" mucalculus nil) (<= const-decl "bool" mucalculus nil) (EX const-decl "bool" ctlops nil)) shostak (EU subtype "LAMBDA Q: (LAMBDA (s1: ctlops.state): booleans.OR(ctlops.g(s1), booleans.AND(ctlops.f(s1), ctlops.EX(ctlops.N, ctlops.Q)(s1))))" "(mucalculus[ctlops.state].monotonic?)"))))(fairctlops (fairEG_TCC1 0 (fairEG_TCC1-1 nil 3242699046 ("" (grind :if-match nil) (("" (inst -2 "p!1") (("" (assert) (("" (skosimp*) (("" (prop) (("1" (skosimp*) (("1" (inst -6 "s!2") (("1" (assert) (("1" (flatten) (("1" (inst -5 "v!1") (("1" (inst 2 "v!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -5 "s!2") (("2" (assert) (("2" (flatten) (("2" (inst 3 "v!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (state formal-type-decl nil fairctlops nil) (monotonic? const-decl "bool" mucalculus nil) (glb const-decl "pred[T]" mucalculus nil) (member const-decl "bool" sets nil) (EU const-decl "pred[state]" ctlops nil) (mu const-decl "pred[T]" mucalculus nil) (lfp const-decl "pred[T]" mucalculus nil) (<= const-decl "bool" mucalculus nil) (EX const-decl "bool" ctlops nil)) shostak (fairEG subtype "LAMBDA P: ctlops[fairctlops.state].EU(fairctlops.N, fairctlops.f, LAMBDA (s1: fairctlops.state): booleans.AND(fairctlops.f(s1), booleans.AND(fairctlops.Ff(s1), ctlops[fairctlops.state].EX(fairctlops.N, fairctlops.P)(s1))))" "(mucalculus[fairctlops.state].monotonic?)"))))(Fairctlops (CheckFair_TCC1 0 (CheckFair_TCC1-1 nil 3237052399 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil)) nil (CheckFair termination "Fairctlops.CheckFair(Fairctlops.Q, Fairctlops.N, Fairctlops.f, Fairctlops.Gflist)" "nil"))) (FairEG_TCC1 0 (FairEG_TCC1-1 nil 3242699046 ("" (induct "Fflist") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("2" (inst -3 "p!1") (("2" (assert) (("2" (skosimp*) (("2" (inst -4 "s!2") (("2" (assert) (("2" (flatten) (("2" (prop) (("2" (skosimp*) (("2" (inst -5 "N!1" "f!1") (("2" (inst -5 "p1!1" "p2!1") (("2" (assert) (("2" (replace -6) (("2" (inst -5 "v!1") (("2" (assert) (("2" (inst 2 "v!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((EX const-decl "bool" ctlops nil) (lfp const-decl "pred[T]" mucalculus nil) (mu const-decl "pred[T]" mucalculus nil) (EU const-decl "pred[state]" ctlops nil) (member const-decl "bool" sets nil) (glb const-decl "pred[T]" mucalculus nil) (<= const-decl "bool" mucalculus nil) (list_induction formula-decl nil list_adt nil) (state formal-type-decl nil Fairctlops nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (CheckFair def-decl "pred[state]" Fairctlops nil) (monotonic? const-decl "bool" mucalculus nil) (predicate_transformer type-eq-decl nil mucalculus nil) (list type-decl nil list_adt nil)) shostak (FairEG subtype "LAMBDA P: Fairctlops.CheckFair(Fairctlops.P, Fairctlops.N, Fairctlops.f, Fairctlops.Fflist)" "(mucalculus[Fairctlops.state].monotonic?)"))))(bit (bit_cases 0 (bit_cases-1 nil 3242701078 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)))(bv)(bv_concat_def (oh_TCC1 0 (oh_TCC1-1 nil 3242699046 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (m formal-const-decl "nat" bv_concat_def nil) (n formal-const-decl "nat" bv_concat_def nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (oh subtype "(number_fields.-)(bv_concat_def.nm, bv_concat_def.m)" "naturalnumbers.below(bv_concat_def.n)"))))(bv_bitwise (bv_OR 0 (bv_OR-1 nil 3242702892 ("" (grind) nil nil) ((OR const-decl "bvec[N]" bv_bitwise nil) (^ const-decl "bit" bv nil)) shostak)) (bv_AND 0 (bv_AND-1 nil 3242702898 ("" (grind) nil nil) ((AND const-decl "bvec[N]" bv_bitwise nil) (^ const-decl "bit" bv nil)) shostak)) (bv_IFF 0 (bv_IFF-1 nil 3242702904 ("" (grind) nil nil) ((IFF const-decl "bvec[N]" bv_bitwise nil) (^ const-decl "bit" bv nil)) shostak)) (bv_XOR 0 (bv_XOR-1 nil 3242702908 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil) (XOR const-decl "bool" xor_def nil) (XOR const-decl "bvec[N]" bv_bitwise nil) (^ const-decl "bit" bv nil)) shostak)) (bv_NOT 0 (bv_NOT-1 nil 3242702912 ("" (grind) nil nil) ((NOT const-decl "bvec[N]" bv_bitwise nil) (^ const-decl "bit" bv nil)) shostak)))(bv_nat (bv2nat_rec_TCC1 0 (bv2nat_rec_TCC1-1 nil 3242699046 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (bv2nat_rec subtype "(number_fields.-)(bv_nat.n, 1)" "nat"))) (bv2nat_rec_TCC2 0 (bv2nat_rec_TCC2-1 nil 3242699046 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (bv2nat_rec subtype "((number_fields.-)(bv_nat.n, 1))" "below[N]"))) (bv2nat_rec_TCC3 0 (bv2nat_rec_TCC3-1 nil 3242699046 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (bv2nat_rec subtype "(number_fields.-)(bv_nat.n, 1)" "naturalnumbers.upto(bv_nat.N)"))) (bv2nat_rec_TCC4 0 (bv2nat_rec_TCC4-1 nil 3242699046 ("" (grind) nil nil) nil shostak (bv2nat_rec termination "bv_nat.bv2nat_rec((number_fields.-)(bv_nat.n, 1), bv_nat.bv)" "nil"))) (bv2nat_rec_TCC5 0 (bv2nat_rec_TCC5-1 nil 3242699046 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (bv2nat_rec subtype "(number_fields.+)(number_fields.*(exp2.exp2((number_fields.-)(bv_nat.n, 1)), bit.b2n(bv[bv_nat.N].^(bv_nat.bv, ((number_fields.-)(bv_nat.n, 1))))), bv_nat.bv2nat_rec((number_fields.-)(bv_nat.n, 1), bv_nat.bv))" "nat"))) (bv_lem 0 (bv_lem-1 nil 3242703392 ("" (skosimp) (("" (assert) nil nil)) nil) nil shostak)) (bv2nat_rec_bound 0 (bv2nat_rec_bound-1 nil 3242703427 ("" (induct-and-rewrite "n" 1 "bv2nat_rec" "exp2") (("" (lemma "bv_lem") (("" (inst - "jt!1" "bv!1") (("" (expand "^") (("" (expand "b2n") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((bv_lem formula-decl nil bv_nat nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rec def-decl "nat" bv_nat nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (N formal-const-decl "nat" bv_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (upto_induction formula-decl nil bounded_nat_inductions nil)) shostak)) (bv2nat_TCC1 0 (bv2nat_TCC1-1 nil 3242699046 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (bv2nat subtype "bv_nat.N" "naturalnumbers.upto(bv_nat.N)"))) (bv2nat_TCC2 0 (bv2nat_TCC2-1 nil 3242699046 ("" (skosimp*) (("" (rewrite "bv2nat_rec_bound") nil nil)) nil) ((bv2nat_rec_bound formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil)) shostak (bv2nat subtype "bv_nat.bv2nat_rec(bv_nat.N, bv_nat.bv)" "naturalnumbers.below(exp2.exp2(bv_nat.N))"))) (bv2nat_inj_rec 0 (bv2nat_inj_rec-1 nil 3242703463 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "bv2nat_rec" +) (("2" (expand "^") (("2" (inst - "bv1!1" "bv2!1") (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (assert) (("1" (expand "b2n") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "jt!1") (("2" (assert) nil nil)) nil) ("3" (hide 2 3) (("3" (lemma "bv2nat_rec_bound") (("3" (inst-cp - "jt!1" "bv1!1") (("3" (inst - "jt!1" "bv2!1") (("3" (lemma "bv_lem") (("3" (inst-cp - "jt!1" "bv1!1") (("3" (inst - "jt!1" "bv2!1") (("3" (expand "b2n") (("3" (lift-if) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv_lem formula-decl nil bv_nat nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_rec def-decl "nat" bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil)) shostak)) (bv2nat_surj_rec 0 (bv2nat_surj_rec-1 nil 3242703513 ("" (induct "n" 1 "upto_induction[N]") (("1" (skosimp*) (("1" (typepred "y!1") (("1" (grind) (("1" (inst 1 "fill[N](FALSE)") nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "y!1") (("2" (expand "exp2") (("2" (expand "bv2nat_rec" +) (("2" (case "FORALL bv,(b:bit),(n:below(N)),(m:{n1:below(N)|n<=n1}):
                   bv2nat_rec(n,bv)=bv2nat_rec(n,bv with [(m):=b])") (("1" (case "y!1<exp2(jt!1)") (("1" (inst -5 "y!1") (("1" (skosimp*) (("1" (inst + "bv!1 with [(jt!1):= FALSE]") (("1" (inst?) (("1" (expand "^") (("1" (assert) (("1" (assert) (("1" (expand "b2n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "y!1-exp2(jt!1)") (("1" (expand "^") (("1" (skosimp*) (("1" (inst + "bv!1 with [(jt!1):= TRUE]") (("1" (inst?) (("1" (expand "b2n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (induct-and-rewrite "n" 1 "bv2nat_rec" "^") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (jt!1 skolem-const-decl "upto(N)" bv_nat nil) (y!1 skolem-const-decl "below(exp2(1 + jt!1))" bv_nat nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below_induction formula-decl nil bounded_nat_inductions nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil)) shostak)) (bv2nat_inj 0 (bv2nat_inj-1 nil 3242703551 ("" (expand "bv2nat") (("" (skolem 1 ("x!1" "y!1")) (("" (rewrite "bv2nat_inj_rec") (("" (flatten) (("" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_inj_rec formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) shostak)) (bv2nat_surj 0 (bv2nat_surj-1 nil 3242703576 ("" (expand "bv2nat") (("" (skolem!) (("" (rewrite "bv2nat_surj_rec") nil nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_surj_rec formula-decl nil bv_nat nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) shostak)) (bv2nat_bij 0 (bv2nat_bij-1 nil 3242703599 ("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (rewrite "bv2nat_inj") nil nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (rewrite "bv2nat_surj") nil nil)) nil)) nil)) nil)) nil) ((bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_inj formula-decl nil bv_nat nil) (injective? const-decl "bool" functions nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (bv2nat_surj formula-decl nil bv_nat nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) shostak)) (bv2nat_rec_fill_F 0 (bv2nat_rec_fill_F-1 nil 3242703627 ("" (induct-and-rewrite "n" 1 "bv2nat_rec" "fill" "^" "b2n") nil nil) ((<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rec def-decl "nat" bv_nat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (N formal-const-decl "nat" bv_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (bv2nat_rec_fill_T 0 (bv2nat_rec_fill_T-1 nil 3242703658 ("" (induct-and-rewrite "n" 1 "bv2nat_rec" "fill" "^" "b2n") (("1" (expand "exp2") (("1" (propax) nil nil)) nil) ("2" (expand "exp2" 1 2) (("2" (assert) nil nil)) nil)) nil) ((even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rec def-decl "nat" bv_nat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (TRUE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (N formal-const-decl "nat" bv_nat nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (upto_induction formula-decl nil bounded_nat_inductions nil)) shostak)) (bv2nat_fill_F 0 (bv2nat_fill_F-1 nil 3242703711 ("" (expand "bv2nat") (("" (rewrite "bv2nat_rec_fill_F") nil nil)) nil) ((bv2nat_rec_fill_F formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) shostak)) (bv2nat_fill_T 0 (bv2nat_fill_T-1 nil 3242703727 ("" (expand "bv2nat") (("" (rewrite "bv2nat_rec_fill_T") nil nil)) nil) ((bv2nat_rec_fill_T formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) shostak)) (bv2nat_eq0 0 (bv2nat_eq0-1 nil 3242703746 ("" (skosimp*) (("" (rewrite "bv2nat_inj") (("" (hide 2) (("" (rewrite "bv2nat_fill_F") nil nil)) nil)) nil)) nil) ((bv2nat_inj formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat nil)) shostak)) (bv2nat_eq_max 0 (bv2nat_eq_max-1 nil 3242703767 ("" (skosimp*) (("" (rewrite "bv2nat_inj") (("" (hide 2) (("" (rewrite "bv2nat_fill_T") nil nil)) nil)) nil)) nil) ((bv2nat_inj formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_fill_T formula-decl nil bv_nat nil)) shostak)) (bv2nat_top_bit_TCC1 0 (bv2nat_top_bit_TCC1-1 nil 3242699047 ("" (grind) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (bv2nat_top_bit subtype "(number_fields.-)(bv_nat.N, 1)" "nat"))) (bv2nat_top_bit_TCC2 0 (bv2nat_top_bit_TCC2-1 nil 3242699047 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (bv2nat_top_bit subtype "((number_fields.-)(bv_nat.N, 1))" "below[N]"))) (bv2nat_top_bit_TCC3 0 (bv2nat_top_bit_TCC3-1 nil 3242699047 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (bv2nat_top_bit subtype "((number_fields.-)(bv_nat.N, 1))" "below[N]"))) (bv2nat_top_bit 0 (bv2nat_top_bit-1 nil 3242703785 ("" (skosimp*) (("" (expand "^") (("" (expand "bv2nat") (("" (expand "bv2nat_rec") (("" (lift-if) (("" (assert) (("" (lemma "bv_lem") (("" (inst?) (("" (prop) (("1" (expand "b2n") (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "b2n") (("2" (expand "^") (("2" (assert) (("2" (rewrite "bv2nat_rec_bound") nil nil)) nil)) nil)) nil) ("3" (expand "b2n") (("3" (expand "^") (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (^ const-decl "bit" bv nil) (nil application-judgement "above(n)" exp2 nil) (bv2nat_rec def-decl "nat" bv_nat nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (b2n const-decl "nbit" bit nil) (bv_lem formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) shostak)) (bv2nat_topbit_TCC1 0 (bv2nat_topbit_TCC1-1 nil 3242699047 ("" (grind) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (bv2nat_topbit subtype "((number_fields.-)(bv_nat.N, 1))" "below[N]"))) (bv2nat_topbit 0 (bv2nat_topbit-1 nil 3242703825 ("" (skosimp*) (("" (lemma "bv2nat_top_bit") (("" (inst?) (("" (assert) (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((bv2nat_top_bit formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (nat2bv_TCC1 0 (nat2bv_TCC1-3 "" 3471680341 ("" (inst 1 "inverse(bv2nat)") (("" (skosimp*) (("" (lemma "bijective_inverse[bvec[N],below(exp2(N))]") (("" (inst -1 "inverse[bvec[N], below(exp2(N))](bv2nat)(x1!1)" "x1!1" "bv2nat") (("1" (ground) nil nil) ("2" (hide 2) (("2" (lemma "bv2nat_bij") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (bv2nat_bij formula-decl nil bv_nat nil) (bijective_inverse formula-decl nil function_inverse nil) (inverse const-decl "D" function_inverse nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil)) shostak (nat2bv existence "" "[val: naturalnumbers.below(exp2.exp2(bv_nat.N)) -> {bv: bv[bv_nat.N].bvec | bv_nat.bv2nat(bv) = val}]")) (nat2bv_TCC1-2 "" 3458165475 ("" (inst 1 "inverse(bv2nat)") (("" (skosimp*) (("" (lemma "bijective_inverse[bvec[N],below(exp2(N))]") (("" (inst -1 "x1!1" "inverse[bvec[N], below(exp2(N))](bv2nat)(x1!1)" "bv2nat") (("1" (ground) nil nil) ("2" (hide 2) (("2" (lemma "bv2nat_bij") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (bv2nat_bij formula-decl nil bv_nat nil) (bijective_inverse formula-decl nil function_inverse nil) (inverse const-decl "D" function_inverse nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (nat2bv existence "" "[val: naturalnumbers.below(exp2.exp2(bv_nat.N)) -> {bv: bv[bv_nat.N].bvec | bv_nat.bv2nat(bv) = val}]")) (nat2bv_TCC1-1 nil 3242699047 ("" (inst 1 "inverse(bv2nat)") (("" (skosimp*) (("" (lemma "bijective_inverse[bvec[N],below(exp2(N))]") (("" (inst -1 "inverse[bvec[N], below(exp2(N))](bv2nat)(x1!1)" "x1!1" "bv2nat") (("1" (ground) nil nil) ("2" (hide 2) (("2" (lemma "bv2nat_bij") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (bv2nat_bij formula-decl nil bv_nat nil) (bijective_inverse formula-decl nil function_inverse nil) (inverse const-decl "D" function_inverse nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (nat2bv existence "" "[val: naturalnumbers.below(exp2.exp2(bv_nat.N)) -> {bv: bv[bv_nat.N].bvec | bv_nat.bv2nat(bv) = val}]"))) (nat2bv_def 0 (nat2bv_def-1 nil 3242703848 ("" (apply-extensionality 1 :hide? t) (("1" (typepred "nat2bv(x!1)") (("1" (expand "inverse") (("1" (lemma "epsilon_ax[bvec[N]]") (("1" (inst?) (("1" (split -1) (("1" (rewrite "bv2nat_inj") nil nil) ("2" (hide 2) (("2" (inst 1 "nat2bv(x!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "inverse") (("2" (lemma "epsilon_ax[bvec[N]]") (("2" (inst?) (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (inst 1 "nat2bv(x1!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (epsilon_ax formula-decl nil epsilons nil) (bv2nat_inj formula-decl nil bv_nat nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (inverse const-decl "D" function_inverse nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (nat2bv_bij 0 (nat2bv_bij-1 nil 3242703876 ("" (lemma "bv2nat_bij") (("" (rewrite "nat2bv_def") (("" (rewrite "bij_inv_is_bij") nil nil)) nil)) nil) ((nat2bv_def formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bij_inv_is_bij formula-decl nil function_inverse nil) (bv2nat_bij formula-decl nil bv_nat nil)) shostak)) (nat2bv_inv 0 (nat2bv_inv-1 nil 3242703899 ("" (skosimp*) (("" (typepred "nat2bv(bv2nat(bv!1))") (("" (rewrite "bv2nat_inj") nil nil)) nil)) nil) ((nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bv2nat_inj formula-decl nil bv_nat nil)) shostak)) (nat2bv_rew 0 (nat2bv_rew-1 nil 3242703922 ("" (skosimp*) (("" (typepred "nat2bv(val!1)") (("" (prop) (("1" (assert) nil nil) ("2" (rewrite "bv2nat_inj") nil nil)) nil)) nil)) nil) ((nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_nat nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bv2nat_inj formula-decl nil bv_nat nil)) shostak)) (bv2nat_inv 0 (bv2nat_inv-1 nil 3242703948 ("" (skosimp*) (("" (assert) nil nil)) nil) nil shostak)))(empty_bv)(bv_caret (caret_TCC1 0 (caret_TCC1-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (caret subtype "(number_fields.+)((number_fields.-)(1, PROJ_2(bv_caret.sp)), PROJ_1(bv_caret.sp))" "nat"))) (caret_TCC2 0 (caret_TCC2-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_caret nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (caret subtype "(number_fields.+)(bv_caret.ii, PROJ_2(bv_caret.sp))" "naturalnumbers.below(bv_caret.N)"))) (bv_caret_all_TCC1 0 (bv_caret_all_TCC1-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (bv_caret_all subtype "(number_fields.-)(bv_caret.N, 1)" "naturalnumbers.below(bv_caret.N)"))) (bv_caret_all_TCC2 0 (bv_caret_all_TCC2-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (bv_caret_all subtype "0" "naturalnumbers.upto((number_fields.-)(bv_caret.N, 1))"))) (bv_caret_all 0 (bv_caret_all-1 nil 3242704209 ("" (skosimp*) (("" (expand "^") (("" (apply-extensionality 1 :hide? t) nil nil)) nil)) nil) ((^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" bv_caret nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (bv_caret_ii_0_TCC1 0 (bv_caret_ii_0_TCC1-1 nil 3242699047 ("" (subtype-tcc) nil nil) nil shostak (bv_caret_ii_0 subtype "bv_caret.i" "naturalnumbers.upto(bv_caret.i)"))) (bv_caret_ii_0 0 (bv_caret_ii_0-1 nil 3242704230 ("" (skosimp*) (("" (expand "^") (("" (propax) nil nil)) nil)) nil) ((^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil)) shostak)) (bv_caret_elim_TCC1 0 (bv_caret_elim_TCC1-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (bv_caret_elim subtype "(number_fields.-)((number_fields.+)(1, bv_caret.i), bv_caret.j)" "nat"))) (bv_caret_elim_TCC2 0 (bv_caret_elim_TCC2-1 nil 3242699047 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (bv_caret_elim subtype "((number_fields.+)(bv_caret.j, bv_caret.k))" "below[N]"))) (bv_caret_elim 0 (bv_caret_elim-1 nil 3242704247 ("" (skosimp*) (("" (expand "^") (("" (propax) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)))(integer_bv_ops (u16xor_TCC1 0 (u16xor_TCC1-1 nil 3835419966 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (u16xor subtype "integer_bv_ops.x16" "naturalnumbers.below(exp2.exp2(16))"))) (u16xor_TCC2 0 (u16xor_TCC2-1 nil 3835419966 ("" (skeep) (("" (lemma "bv2nat_rec_bound[16]") (("" (expand "bv2nat") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((bv2nat_rec_bound formula-decl nil bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (XOR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint16 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16xor subtype "bv_nat[16].bv2nat((bv_bitwise[16].XOR(bv_nat[16].nat2bv(integer_bv_ops.x16), bv_nat[16].nat2bv(integer_bv_ops.y16))))" "uint16"))) (u32xor_TCC1 0 (u32xor_TCC1-1 nil 3835419966 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (u32xor subtype "integer_bv_ops.x32" "naturalnumbers.below(exp2.exp2(32))"))) (u32xor_TCC2 0 (u32xor_TCC2-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (lemma "bv2nat_rec_bound[32]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (XOR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint32 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32xor subtype "bv_nat[32].bv2nat((bv_bitwise[32].XOR(bv_nat[32].nat2bv(integer_bv_ops.x32), bv_nat[32].nat2bv(integer_bv_ops.y32))))" "uint32"))) (u64xor_TCC1 0 (u64xor_TCC1-1 nil 3835419966 ("" (subtype-tcc) nil nil) ((nil application-judgement "above(n)" exp2 nil)) shostak (u64xor subtype "integer_bv_ops.x64" "naturalnumbers.below(exp2.exp2(64))"))) (u64xor_TCC2 0 (u64xor_TCC2-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (lemma "bv2nat_rec_bound[64]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (XOR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint64 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64xor subtype "bv_nat[64].bv2nat((bv_bitwise[64].XOR(bv_nat[64].nat2bv(integer_bv_ops.x64), bv_nat[64].nat2bv(integer_bv_ops.y64))))" "uint64"))) (u16and_TCC1 0 (u16and_TCC1-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (lemma "bv2nat_rec_bound[16]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint16 type-eq-decl nil integertypes nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16and subtype "bv_nat[16].bv2nat((bv_bitwise[16].AND(bv_nat[16].nat2bv(integer_bv_ops.x16), bv_nat[16].nat2bv(integer_bv_ops.y16))))" "uint16"))) (u32and_TCC1 0 (u32and_TCC1-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[32]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint32 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32and subtype "bv_nat[32].bv2nat((bv_bitwise[32].AND(bv_nat[32].nat2bv(integer_bv_ops.x32), bv_nat[32].nat2bv(integer_bv_ops.y32))))" "uint32"))) (u64and_TCC1 0 (u64and_TCC1-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[64]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint64 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64and subtype "bv_nat[64].bv2nat((bv_bitwise[64].AND(bv_nat[64].nat2bv(integer_bv_ops.x64), bv_nat[64].nat2bv(integer_bv_ops.y64))))" "uint64"))) (u16or_TCC1 0 (u16or_TCC1-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[16]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (OR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint16 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16or subtype "bv_nat[16].bv2nat((bv_bitwise[16].OR(bv_nat[16].nat2bv(integer_bv_ops.x16), bv_nat[16].nat2bv(integer_bv_ops.y16))))" "uint16"))) (u32or_TCC1 0 (u32or_TCC1-1 nil 3835419966 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[32]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (OR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint32 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32or subtype "bv_nat[32].bv2nat((bv_bitwise[32].OR(bv_nat[32].nat2bv(integer_bv_ops.x32), bv_nat[32].nat2bv(integer_bv_ops.y32))))" "uint32"))) (u64or_TCC1 0 (u64or_TCC1-1 nil 3835419967 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[64]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (OR const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint64 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64or subtype "bv_nat[64].bv2nat((bv_bitwise[64].OR(bv_nat[64].nat2bv(integer_bv_ops.x64), bv_nat[64].nat2bv(integer_bv_ops.y64))))" "uint64"))) (u16not_TCC1 0 (u16not_TCC1-1 nil 3835419967 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[16]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (NOT const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint16 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u16not subtype "bv_nat[16].bv2nat((bv_bitwise[16].NOT)(bv_nat[16].nat2bv(integer_bv_ops.x16)))" "uint16"))) (u32not_TCC1 0 (u32not_TCC1-1 nil 3835419967 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[32]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (NOT const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint32 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u32not subtype "bv_nat[32].bv2nat((bv_bitwise[32].NOT)((bv_nat[32].nat2bv(integer_bv_ops.x32))))" "uint32"))) (u64not_TCC1 0 (u64not_TCC1-1 nil 3835419967 ("" (skeep) (("" (expand "bv2nat") (("" (use "bv2nat_rec_bound[64]") (("" (assert) nil nil)) nil)) nil)) nil) ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (NOT const-decl "bvec[N]" bv_bitwise nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (uint64 type-eq-decl nil integertypes nil) (bv2nat_rec_bound formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil)) shostak (u64not subtype "bv_nat[64].bv2nat((bv_bitwise[64].NOT)((bv_nat[64].nat2bv(integer_bv_ops.x64))))" "uint64"))))(mod (ml3 0 (ml3-1 nil 3341424447 ("" (skolem!) (("" (expand "abs") (("" (lemma "both_sides_times_pos_lt1") (("" (lift-if) (("" (ground) (("1" (inst - "m!1" "floor(i!1 / m!1)" "i!1 / m!1") (("1" (assert) nil nil)) nil) ("2" (inst - "m!1" "i!1 / m!1" "1 + floor(i!1 / m!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (ml4 0 (ml4-1 nil 3341424588 ("" (skolem!) (("" (expand "abs") (("" (lemma "both_sides_times_pos_lt1") (("" (lift-if) (("" (ground) (("1" (inst - "m!1" "-i!1 / m!1" "1 + floor(-i!1 / m!1)") (("1" (assert) nil nil)) nil) ("2" (inst - "m!1" "floor(-i!1 / m!1)" "-i!1 / m!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (mod_TCC1 0 (mod_TCC1-1 nil 3341424436 ("" (skolem!) (("" (case "j!1 >= 0") (("1" (assert) (("1" (use "ml3") (("1" (expand "abs") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "ml4") (("2" (inst - "i!1" "-j!1") (("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ml3 formula-decl nil mod nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (ml4 formula-decl nil mod nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (mod subtype "(number_fields.-)(mod.i, number_fields.*(mod.j, floor_ceil.floor(number_fields./(mod.i, mod.j))))" "{k | reals.<(real_defs.abs(mod.k), real_defs.abs(mod.j))}"))) (mod_pos 0 (mod_pos-1 nil 3341424826 ("" (skolem!) (("" (typepred "mod(i!1, m!1)") (("" (tcc) (("" (lemma "both_sides_times_pos_le1") (("" (inst - "m!1" "floor(i!1 / m!1)" "i!1 / m!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (mod_TCC2 0 (mod_TCC2-1 nil 3341424436 ("" (skolem!) (("" (rewrite "mod_pos") nil nil)) nil) ((mod_pos formula-decl nil mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil)) nil (mod_ subtype "mod.mod(mod.i, mod.m)" "naturalnumbers.below(mod.m)"))) (mod_even 0 (mod_even-1 nil 3341424996 ("" (skosimp) (("" (expand "mod") (("" (rewrite "floor_int") (("" (assert) nil nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_int formula-decl nil floor_ceil nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) shostak)) (mod_neg 0 (mod_neg-1 nil 3341425033 ("" (auto-rewrite-theory "integers") (("" (skolem!) (("" (lift-if) (("" (expand "mod") (("" (case "-i!1 / j!1 = -(i!1 / j!1)") (("1" (replace -1) (("1" (ground) (("1" (rewrite "floor_int") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "floor_neg") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (floor_neg formula-decl nil floor_ceil nil) (integer? const-decl "bool" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (closed_neg formula-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (floor_int formula-decl nil floor_ceil nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil)) shostak)) (mod_neg_d 0 (mod_neg_d-2 "" 3505099237 ("" (auto-rewrite-theory "integers") (("" (skolem!) (("" (lift-if) (("" (expand "mod") (("" (case "i!1 / -j!1 = -(i!1 / j!1)") (("1" (replace -1) (("1" (rewrite "floor_neg") (("1" (lift-if) (("1" (ground) (("1" (rewrite "floor_int") (("1" (assert) nil nil)) nil) ("2" (case "integer_pred(--(i!1 / j!1))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (ground) (("3" (case "integer_pred(--(i!1 / j!1))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (integer nonempty-type-from-decl nil integers nil) (floor_int formula-decl nil floor_ceil nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (closed_neg formula-decl nil integers nil) (integer? const-decl "bool" integers nil) (minus_int_is_int application-judgement "int" integers nil) (floor_neg formula-decl nil floor_ceil nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonzero_integer nonempty-type-eq-decl nil integers nil)) shostak) (mod_neg_d-1 nil 3341425208 ("" (auto-rewrite-theory "integers") (("" (skolem!) (("" (lift-if) (("" (expand "mod") (("" (case "i!1 / -j!1 = -(i!1 / j!1)") (("1" (replace -1) (("1" (rewrite "floor_neg") (("1" (lift-if) (("1" (ground) (("1" (rewrite "floor_int") (("1" (assert) nil nil)) nil) ("2" (case "integer_pred(--(i!1 / j!1))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (integer nonempty-type-from-decl nil integers nil) (floor_int formula-decl nil floor_ceil nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (closed_neg formula-decl nil integers nil) (minus_int_is_int application-judgement "int" integers nil) (integer? const-decl "bool" integers nil) (floor_neg formula-decl nil floor_ceil nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonzero_integer nonempty-type-eq-decl nil integers nil)) shostak)) (mod_eq_arg 0 (mod_eq_arg-1 nil 3341425474 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (mod_lt 0 (mod_lt-1 nil 3341425485 ("" (grind :rewrites ("floor_small" "pos_div_ge")) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (sgn const-decl "int" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (floor_small formula-decl nil floor_ceil nil) (pos_div_ge formula-decl nil real_props nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (mod_lt_nat 0 (mod_lt_nat-1 nil 3341425653 ("" (skosimp) (("" (rewrite "mod_lt") (("1" (expand "sgn") (("1" (propax) nil nil)) nil) ("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil) ((mod_lt formula-decl nil mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nil application-judgement "below(m)" mod nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sgn const-decl "int" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak)) (mod_lt_int 0 (mod_lt_int-1 nil 3341425710 ("" (skosimp) (("" (rewrite "mod_lt") (("1" (expand "sgn") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ((mod_lt formula-decl nil mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "below(m)" mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sgn const-decl "int" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak)) (mod_sum_pos 0 (mod_sum_pos-1 nil 3341425771 ("" (skolem!) (("" (expand "mod") (("" (lemma "floor_plus_int") (("" (inst - "k!1 * m!1 / m!1" "i!1 / m!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (floor_plus_int formula-decl nil floor_ceil nil)) shostak)) (mod_gt 0 (mod_gt-1 nil 3341425822 ("" (skosimp) (("" (lemma "mod_sum_pos") (("" (inst - "i!1" -1 "m!1") (("" (replace -1 * rl) (("" (rewrite "mod_lt_int") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mod_sum_pos formula-decl nil mod nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (nil application-judgement "below(m)" mod nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mod_lt_int formula-decl nil mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (mod_sum 0 (mod_sum-1 nil 3341425866 ("" (skolem!) (("" (expand "mod") (("" (lemma "floor_plus_int") (("" (inst - "k!1 * j!1 / j!1" "i!1 / j!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (floor_plus_int formula-decl nil floor_ceil nil)) shostak)) (mod_sum_nat 0 (mod_sum_nat-1 nil 3341425900 ("" (skolem!) (("" (lift-if) (("" (ground) (("1" (rewrite "mod_lt_nat") nil nil) ("2" (lemma "mod_sum") (("2" (inst - "n1!1 + n2!1" "m!1" -1) (("2" (rewrite "mod_lt_nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mod_sum formula-decl nil mod nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (mod_lt_nat formula-decl nil mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (mod_it_is 0 (mod_it_is-1 nil 3341425969 ("" (skosimp) (("" (replace -1) (("" (hide -1) (("" (lemma "mod_sum") (("" (inst - "b!1" "m!1" "c!1") (("" (replace -1) (("" (hide -1) (("" (rewrite "mod_lt") (("1" (expand "sgn") (("1" (propax) nil nil)) nil) ("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mod_sum formula-decl nil mod nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod_lt formula-decl nil mod nil) (nil application-judgement "below(m)" mod nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sgn const-decl "int" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (mod_zero 0 (mod_zero-1 nil 3341426079 ("" (tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (mod_one 0 (mod_one-1 nil 3341426091 ("" (grind :rewrites ("floor_small" "pos_div_ge")) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (floor_small formula-decl nil floor_ceil nil) (pos_div_ge formula-decl nil real_props nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (mod_of_mod 0 (mod_of_mod-1 nil 3341426141 ("" (skolem!) (("" (rewrite "mod") (("" (lemma "mod_sum") (("" (inst - "i!1 + k!1" "m!1" "-floor(k!1 / m!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((mod const-decl "{k | abs(k) < abs(j)}" mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nil application-judgement "below(m)" mod nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (mod_sum formula-decl nil mod nil)) shostak)) (mod_of_mod_neg 0 (mod_of_mod_neg-1 nil 3341426188 ("" (skolem!) (("" (rewrite "mod") (("" (lemma "mod_sum") (("" (inst - "i!1 - k!1" "m!1" "floor(k!1 / m!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((mod const-decl "{k | abs(k) < abs(j)}" mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nil application-judgement "below(m)" mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod_sum formula-decl nil mod nil)) shostak)) (mod_inj_plus 0 (mod_inj_plus-1 nil 3341426229 ("" (skosimp) (("" (rewrite "mod_lt_nat") (("1" (rewrite "mod_lt_nat") (("1" (assert) nil nil) ("2" (rewrite "mod_gt") (("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "mod_gt") (("2" (rewrite "mod_lt_nat") (("1" (assert) nil nil) ("2" (rewrite "mod_gt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod_lt_nat formula-decl nil mod nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil application-judgement "below(m)" mod nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mod_gt formula-decl nil mod nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (mod_inj_minus 0 (mod_inj_minus-1 nil 3341426501 ("" (skosimp) (("" (expand "mod") (("" (rewrite "floor_small") (("1" (rewrite "floor_small") (("1" (grind) nil nil) ("2" (expand "abs") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_small formula-decl nil floor_ceil nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (mod_wrap_around 0 (mod_wrap_around-1 nil 3341426603 ("" (skosimp) (("" (expand "mod") (("" (use "floor_val" ("k" 1)) (("" (ground) nil nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_val formula-decl nil floor_ceil nil)) shostak)) (mod_wrap2 0 (mod_wrap2-1 nil 3388684876 ("" (skosimp*) (("" (expand "mod") (("" (case "(m!1 + c!1) / m!1 = 1 + c!1/m!1") (("1" (lemma "floor_plus_int") (("1" (inst -1 "1" "c!1/m!1") (("1" (lemma "floor_small") (("1" (inst?) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (floor_plus_int formula-decl nil floor_ceil nil) (floor_small formula-decl nil floor_ceil nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_plus_nnrat_is_posrat application-judgement "posrat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (mod_inj1 0 (mod_inj1-1 nil 3388685021 ("" (skosimp*) (("" (expand "mod") (("" (lemma "floor_val") (("" (case "floor((x!1 + n!1) / m!1) = 0 OR floor((x!1 + n!1) / m!1) = 1") (("1" (case "floor((x!1 + c!1) / m!1) = 0 OR floor((x!1 + c!1) / m!1) = 1") (("1" (ground) nil nil) ("2" (case "x!1 + c!1 < m!1") (("1" (flatten) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "x!1+c!1" "m!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 + n!1 < m!1") (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "x!1+n!1" "m!1" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (floor_val formula-decl nil floor_ceil nil)) shostak)) (mod_inj2 0 (mod_inj2-1 nil 3388685236 ("" (skosimp*) (("" (expand "mod") (("" (rewrite "floor_small") (("1" (rewrite "floor_small") (("1" (tcc-bdd) nil nil) ("2" (tcc-bdd) nil nil)) nil) ("2" (tcc-bdd) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (floor_small formula-decl nil floor_ceil nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (mod_wrap_inj 0 (mod_wrap_inj-1 nil 3341426657 ("" (skosimp) (("" (lemma "mod_lt") (("" (inst-cp - "n!1 - b!1" "m!1") (("" (inst - "n!1 + a!1" "m!1") (("" (use "mod_wrap_around") (("" (expand* "sgn" "abs") (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mod_lt formula-decl nil mod nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sgn const-decl "int" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (mod_wrap_around formula-decl nil mod nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (mod_wrap_inj_eq 0 (mod_wrap_inj_eq-1 nil 3388685722 ("" (skosimp) (("" (iff) (("" (ground) (("1" (lemma "mod_wrap_inj") (("1" (inst -1 "a!1" "b!1" "m!1" "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case-replace "a!1 = m!1 - b!1") (("1" (lemma "mod_sum") (("1" (inst -1 "x!1 - b!1" "m!1" "1") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mod_sum formula-decl nil mod nil) (mod_wrap_inj formula-decl nil mod nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (mod_neg_limited 0 (mod_neg_limited-1 nil 3388686624 ("" (skosimp*) (("" (lemma "mod_lt") (("" (inst?) (("" (expand "abs") (("" (assert) (("" (expand "sgn") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mod_lt formula-decl nil mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sgn const-decl "int" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "below(m)" mod nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (odd_mod 0 (odd_mod-1 nil 3388686712 ("" (skosimp*) (("" (expand "even?") (("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (expand "odd?") (("" (prop) (("1" (skosimp*) (("1" (expand "mod") (("1" (inst + "(floor(i!1 / (2 * j!1)) * j!1) + j!2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (expand "mod") (("2" (inst + "j!2 - (floor(i!1 / (2 * j!1)) * j!1)") (("1" (assert) nil nil) ("2" (reveal -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even? const-decl "bool" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (odd? const-decl "bool" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "int" mod nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (even_mod 0 (even_mod-1 nil 3388687032 ("" (skosimp*) (("" (rewrite "even_iff_not_odd" +) (("" (rewrite "even_iff_not_odd" +) (("" (use "odd_mod") (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((even_iff_not_odd formula-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nil application-judgement "below(m)" mod nil) (odd_mod formula-decl nil mod nil)) shostak)) (mod_mult 0 (mod_mult-1 nil 3341426873 ("" (skolem!) (("" (expand "mod") (("" (lemma "floor_plus_int") (("" (inst - "-floor(i!1 / (mj!1 * m!1)) * mj!1" "i!1 / m!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (floor_plus_int formula-decl nil floor_ceil nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) shostak)))(bv_arith_nat_defs (plus_TCC1 0 (plus_TCC1-1 nil 3364695166 ("" (inst + "LAMBDA (bv: bvec[N], i: int): nat2bv(mod(bv2nat(bv) + i, exp2(N)))") nil nil) ((nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_arith_nat_defs nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "below(m)" mod nil) (int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus existence "" "[d: [bvec[N], int] -> {bvn: bv[bv_arith_nat_defs.N].bvec | bv_nat[bv_arith_nat_defs.N].bv2nat(bvn) = mod.mod((number_fields.+)(d`2, bv_nat[bv_arith_nat_defs.N].bv2nat(d`1)), exp2.exp2(bv_arith_nat_defs.N))}]"))) (bv_plus 0 (bv_plus-1 nil 3364699615 ("" (skolem!) (("" (assert) nil nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (bv_minus 0 (bv_minus-1 nil 3364699637 ("" (expand "-") (("" (skolem!) (("" (rewrite "bv_plus") (("" (assert) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "below(m)" mod nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_arith_nat_defs nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv_plus formula-decl nil bv_arith_nat_defs nil) (- const-decl "bvec[N]" bv_arith_nat_defs nil) (minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (plus_TCC2 0 (plus_TCC2-1 nil 3364695166 ("" (inst + "LAMBDA (bv1, bv2: bvec[N]): nat2bv(IF bv2nat(bv1) + bv2nat(bv2) < exp2(N) THEN bv2nat(bv1) + bv2nat(bv2) ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N) ENDIF)") (("" (skosimp) (("" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_arith_nat_defs nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak (plus existence "" "[d: [bvec[N], bvec[N]] -> {bv: bv[bv_arith_nat_defs.N].bvec | bv_nat[bv_arith_nat_defs.N].bv2nat(bv) = IF reals.<((number_fields.+)(bv_nat[bv_arith_nat_defs.N].bv2nat(d`1), bv_nat[bv_arith_nat_defs.N].bv2nat(d`2)), exp2.exp2(bv_arith_nat_defs.N)) THEN (number_fields.+)(bv_nat[bv_arith_nat_defs.N].bv2nat(d`1), bv_nat[bv_arith_nat_defs.N].bv2nat(d`2)) ELSE (number_fields.-)((number_fields.+)(bv_nat[bv_arith_nat_defs.N].bv2nat(d`1), bv_nat[bv_arith_nat_defs.N].bv2nat(d`2)), exp2.exp2(bv_arith_nat_defs.N)) ENDIF}]"))) (times_TCC1 0 (times_TCC1-1 nil 3364695166 ("" (inst + "LAMBDA (bv1, bv2: bvec[N]): nat2bv[2 * N](bv2nat(bv1) * bv2nat(bv2))") (("" (skolem!) (("" (assert) (("" (lemma "lt_times_lt_pos1") (("" (inst?) (("" (inst - "exp2(N)" "exp2(N)") (("" (use "exp2_sum") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_times_lt_pos1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (exp2_sum formula-decl nil exp2 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (nat2bv const-decl "{bv: bvec[N] | bv2nat(bv) = val}" bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" bv_arith_nat_defs nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak (times existence "" "[d: [bvec[N], bvec[N]] -> {bv: bv[number_fields.*(2, bv_arith_nat_defs.N)].bvec | bv_nat[number_fields.*(2, bv_arith_nat_defs.N)].bv2nat(bv) = number_fields.*(bv_nat[bv_arith_nat_defs.N].bv2nat(d`1), bv_nat[bv_arith_nat_defs.N].bv2nat(d`2))}]"))))(bv_int_defs (minint_TCC1 0 (minint_TCC1-1 nil 3364695166 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (minint subtype "(number_fields.-)(bv_int_defs.N, 1)" "nat"))) (bv_maxint_to_minint 0 (bv_maxint_to_minint-1 nil 3364710000 ("" (expand* "maxint" "minint") (("" (assert) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil)) shostak)) (bv_minint_to_maxint 0 (bv_minint_to_maxint-1 nil 3364710014 ("" (expand* "maxint" "minint") (("" (assert) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (maxint const-decl "int" bv_int_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minint const-decl "int" bv_int_defs nil)) shostak)) (bv2int_TCC1 0 (bv2int_TCC1-1 nil 3364695166 ("" (subtype-tcc) nil nil) ((minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (bv2int subtype "bv_nat[bv_int_defs.N].bv2nat(bv_int_defs.bv)" "rng_2s_comp"))) (bv2int_TCC2 0 (bv2int_TCC2-1 nil 3364695166 ("" (skosimp) (("" (expand* "maxint" "minint") (("" (assert) (("" (expand "exp2" 2 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((minint const-decl "int" bv_int_defs nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (maxint const-decl "int" bv_int_defs nil) (exp2 def-decl "posnat" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil)) shostak (bv2int subtype "(number_fields.-)(bv_nat[bv_int_defs.N].bv2nat(bv_int_defs.bv), exp2.exp2(bv_int_defs.N))" "rng_2s_comp"))) (int2bv_TCC1 0 (int2bv_TCC1-1 nil 3364695167 ("" (inst + "LAMBDA (iv: rng_2s_comp): inverse(bv2int)(iv)") (("" (skolem!) (("" (case "bijective?(bv2int)") (("1" (use "bijective_inverse[bvec[N], rng_2s_comp]") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "bijective?") (("2" (prop) (("1" (expand "injective?") (("1" (skosimp) (("1" (expand "bv2int") (("1" (lemma "bv2nat_inj[N]") (("1" (inst -1 "x1!1" "x2!1") (("1" (smash) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skolem-typepred) (("2" (expand "maxint") (("2" (expand "minint") (("2" (lemma "bv2nat_surj[N]") (("2" (expand "bv2int") (("2" (case "y!1 >= 0") (("1" (inst -2 "y!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (expand "exp2" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "y!1 + exp2(N)") (("1" (skosimp) (("1" (inst 2 "x!1") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (expand "exp2" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "exp2" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2nat_inj formula-decl nil bv_nat nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (y!1 skolem-const-decl "rng_2s_comp" bv_int_defs nil) (exp2 def-decl "posnat" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bv2nat_surj formula-decl nil bv_nat nil) (surjective? const-decl "bool" functions nil) (bijective_inverse formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" bv_int_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil)) shostak (int2bv existence "" "[iv: bv_int_defs.rng_2s_comp -> {bv: bv[bv_int_defs.N].bvec | bv_int_defs.bv2int(bv) = iv}]"))))(bv_arithmetic_defs (difference_TCC1 0 (difference_TCC1-1 nil 3364695167 ("" (inst + "LAMBDA (bv: bvec[N]): int2bv(IF bv2int[N](bv) = minint[N] THEN bv2int[N](bv) ELSE -((bv2int[N](bv))) ENDIF)") (("" (skosimp) (("" (typepred "bv2int[N](bv!1)") (("" (expand* "minint" "maxint") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int2bv const-decl "{bv: bvec[N] | bv2int(bv) = iv}" bv_int_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bvec type-eq-decl nil bv nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil)) shostak (difference existence "" "[bv: bv[bv_arithmetic_defs.N].bvec -> {bvn: bv[bv_arithmetic_defs.N].bvec | bv_int_defs[bv_arithmetic_defs.N].bv2int(bvn) = IF bv_int_defs[bv_arithmetic_defs.N].bv2int(bv) = bv_int_defs[bv_arithmetic_defs.N].minint THEN bv_int_defs[bv_arithmetic_defs.N].bv2int(bv) ELSE (number_fields.-)((bv_int_defs[bv_arithmetic_defs.N].bv2int(bv))) ENDIF}]"))) (bv_splus_TCC1 0 (bv_splus_TCC1-1 nil 3369463698 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (overflow const-decl "bool" bv_arithmetic_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minint const-decl "int" bv_int_defs nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (maxint const-decl "int" bv_int_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (bv_splus subtype "(number_fields.+)(bv_int_defs[bv_arithmetic_defs.N].bv2int(bv_arithmetic_defs.bv1), bv_int_defs[bv_arithmetic_defs.N].bv2int(bv_arithmetic_defs.bv2))" "rng_2s_comp[N]"))) (bv_stimes_TCC1 0 (bv_stimes_TCC1-1 nil 3369463699 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (mult_overflow const-decl "bool" bv_arithmetic_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minint const-decl "int" bv_int_defs nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (maxint const-decl "int" bv_int_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (bv_stimes subtype "number_fields.*(bv_int_defs[bv_arithmetic_defs.N].bv2int(bv_arithmetic_defs.bv1), bv_int_defs[bv_arithmetic_defs.N].bv2int(bv_arithmetic_defs.bv2))" "rng_2s_comp[N]"))) (nat2bv_rec_TCC1 0 (nat2bv_rec_TCC1-1 nil 3726081087 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (below type-eq-decl nil naturalnumbers nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "upto(n)" modulo_arithmetic nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (nat2bv_rec subtype "modulo_arithmetic.ndiv(bv_arithmetic_defs.n, 2)" "naturalnumbers.below(exp2.exp2(bv_arithmetic_defs.N))"))) (nat2bv_rec_TCC2 0 (nat2bv_rec_TCC2-1 nil 3726081087 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (below type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (nat2bv_rec subtype "(number_fields.-)(bv_arithmetic_defs.idx, 1)" "naturalnumbers.below(bv_arithmetic_defs.N)"))) (nat2bv_rec_TCC3 0 (nat2bv_rec_TCC3-1 nil 3726081087 ("" (termination-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil)) shostak (nat2bv_rec termination "bv_arithmetic_defs.nat2bv_rec(modulo_arithmetic.ndiv(bv_arithmetic_defs.n, 2), bv_arithmetic_defs.nbv, (number_fields.-)(bv_arithmetic_defs.idx, 1))" "nil"))) (bv_TCC1 0 (bv_TCC1-1 nil 3726081087 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (N formal-const-decl "posnat" bv_arithmetic_defs nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (bv subtype "(number_fields.-)(bv_arithmetic_defs.N, 1)" "naturalnumbers.below(bv_arithmetic_defs.N)"))))(bv_extend_defs (zero_extend_TCC1 0 (zero_extend_TCC1-1 nil 3364695167 ("" (subtype-tcc) nil nil) nil shostak (zero_extend subtype "(number_fields.-)(bv_extend_defs.k, bv_extend_defs.N)" "nat"))) (sign_extend_TCC1 0 (sign_extend_TCC1-1 nil 3364695167 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (sign_extend subtype "((number_fields.-)(bv_extend_defs.N, 1))" "below[N]"))) (lsb_extend_TCC1 0 (lsb_extend_TCC1-1 nil 3364695167 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (lsb_extend subtype "0" "below[N]"))))(infinite_sets_def (infinite_nonempty 0 (infinite_nonempty-1 nil 3249344193 ("" (skolem-typepred) (("" (expand "nonempty?") (("" (rewrite "emptyset_is_empty?[T]") (("" (assert) nil nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_nonempty subtype "infinite_sets_def.x" "(sets[infinite_sets_def.T].nonempty?)"))) (infinite_add 0 (infinite_add-1 nil 3249344193 ("" (skolem-typepred) (("" (use "member_add[T]") (("" (assert) (("" (lemma "finite_remove[T]") (("" (inst - "add(t!1, Inf!1)" "t!1") (("" (use "remove_add_member[T]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member_add formula-decl nil sets_lemmas nil) (finite_remove judgement-tcc nil finite_sets nil) (remove_add_member formula-decl nil sets_lemmas nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_add subtype "sets[infinite_sets_def.T].add(infinite_sets_def.t, infinite_sets_def.Inf)" "infinite_set"))) (infinite_remove 0 (infinite_remove-1 nil 3249344193 ("" (skolem-typepred) (("" (use "member_remove[T]") (("" (assert) (("" (lemma "finite_add[T]") (("" (inst - "remove(t!1, Inf!1)" "t!1") (("" (forward-chain "add_remove_member[T]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member_remove formula-decl nil sets_lemmas nil) (finite_add formula-decl nil finite_sets nil) (add_remove_member formula-decl nil sets_lemmas nil) (remove const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_remove subtype "sets[infinite_sets_def.T].remove(infinite_sets_def.t, infinite_sets_def.Inf)" "infinite_set"))) (infinite_superset 0 (infinite_superset-1 nil 3249344193 ("" (skosimp :preds? t) (("" (forward-chain "finite_subset[T]") nil nil)) nil) ((finite_subset formula-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil infinite_sets_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (infinite_set type-eq-decl nil infinite_sets_def nil)) nil)) (infinite_union_left 0 (infinite_union_left-3 "" 3658948361 ("" (skolem-typepred) (("" (expand* "union" "member" "is_finite") (("" (skolem-typepred) (("" (inst + "N!1" "restrict[({x: T | Inf!1(x) OR S!1(x)}), (Inf!1), below[N!1]](f!1)") (("" (expand* "injective?" "restrict") (("" (skosimp* :preds? t) (("" (inst? -) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (union const-decl "set" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) shostak (infinite_union_left subtype "sets[infinite_sets_def.T].union(infinite_sets_def.Inf, infinite_sets_def.S)" "infinite_set")) (infinite_union_left-2 "" 3590860111 ("" (skolem-typepred) (("" (expand* "union" "member" "is_finite") (("" (skolem-typepred) (("" (inst + "N!1" "restrict[({x: T | Inf!1(x) OR S!1(x)}), (Inf!1), below[N!1]](f!1)") (("" (expand* "injective?" "restrict") (("" (skosimp* :preds? t) (("" (inst? -6) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (union const-decl "set" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) shostak (infinite_union_left subtype "sets[infinite_sets_def.T].union(infinite_sets_def.Inf, infinite_sets_def.S)" "infinite_set")) (infinite_union_left-1 nil 3249344193 ("" (skolem-typepred) (("" (expand* "union" "member" "is_finite") (("" (skolem-typepred) (("" (inst + "N!1" "restrict[({x: T | Inf!1(x) OR S!1(x)}), (Inf!1), below[N!1]](f!1)") (("" (expand* "injective?" "restrict") (("" (skosimp* :preds? t) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (union const-decl "set" sets nil) (restrict const-decl "R" restrict nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_union_left subtype "sets[infinite_sets_def.T].union(infinite_sets_def.Inf, infinite_sets_def.S)" "infinite_set"))) (infinite_union_right 0 (infinite_union_right-1 nil 3249344193 ("" (skolem-typepred) (("" (use "union_commutative[T]") (("" (use "infinite_union_left") (("" (assert) nil nil)) nil)) nil)) nil) ((union_commutative formula-decl nil sets_lemmas nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (infinite_union_left application-judgement "infinite_set" infinite_sets_def nil) (infinite_union_left judgement-tcc nil infinite_sets_def nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_union_right subtype "sets[infinite_sets_def.T].union(infinite_sets_def.S, infinite_sets_def.Inf)" "infinite_set"))) (infinite_union 0 (infinite_union-1 nil 3249344193 ("" (skosimp) (("" (use "finite_union[T]") nil nil)) nil) ((S!1 skolem-const-decl "set[T]" infinite_sets_def nil) (R!1 skolem-const-decl "set[T]" infinite_sets_def nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_union judgement-tcc nil finite_sets nil) (T formal-type-decl nil infinite_sets_def nil)) nil)) (infinite_intersection 0 (infinite_intersection-1 nil 3249344193 ("" (skosimp) (("" (use "finite_intersection1[T]") (("" (use "finite_intersection2[T]") (("" (assert) nil nil)) nil)) nil)) nil) ((finite_intersection1 judgement-tcc nil finite_sets nil) (T formal-type-decl nil infinite_sets_def nil) (R!1 skolem-const-decl "set[T]" infinite_sets_def nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (S!1 skolem-const-decl "set[T]" infinite_sets_def nil) (finite_intersection2 judgement-tcc nil finite_sets nil)) nil)) (infinite_difference 0 (infinite_difference-1 nil 3249344193 ("" (skolem-typepred) (("" (expand* "difference" "member" "is_finite" "injective?") (("" (skosimp*) (("" (inst + "N!1 + N!2" "LAMBDA (s: (Inf!1)): IF Fin!1(s) THEN f!1(s) + N!2 ELSE f!2(s) ENDIF") (("1" (skosimp) (("1" (smash) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst? -3) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) nil nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (difference const-decl "set" sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (N!2 skolem-const-decl "nat" infinite_sets_def nil) (f!1 skolem-const-decl "[(Fin!1) -> below[N!1]]" infinite_sets_def nil) (below type-eq-decl nil nat_types nil) (N!1 skolem-const-decl "nat" infinite_sets_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Fin!1 skolem-const-decl "finite_set[T]" infinite_sets_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Inf!1 skolem-const-decl "infinite_set" infinite_sets_def nil) (f!2 skolem-const-decl "[({x | Inf!1(x) AND NOT Fin!1(x)}) -> below[N!2]]" infinite_sets_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (infinite_difference subtype "sets[infinite_sets_def.T].difference(infinite_sets_def.Inf, infinite_sets_def.Fin)" "infinite_set"))) (infinite_rest 0 (infinite_rest-1 nil 3249344193 ("" (skolem-typepred) (("" (expand "rest") (("" (prop) (("" (use "add_remove_member[T]") (("" (expand "member") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (add_remove_member formula-decl nil sets_lemmas nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (infinite_remove application-judgement "infinite_set" infinite_sets_def nil) (infinite_add application-judgement "infinite_set" infinite_sets_def nil) (member const-decl "bool" sets nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil infinite_sets_def nil)) nil (infinite_rest subtype "sets[infinite_sets_def.T].rest(infinite_sets_def.Inf)" "infinite_set"))) (infinite_fullset 0 (infinite_fullset-1 nil 3249344193 ("" (flatten) (("" (skolem!) (("" (lemma "finite_subset[T]" ("A" "fullset[T]" "s" "S!1")) (("1" (expand* "subset?" "fullset" "member") nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (finite_subset formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (fullset const-decl "set" sets nil) (T formal-type-decl nil infinite_sets_def nil)) nil)))(finite_sets_of_sets (powerset_natfun_rec_TCC1 0 (powerset_natfun_rec_TCC1-1 nil 3242842726 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (inverse const-decl "D" function_inverse nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (powerset_natfun_rec subtype "(number_fields.-)(finite_sets_of_sets.n, 1)" "naturalnumbers.upto(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))"))) (powerset_natfun_rec_TCC2 0 (powerset_natfun_rec_TCC2-2 "" 3332190247 ("" (skolem-typepred) (("" (flatten) (("" (assert) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_rec termination "finite_sets_of_sets.powerset_natfun_rec(finite_sets_of_sets.A, (number_fields.-)(finite_sets_of_sets.n, 1), finite_sets_of_sets.f, finite_sets_of_sets.B)" "nil")) (powerset_natfun_rec_TCC2-1 nil 3242842733 ("" (skolem-typepred) (("" (hide -1 -2 -3) (("" (flatten) (("" (lemma "empty_card[T]") (("" (inst -1 "A!1") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_rec termination "finite_sets_of_sets.powerset_natfun_rec(finite_sets_of_sets.A, (number_fields.-)(finite_sets_of_sets.n, 1), finite_sets_of_sets.f, finite_sets_of_sets.B)" "nil"))) (powerset_natfun_rec_TCC3 0 (powerset_natfun_rec_TCC3-1 nil 3242843028 ("" (grind) (("" (lemma "empty_card[T]") (("" (inst -1 "A!1") (("" (grind) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (A!1 skolem-const-decl "finite_set[T]" finite_sets_of_sets nil) (TRUE const-decl "bool" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (nil application-judgement "above(n)" exp2 nil) (inverse const-decl "D" function_inverse nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (powerset_natfun_rec subtype "(number_fields.+)(finite_sets_of_sets.nval, finite_sets_of_sets.powerset_natfun_rec(finite_sets_of_sets.A, (number_fields.-)(finite_sets_of_sets.n, 1), finite_sets_of_sets.f, finite_sets_of_sets.B))" "nat"))) (powerset_natfun_rec_TCC4 0 (powerset_natfun_rec_TCC4-1 nil 3242843036 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (powerset_natfun_rec subtype "(number_fields.-)(finite_sets_of_sets.n, 1)" "nat"))) (powerset_natfun_rec_TCC5 0 (powerset_natfun_rec_TCC5-1 nil 3242962925 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (powerset_natfun_rec subtype "(number_fields.-)(finite_sets_of_sets.n, 1)" "naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))"))) (powerset_natfun_rec_TCC6 0 (powerset_natfun_rec_TCC6-1 nil 3369463704 ("" (skolem-typepred) (("" (flatten) (("" (use "empty_card[T]") (("" (expand "empty?") (("" (expand "member") (("" (assert) (("" (skolem-typepred) (("" (inst 2 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (A!1 skolem-const-decl "finite_set[T]" finite_sets_of_sets nil) (x!1 skolem-const-decl "T" finite_sets_of_sets nil) (member const-decl "bool" sets nil) (empty_card formula-decl nil finite_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_rec existence "" "(finite_sets_of_sets.A)"))) (powerset_natfun_rec_bound 0 (powerset_natfun_rec_bound-1 nil 3242966710 ("" (skolem 1 ("A!1" _ "f!1" "B!1")) (("" (induct-and-simplify "n") nil nil)) nil) ((member const-decl "bool" sets nil) (inverse const-decl "D" function_inverse nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (bijective_inverse_is_bijective application-judgement "(bijective?[R, D])" function_inverse nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (T formal-type-decl nil finite_sets_of_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (powerset_natfun_rec def-decl "nat" finite_sets_of_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil)) shostak)) (powerset_natfun_TCC1 0 (powerset_natfun_TCC1-2 "" 3342856117 ("" (skolem-typepred) (("" (lemma "Card_bijection[T]") (("" (inst -1 "A!1" "card(A!1)") (("" (rewrite "card_def") (("" (assert) (("" (skosimp) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Card_bijection formula-decl nil finite_sets nil) (card_def formula-decl nil finite_sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun subtype "functions[(finite_sets_of_sets.A), naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))].bijective?" "(sets[[(finite_sets_of_sets.A) -> naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))]].nonempty?)")) (powerset_natfun_TCC1-1 nil 3242843042 ("" (skosimp) (("" (use "Card_bijection[T]") (("" (inst -1 "A!1" "card(A!1)") (("" (rewrite "card_def") (("" (assert) (("" (skosimp) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Card_bijection formula-decl nil finite_sets nil) (card_def formula-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun subtype "functions[(finite_sets_of_sets.A), naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))].bijective?" "(sets[[(finite_sets_of_sets.A) -> naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))]].nonempty?)"))) (powerset_natfun_TCC2 0 (powerset_natfun_TCC2-1 nil 3242843103 ("" (grind) nil nil) nil shostak (powerset_natfun subtype "finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A)" "naturalnumbers.upto(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))"))) (powerset_natfun_TCC3 0 (powerset_natfun_TCC3-2 "" 3369465081 ("" (skosimp) (("" (beta) (("" (lemma "powerset_natfun_rec_bound") (("" (inst?) nil nil)) nil)) nil)) nil) ((powerset_natfun_rec_bound formula-decl nil finite_sets_of_sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil)) shostak (powerset_natfun subtype "finite_sets_of_sets.powerset_natfun_rec(finite_sets_of_sets.A, finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A), finite_sets_of_sets.f, finite_sets_of_sets.B)" "naturalnumbers.below(exp2.exp2(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A)))")) (powerset_natfun_TCC3-1 nil 3369463706 ("" (subtype-tcc) (("" (postpone) nil nil)) nil) ((powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (powerset_natfun_rec_bound formula-decl nil finite_sets_of_sets nil)) shostak (powerset_natfun subtype "finite_sets_of_sets.powerset_natfun_rec(finite_sets_of_sets.A, finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A), finite_sets_of_sets.f, finite_sets_of_sets.B)" "naturalnumbers.below(exp2.exp2(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A)))"))) (powerset_natfun_inj_rec_TCC1 0 (powerset_natfun_inj_rec_TCC1-1 nil 3242962926 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (powerset_natfun_inj_rec subtype "finite_sets_of_sets.m" "naturalnumbers.below(finite_sets[finite_sets_of_sets.T].card(finite_sets_of_sets.A))"))) (powerset_natfun_inj_rec_TCC2 0 (powerset_natfun_inj_rec_TCC2-3 "" 3590860305 ("" (skolem-typepred) (("" (flatten) (("" (lemma "nonempty_card[T]") (("" (inst?) (("" (assert) (("" (expand "nonempty?") (("" (expand "empty?") (("" (skolem-typepred) (("" (expand "member") (("" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (x!1 skolem-const-decl "T" finite_sets_of_sets nil) (A!1 skolem-const-decl "finite_set[T]" finite_sets_of_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_card formula-decl nil finite_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_inj_rec existence "" "(finite_sets_of_sets.A)")) (powerset_natfun_inj_rec_TCC2-2 "" 3332564344 ("" (skolem-typepred) (("" (flatten) (("" (lemma "nonempty_card[T]") (("" (inst?) (("" (assert) (("" (expand "nonempty?") (("" (expand "empty?") (("" (skolem-typepred) (("" (expand "member") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_card formula-decl nil finite_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_inj_rec existence "" "(finite_sets_of_sets.A)")) (powerset_natfun_inj_rec_TCC2-1 nil 3242962926 ("" (grind) nil nil) ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty_card formula-decl nil finite_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (powerset_natfun_inj_rec existence "" "(finite_sets_of_sets.A)"))) (powerset_natfun_inj_rec 0 (powerset_natfun_inj_rec-1 nil 3242959167 ("" (skolem 1 ("A!1" _ "f!1" "B1!1" "B2!1")) (("" (induct "n") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "powerset_natfun_rec" +) (("3" (split 1) (("1" (flatten) (("1" (skosimp) (("1" (case-replace "m!1 = jt!1") (("1" (assert) (("1" (expand "member") (("1" (lemma "powerset_natfun_rec_bound") (("1" (inst-cp -1 "A!1" "jt!1" "f!1" "B1!1") (("1" (inst -1 "A!1" "jt!1" "f!1" "B2!1") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -4) (("1" (inst -1 "m!1") (("1" (assert) nil nil)) nil) ("2" (replace 1) (("2" (assert) (("2" (expand "member") (("2" (lemma "powerset_natfun_rec_bound") (("2" (inst-cp -1 "A!1" "jt!1" "f!1" "B1!1") (("2" (inst -1 "A!1" "jt!1" "f!1" "B2!1") (("2" (assert) (("2" (hide 4) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (ground) nil nil)) nil) ("4" (lift-if) (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (split -4) (("1" (inst -2 "jt!1") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (skosimp) (("2" (inst -2 "m!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 1) (("4" (grind) (("4" (lemma "empty_card[T]") (("4" (inst -1 "A!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (hide -1 1) (("5" (grind) (("5" (lemma "empty_card[T]") (("5" (inst -1 "A!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (hide -1 1) (("6" (grind) nil nil)) nil) ("7" (hide -1 1) (("7" (grind) nil nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (A!1 skolem-const-decl "finite_set[T]" finite_sets_of_sets nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (bijective? const-decl "bool" functions nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (powerset_natfun_rec def-decl "nat" finite_sets_of_sets nil) (member const-decl "bool" sets nil) (inverse const-decl "D" function_inverse nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (powerset_natfun_rec_bound formula-decl nil finite_sets_of_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (bijective_inverse_is_bijective application-judgement "(bijective?[R, D])" function_inverse nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (powerset_natfun_inj 0 (powerset_natfun_inj-4 "" 3658948800 ("" (lemma "powerset_natfun_inj_rec") (("" (skosimp) (("" (skosimp) (("" (expand "powerset_natfun") (("" (inst? -1) (("" (assert) (("" (apply-extensionality) (("" (expand "member") (("" (hide -2) (("" (hide 2) (("" (name-replace "f" "choose(bijective?[(A!1), below(card(A!1))])") (("1" (case "A!1(x!1)") (("1" (inst -2 "f(x!1)") (("1" (assert) (("1" (typepred "f") (("1" (expand "inverse") (("1" (case-replace "(epsilon! (x: (A!1)): f(x) = f(x!1)) = x!1") (("1" (iff) (("1" (propax) nil nil)) nil) ("2" (hide -3 2) (("2" (use "epsilon_ax[(A!1)]") (("1" (prop) (("1" (expand "bijective?") (("1" (flatten) (("1" (expand "injective?") (("1" (inst?) (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("3" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "f(x!1)") (("2" (assert) nil nil)) nil)) nil) ("2" (expand "inverse") (("2" (typepred "B1!1") (("2" (typepred "B2!1") (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "Card_bijection[T]") (("2" (inst -1 "A!1" "card(A!1)") (("2" (rewrite "card_def") (("2" (assert) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powerset_natfun const-decl "below(exp2(card(A)))" finite_sets_of_sets nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (member const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (empty? const-decl "bool" sets nil) (card_def formula-decl nil finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (f skolem-const-decl "(bijective?[(A!1), below(card(A!1))])" finite_sets_of_sets nil) (x!1 skolem-const-decl "T" finite_sets_of_sets nil) (A!1 skolem-const-decl "finite_set[T]" finite_sets_of_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (powerset_natfun_inj_rec formula-decl nil finite_sets_of_sets nil)) shostak) (powerset_natfun_inj-3 "" 3590860968 ("" (lemma "powerset_natfun_inj_rec") (("" (skosimp) (("" (skosimp) (("" (expand "powerset_natfun") (("" (inst? -1) (("" (assert) (("" (apply-extensionality) (("" (expand "member") (("" (hide -2) (("" (hide 2) (("" (name-replace "f" "choose(bijective?[(A!1), below(card(A!1))])") (("1" (case "A!1(x!1)") (("1" (inst -2 "f(x!1)") (("1" (assert) (("1" (typepred "f") (("1" (expand "inverse") (("1" (case-replace "(epsilon! (x: (A!1)): f(x) = f(x!1)) = x!1") (("1" (iff) (("1" (propax) nil nil)) nil) ("2" (hide -4 2) (("2" (use "epsilon_ax[(A!1)]") (("1" (prop) (("1" (expand "bijective?") (("1" (flatten) (("1" (expand "injective?") (("1" (inst?) (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("3" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "f(x!1)") (("2" (assert) nil nil)) nil)) nil) ("2" (expand "inverse") (("2" (typepred "B1!1") (("2" (typepred "B2!1") (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "Card_bijection[T]") (("2" (inst -1 "A!1" "card(A!1)") (("2" (rewrite "card_def") (("2" (assert) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powerset_natfun const-decl "below(exp2(card(A)))" finite_sets_of_sets nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (member const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (empty? const-decl "bool" sets nil) (card_def formula-decl nil finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (powerset_natfun_inj_rec formula-decl nil finite_sets_of_sets nil)) shostak) (powerset_natfun_inj-2 "" 3342858990 ("" (lemma "powerset_natfun_inj_rec") (("" (skosimp) (("" (skosimp) (("" (expand "powerset_natfun") (("" (inst? -1) (("" (assert) (("" (apply-extensionality) (("" (expand "member") (("" (hide -2) (("" (hide 2) (("" (name-replace "f" "choose(bijective?[(A!1), below(card(A!1))])") (("1" (case "A!1(x!1)") (("1" (inst -2 "f(x!1)") (("1" (assert) (("1" (typepred "f") (("1" (expand "inverse") (("1" (case-replace "(epsilon! (x: (A!1)): f(x) = f(x!1)) = x!1") (("1" (iff) (("1" (propax) nil nil)) nil) ("2" (hide -3 2) (("2" (use "epsilon_ax[(A!1)]") (("1" (prop) (("1" (expand "bijective?") (("1" (flatten) (("1" (expand "injective?") (("1" (inst?) (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil) ("3" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "f(x!1)") (("2" (assert) nil nil)) nil)) nil) ("2" (expand "inverse") (("2" (typepred "B1!1") (("2" (typepred "B2!1") (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "Card_bijection[T]") (("2" (inst -1 "A!1" "card(A!1)") (("2" (rewrite "card_def") (("2" (assert) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powerset_natfun const-decl "below(exp2(card(A)))" finite_sets_of_sets nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (member const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (empty? const-decl "bool" sets nil) (card_def formula-decl nil finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (powerset_natfun_inj_rec formula-decl nil finite_sets_of_sets nil)) shostak) (powerset_natfun_inj-1 nil 3242962518 ("" (lemma "powerset_natfun_inj_rec") (("" (skosimp) (("" (skosimp) (("" (expand "powerset_natfun") (("" (inst? -1) (("1" (assert) (("1" (apply-extensionality) (("1" (expand "member") (("1" (hide -2) (("1" (hide 2) (("1" (name-replace "f" "choose(bijective?[(A!1), below(card(A!1))])") (("1" (inst -1 "f(x!1)") (("1" (assert) (("1" (typepred "f") (("1" (expand "inverse") (("1" (case "A!1(x!1)") (("1" (case-replace "(epsilon! (x: (A!1)): f(x) = f(x!1)) = x!1") (("1" (iff) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide -3 2) (("2" (use "epsilon_ax[(A!1)]") (("1" (split) (("1" (expand "bijective?") (("1" (flatten) (("1" (expand "injective?") (("1" (inst?) (("1" (assert) nil nil) ("2" (inst 1 "x!1") nil nil) ("3" (skosimp) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil) ("2" (skosimp) nil nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") nil nil) ("4" (skosimp) nil nil)) nil) ("2" (hide -1 -2) (("2" (typepred "B1!1") (("2" (typepred "B2!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "f") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "B1!1") (("3" (typepred "B2!1") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "Card_bijection[T]") (("2" (inst -1 "A!1" "card(A!1)") (("2" (rewrite "card_def") (("2" (assert) (("2" (skosimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "Card_bijection[T]") (("2" (inst -1 "A!1" "card(A!1)") (("2" (rewrite "card_def") (("2" (assert) (("2" (skosimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powerset_natfun const-decl "below(exp2(card(A)))" finite_sets_of_sets nil) (unique_bijective_inverse application-judgement "{x: D | f(x) = y}" function_inverse nil) (member const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (empty? const-decl "bool" sets nil) (card_def formula-decl nil finite_sets nil) (Card_bijection formula-decl nil finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (inverse const-decl "D" function_inverse nil) (injective? const-decl "bool" functions nil) (epsilon_ax formula-decl nil epsilons nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (powerset_natfun_inj_rec formula-decl nil finite_sets_of_sets nil)) shostak)) (powerset_finite 0 (powerset_finite-1 nil 3242843110 ("" (use "powerset_natfun_inj") (("" (skosimp) (("" (expand "is_finite") (("" (inst 1 "exp2(card(A!1))" "powerset_natfun(A!1)") (("" (expand "injective?") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (T formal-type-decl nil finite_sets_of_sets nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (powerset_natfun const-decl "below(exp2(card(A)))" finite_sets_of_sets nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (powerset_natfun_inj formula-decl nil finite_sets_of_sets nil)) shostak (powerset_finite subtype "sets[finite_sets_of_sets.T].powerset(finite_sets_of_sets.A)" "finite_set[set[T]]"))) (Union_finite 0 (Union_finite-2 "" 3728843445 ("" (skolem!) (("" (expand "every") (("" (prop) (("1" (lemma "finite_subset[set[T]]") (("1" (inst - "powerset(Union(SS!1))" "SS!1") (("1" (grind) nil nil) ("2" (use "powerset_finite") nil nil)) nil)) nil) ("2" (skolem!) (("2" (lemma "finite_subset[T]") (("2" (inst - "Union(SS!1)" "x!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (case "FORALL (n: nat), (B: setofsets[T]): (EXISTS (f: [(B) -> below[n]]): injective?(f)) AND (FORALL (b: (B)): is_finite(b)) => is_finite(Union(B))") (("1" (expand "is_finite" -2) (("1" (skolem!) (("1" (inst - "N!1" "SS!1") (("1" (prop) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (delete -1 -2 2) (("2" (induct "n") (("1" (skosimp*) (("1" (expand "is_finite" +) (("1" (inst + "1" "LAMBDA (b: (Union(B!1))): 0") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (expand "Union") (("1" (skosimp*) (("1" (typepred "f!1(a!1)") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "EXISTS (b: (B!1)): f!1(b) = j!1") (("1" (skolem!) (("1" (inst - "remove(b!1, B!1)") (("1" (prop) (("1" (inst - "b!1") (("1" (expand "is_finite") (("1" (skosimp*) (("1" (inst + "N!1 + N!2" "LAMBDA (c: (Union(B!1))): IF b!1(c) THEN N!1 + f!3(c) ELSE f!2(c) ENDIF") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand "Union") (("1" (skosimp*) (("1" (smash) (("1" (inst -6 "x1!1" "x2!1") (("1" (assert) nil nil)) nil) ("2" (inst - "x1!1" "x2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp :preds? t) (("2" (expand* "remove" "member" "Union") (("2" (skolem!) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp :preds? t) (("3" (expand* "remove" "member" "Union") (("3" (skolem!) (("3" (inst + "a!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "LAMBDA (c: (remove(b!1, B!1))): f!1(c)") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand* "remove" "member") (("1" (flatten) (("1" (inst - "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand* "remove" "member" "injective?") (("2" (flatten) (("2" (inst - "b!1" "c!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skolem-typepred) (("3" (expand* "remove" "member") (("3" (flatten) nil nil)) nil)) nil)) nil) ("3" (skolem-typepred) (("3" (expand* "remove" "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "B!1") (("2" (prop) (("2" (inst + "f!1") (("2" (skolem!) (("2" (inst + "x1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" sets nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "set" sets nil) (b!2 skolem-const-decl "(remove(b!1, B!1))" finite_sets_of_sets nil) (j!1 skolem-const-decl "nat" finite_sets_of_sets nil) (f!1 skolem-const-decl "[(B!1) -> below[1 + j!1]]" finite_sets_of_sets nil) (a!1 skolem-const-decl "(B!1)" finite_sets_of_sets nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (f!2 skolem-const-decl "[(Union(remove(b!1, B!1))) -> below[N!1]]" finite_sets_of_sets nil) (N!1 skolem-const-decl "nat" finite_sets_of_sets nil) (f!3 skolem-const-decl "[(b!1) -> below[N!2]]" finite_sets_of_sets nil) (N!2 skolem-const-decl "nat" finite_sets_of_sets nil) (b!1 skolem-const-decl "(B!1)" finite_sets_of_sets nil) (B!1 skolem-const-decl "setofsets[T]" finite_sets_of_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (finite_subset formula-decl nil finite_sets nil) (powerset_finite judgement-tcc nil finite_sets_of_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (Union const-decl "set" sets nil) (SS!1 skolem-const-decl "setofsets[T]" finite_sets_of_sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)) shostak) (Union_finite-1 nil 3252521570 ("" (skolem!) (("" (expand "every") (("" (prop) (("1" (lemma "finite_subset[set[T]]") (("1" (inst - "powerset(Union(SS!1))" "SS!1") (("1" (grind) nil nil) ("2" (use "powerset_finite") nil nil)) nil)) nil) ("2" (skolem!) (("2" (lemma "finite_subset[T]") (("2" (inst - "Union(SS!1)" "x!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (case "FORALL (n: nat), (B: setofsets[T]): (EXISTS (f: [(B) -> below[n]]): injective?(f)) AND (FORALL (b: (B)): is_finite(b)) => is_finite(Union(B))") (("1" (expand "is_finite" -2) (("1" (skolem!) (("1" (inst - "N!1" "SS!1") (("1" (prop) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (delete -1 -2 2) (("2" (induct "n") (("1" (skosimp*) (("1" (expand "is_finite" +) (("1" (inst + "1" "LAMBDA (b: (Union(B!1))): 0") (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (expand "Union") (("1" (skosimp*) (("1" (typepred "f!1(a!1)") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "EXISTS (b: (B!1)): f!1(b) = j!1") (("1" (skolem!) (("1" (inst - "remove(b!1, B!1)") (("1" (prop) (("1" (inst - "b!1") (("1" (expand "is_finite") (("1" (skosimp*) (("1" (inst + "N!1 + N!2" "LAMBDA (c: (Union(B!1))): IF b!1(c) THEN N!1 + f!3(c) ELSE f!2(c) ENDIF") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand "Union") (("1" (skosimp*) (("1" (smash) (("1" (inst -6 "x1!1" "x2!1") (("1" (assert) nil nil)) nil) ("2" (inst - "x1!1" "x2!1") (("1" (assert) nil nil) ("2" (expand* "remove" "member" "Union") (("2" (inst + "a!2") nil nil)) nil) ("3" (expand* "remove" "member" "Union") (("3" (inst + "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp :preds? t) (("3" (expand* "remove" "member" "Union") (("3" (skolem!) (("3" (inst + "a!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "LAMBDA (c: (remove(b!1, B!1))): f!1(c)") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand* "remove" "member") (("1" (flatten) (("1" (inst - "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand* "remove" "member" "injective?") (("2" (flatten) (("2" (inst - "b!1" "c!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skolem-typepred) (("3" (expand* "remove" "member") (("3" (flatten) nil nil)) nil)) nil)) nil) ("3" (skolem-typepred) (("3" (expand* "remove" "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "B!1") (("2" (prop) (("2" (inst + "f!1") (("1" (expand "injective?") (("1" (propax) nil nil)) nil) ("2" (skolem!) (("2" (inst + "x1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (finite_subset formula-decl nil finite_sets nil) (powerset_finite judgement-tcc nil finite_sets_of_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (Union const-decl "set" sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)) shostak)) (finite_Union_finite 0 (finite_Union_finite-1 nil 3397716311 ("" (skosimp*) (("" (use "Union_finite") (("" (assert) nil nil)) nil)) nil) ((Union_finite formula-decl nil finite_sets_of_sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)) shostak)) (Union_infinite 0 (Union_infinite-1 nil 3252521819 ("" (skolem!) (("" (use "Union_finite") (("" (expand* "every" "some") (("" (smash) (("1" (skolem!) (("1" (inst - "x!1") nil nil)) nil) ("2" (skolem!) (("2" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil) ((Union_finite formula-decl nil finite_sets_of_sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil) (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (every const-decl "bool" sets nil) (some const-decl "bool" sets nil)) shostak)) (Intersection_finite 0 (Intersection_finite-1 nil 3252521839 ("" (expand* "every" "is_finite" "nonempty?" "empty?" "member") (("" (skosimp*) (("" (inst - "x!1") (("" (skolem!) (("" (inst + "N!1" "LAMBDA (a: (Intersection(SS!1))): f!1(a)") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand "Intersection") (("1" (inst - "x!1") (("1" (inst - "x!1") (("1" (inst - "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "Intersection") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Intersection const-decl "set" sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (SS!1 skolem-const-decl "setofsets[T]" finite_sets_of_sets nil) (x!1 skolem-const-decl "setof[T]" finite_sets_of_sets nil) (every const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil)) shostak)) (Intersection_infinite 0 (Intersection_infinite-1 nil 3252521879 ("" (expand* "every" "is_finite") (("" (skosimp*) (("" (inst + "N!1" "LAMBDA (a: (Intersection(SS!1))): f!1(a)") (("1" (expand "injective?") (("1" (skosimp :preds? t) (("1" (expand "Intersection") (("1" (inst - "x!1") (("1" (inst - "x!1") (("1" (inst - "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (expand "Intersection") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (SS!1 skolem-const-decl "setofsets[T]" finite_sets_of_sets nil) (x!1 skolem-const-decl "(SS!1)" finite_sets_of_sets nil) (every const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil)) shostak)) (Complement_finite 0 (Complement_finite-1 nil 3252521922 ("" (skolem!) (("" (expand* "Complement" "is_finite" "injective?") (("" (prop) (("1" (skolem!) (("1" (inst + "N!1" "LAMBDA (a: (SS!1)): f!1(complement(a))") (("1" (skosimp) (("1" (inst - "complement(x1!1)" "complement(x2!1)") (("1" (assert) (("1" (rewrite "complement_equal") nil nil)) nil) ("2" (inst + "x2!1") nil nil) ("3" (inst + "x1!1") nil nil)) nil)) nil) ("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst + "N!1" "LAMBDA (c: ({a: set[T] | EXISTS (b: (SS!1)): a = complement(b)})): f!1(complement(c))") (("1" (skosimp :preds? t) (("1" (skosimp*) (("1" (inst - "complement(x1!1)" "complement(x2!1)") (("1" (assert) (("1" (rewrite "complement_equal") nil nil)) nil) ("2" (lemma "complement_complement[T]") (("2" (inst - "b!2") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "complement_complement[T]") (("3" (inst - "b!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp* :preds? t) (("2" (use "complement_complement[T]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (Complement const-decl "setofsets[T]" sets_lemmas nil) (complement_complement formula-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (complement_equal formula-decl nil sets_lemmas nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (SS!1 skolem-const-decl "setofsets[T]" finite_sets_of_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (complement const-decl "set" sets nil)) shostak)) (Complement_is_finite 0 (Complement_is_finite-1 nil 3252221181 ("" (skolem!) (("" (rewrite "Complement_finite") nil nil)) nil) ((Complement_finite formula-decl nil finite_sets_of_sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) shostak (Complement_is_finite subtype "sets_lemmas[finite_sets_of_sets.T].Complement(finite_sets_of_sets.SS)" "finite_set[set[T]]"))) (Complement_infinite 0 (Complement_infinite-1 nil 3252522256 ("" (skolem!) (("" (use "Complement_finite") (("" (prop) nil nil)) nil)) nil) ((Complement_finite formula-decl nil finite_sets_of_sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_of_sets nil)) shostak)) (Complement_is_infinite 0 (Complement_is_infinite-1 nil 3252221181 ("" (skolem!) (("" (rewrite "Complement_infinite") nil nil)) nil) ((Complement_infinite formula-decl nil finite_sets_of_sets nil) (T formal-type-decl nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (infinite_set type-eq-decl nil infinite_sets_def nil)) shostak (Complement_is_infinite subtype "sets_lemmas[finite_sets_of_sets.T].Complement(finite_sets_of_sets.SS)" "infinite_set[set[T]]"))))(EquivalenceClosure (EquivClos_TCC1 0 (EquivClos_TCC1-1 nil 3243015830 ("" (skosimp*) (("" (expand "equivalence?") (("" (expand "EquivClos") (("" (prop) (("1" (expand "reflexive?") (("1" (skosimp*) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst?) nil))))))))))))) ("2" (expand "symmetric?") (("2" (skosimp*) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (inst?) (("2" (prop) (("2" (expand "symmetric?") (("2" (inst -3 "x!1" "y!1") (("2" (assert) nil))))))))))))))))))) ("3" (expand "transitive?") (("3" (skosimp*) (("3" (typepred "S!1") (("3" (expand "equivalence?") (("3" (flatten) (("3" (inst?) (("3" (inst?) (("3" (prop) (("3" (expand "transitive?") (("3" (inst -5 "x!1" "y!1" "z!1") (("3" (assert) nil)))))))))))))))))))))))))))) nil) ((equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil EquivalenceClosure nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (EquivClos subtype "{(x, y) | FORALL (S: relations[EquivalenceClosure.T].equivalence): booleans.IMPLIES(sets[[EquivalenceClosure.T, EquivalenceClosure.T]].subset?(EquivalenceClosure.R, S), S(EquivalenceClosure.x, EquivalenceClosure.y))}" "equivalence[T]"))) (EquivClosSuperset 0 (EquivClosSuperset-1 nil 3243015830 ("" (skosimp*) (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivClos") (("" (skosimp*) (("" (expand "subset?") (("" (inst?) (("" (expand "member") (("" (assert) nil)))))))))))))))))) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (T formal-type-decl nil EquivalenceClosure nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil)) nil)) (EquivClosMonotone 0 (EquivClosMonotone-1 nil 3243015830 ("" (skosimp*) (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivClos") (("" (skosimp*) (("" (typepred "S!2") (("" (inst -3 "S!2") (("" (assert) (("" (expand "subset?") (("" (expand "member") (("" (skosimp*) (("" (inst?) (("" (inst?) (("" (assert) nil)))))))))))))))))))))))))))) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil EquivalenceClosure nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil)) nil)) (EquivClosLeast 0 (EquivClosLeast-1 nil 3243015830 ("" (skosimp*) (("" (expand "subset?" 1) (("" (skosimp*) (("" (expand "member") (("" (expand "EquivClos") (("" (inst?) (("" (assert) nil)))))))))))) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (S!1 skolem-const-decl "PRED[[T, T]]" EquivalenceClosure nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil EquivalenceClosure nil) (equivalence type-eq-decl nil relations nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil)) nil)) (EquivClosIdempotent 0 (EquivClosIdempotent-1 nil 3243015830 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (iff) (("" (prop) (("1" (lemma "EquivClosLeast") (("1" (inst -1 "EquivClos(R!1)" "EquivClos(R!1)") (("1" (assert) (("1" (expand "subset?") (("1" (expand "member") (("1" (prop) (("1" (inst?) (("1" (assert) nil))) ("2" (skosimp*) nil))))))))))))) ("2" (lemma "EquivClosSuperset") (("2" (inst -1 "EquivClos(R!1)") (("2" (expand "subset?") (("2" (inst -1 "(x!1, x!2)") (("2" (assert) (("2" (expand "member") (("2" (propax) nil)))))))))))))))))))) nil) ((T formal-type-decl nil EquivalenceClosure nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (EquivClosLeast formula-decl nil EquivalenceClosure nil) (EquivClosSuperset formula-decl nil EquivalenceClosure nil)) nil)) (EquivalenceCharacterization 0 (EquivalenceCharacterization-1 nil 3243015830 ("" (skosimp*) (("" (prop) (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (lemma "EquivClosSuperset") (("1" (inst?) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil))))))))))) ("2" (lemma "EquivClosLeast") (("2" (inst -1 "S!1" "S!1") (("2" (assert) (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil))))))) ("2" (expand "subset?") (("2" (expand "member") (("2" (skosimp*) nil))))))))))))))))))) ("2" (assert) nil)))) nil) ((EquivClosLeast formula-decl nil EquivalenceClosure nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (EquivClosSuperset formula-decl nil EquivalenceClosure nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil EquivalenceClosure nil)) nil)))(QuotientDefinition (EquivClassNonEmpty 0 (EquivClassNonEmpty-1 nil 3243015830 ("" (skosimp*) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (expand "EquivClass") (("" (inst -1 "x!1") (("" (typepred "S!1") (("" (expand "equivalence?") (("" (expand "reflexive?") (("" (flatten) (("" (inst -1 "x!1") nil)))))))))))))))))))) nil) ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (T formal-type-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (empty? const-decl "bool" sets nil)) nil)) (EquivClassEq 0 (EquivClassEq-1 nil 3243015830 ("" (skosimp*) (("" (typepred "S!1") (("" (expand "EquivClass") (("" (prop) (("1" (case "S!1(x!1, y!1) = (LAMBDA (z: T): S!1(x!1, z))(y!1)") (("1" (replace -2) (("1" (assert) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst -3 "y!1") (("1" (assert) nil))))))))))))) ("2" (assert) nil))) ("2" (apply-extensionality :hide? t) (("2" (iff) (("2" (prop) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst -4 "x!1" "y!1") (("1" (assert) (("1" (inst -5 "y!1" "x!1" "x!2") (("1" (assert) nil))))))))))))))) ("2" (expand "equivalence?") (("2" (flatten) (("2" (expand "transitive?") (("2" (inst -5 "x!1" "y!1" "x!2") (("2" (assert) nil)))))))))))))))))))))) nil) ((equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (reflexive? const-decl "bool" relations nil) (= const-decl "[T, T -> boolean]" equalities nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (EquivClass const-decl "set[T]" QuotientDefinition nil)) nil)) (repEC_TCC1 0 (repEC_TCC1-1 nil 3243663393 ("" (skosimp) (("" (grind) (("" (typepred "S!1") (("" (expand "equivalence?") (("" (flatten) (("" (hide -2 -3) (("" (expand "reflexive?") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((EquivClass const-decl "set[T]" QuotientDefinition nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (T formal-type-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil)) shostak (repEC subtype "QuotientDefinition.EquivClass(QuotientDefinition.S)(QuotientDefinition.x)" "(sets[QuotientDefinition.T].nonempty?)"))) (EquivClassChoose 0 (EquivClassChoose-1 nil 3243015830 ("" (skosimp*) (("" (use "EquivClassNonEmpty") (("" (expand "repEC") (("" (typepred "choose(EquivClass(S!1)(x!1))") (("1" (expand "EquivClass") (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((EquivClassNonEmpty formula-decl nil QuotientDefinition nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil QuotientDefinition nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (repEC const-decl "T" QuotientDefinition nil)) nil)) (ChooseEquivClassChoose 0 (ChooseEquivClassChoose-1 nil 3243015830 ("" (skosimp*) (("" (use "EquivClassNonEmpty") (("" (use "EquivClassEq") (("" (use "EquivClassChoose") (("" (assert) (("" (typepred "S!1") (("" (expand "equivalence?") (("" (expand "symmetric?") (("" (flatten) (("" (inst -2 "x!1" "repEC(S!1)(x!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((EquivClassNonEmpty formula-decl nil QuotientDefinition nil) (repEC const-decl "T" QuotientDefinition nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil QuotientDefinition nil) (EquivClassChoose formula-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (symmetric? const-decl "bool" relations nil) (EquivClassEq formula-decl nil QuotientDefinition nil)) nil)) (rep_TCC1 0 (rep_TCC1-1 nil 3243663393 ("" (skosimp) (("" (grind) (("" (typepred "P!1") (("" (skosimp) (("" (expand "EquivClass") (("" (decompose-equality) (("" (inst -1 "x!1") (("" (inst -2 "x!1") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (typepred "S!1") (("" (expand "equivalence?") (("" (flatten) (("" (hide -2 -3) (("" (expand "reflexive?") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil QuotientDefinition nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (Quotient type-eq-decl nil QuotientDefinition nil)) shostak (rep subtype "QuotientDefinition.P" "(sets[QuotientDefinition.T].nonempty?)"))) (rep_is_repEC_TCC1 0 (rep_is_repEC_TCC1-1 nil 3243663393 ("" (skosimp) (("" (inst 1 "x!1") nil nil)) nil) ((T formal-type-decl nil QuotientDefinition nil)) shostak (rep_is_repEC subtype "QuotientDefinition.EquivClass(QuotientDefinition.S)(QuotientDefinition.x)" "QuotientDefinition.Quotient(QuotientDefinition.S)"))) (rep_is_repEC 0 (rep_is_repEC-1 nil 3243664057 ("" (grind) nil nil) ((rep const-decl "T" QuotientDefinition nil) (repEC const-decl "T" QuotientDefinition nil)) shostak)) (rep_lemma 0 (rep_lemma-1 nil 3245191776 ("" (grind :if-match nil) (("" (use "epsilon_ax[T]") (("1" (grind :if-match nil) (("1" (inst 1 "x!1") (("1" (inst? -1) nil nil)) nil)) nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil) ((rep const-decl "T" QuotientDefinition nil)) shostak)) (quotient_map_surjective 0 (quotient_map_surjective-1 nil 3243015830 ("" (skosimp*) (("" (expand "surjective?") (("" (skosimp*) (("" (typepred "y!1") (("" (skosimp*) (("" (inst?) (("" (expand "quotient_map") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective? const-decl "bool" functions nil) (Quotient type-eq-decl nil QuotientDefinition nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) nil)))(KernelDefinition (EquivalenceKernel_TCC1 0 (EquivalenceKernel_TCC1-1 nil 3243663393 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" KernelDefinition nil) (X1 formal-subtype-decl nil KernelDefinition nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (equivalence? const-decl "bool" relations nil)) shostak (EquivalenceKernel subtype "{(x1, x2) | KernelDefinition.f(KernelDefinition.x1) = KernelDefinition.f(KernelDefinition.x2)}" "equivalence[X1]"))) (PreservesEqClosure 0 (PreservesEqClosure-1 nil 3243664201 ("" (skosimp*) (("" (expand "PreservesEq") (("" (apply-extensionality :hide? t) (("" (iff) (("" (prop) (("1" (lemma "EquivClosLeast[X1]") (("1" (inst?) (("1" (assert) (("1" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") nil nil)) nil)) nil)) nil) ("2" (lemma "EquivClosSuperset[X1]") (("2" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") (("2" (inst?) (("2" (lemma "subset_transitive[[X1, X1]]") (("2" (inst -1 "restrict[[X, X], [X1, X1], bool](R!1)" "EquivClos(restrict[[X, X], [X1, X1], boolean](R!1))" "EquivalenceKernel(x!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (EquivClosSuperset formula-decl nil EquivalenceClosure nil) (subset_transitive formula-decl nil sets_lemmas nil) (EquivClosLeast formula-decl nil EquivalenceClosure nil) (restrict_extend formula-decl nil extend nil) (symmetric_extend application-judgement "(symmetric?[T])" extend_order_props nil) (transitive_extend application-judgement "(transitive?[T])" extend_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil) (Y formal-type-decl nil KernelDefinition nil) (X1 formal-subtype-decl nil KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" KernelDefinition nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil KernelDefinition nil)) shostak)) (PreservesEq_is_preserving 0 (PreservesEq_is_preserving-1 nil 3244148904 ("" (grind) (("" (apply-extensionality :hide? t) nil nil)) nil) ((Y formal-type-decl nil KernelDefinition nil) (X1 formal-subtype-decl nil KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" KernelDefinition nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil KernelDefinition nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (preserves const-decl "bool" functions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (restrict const-decl "R" restrict nil) (preserves const-decl "bool" functions nil) (PreservesEq const-decl "bool" KernelDefinition nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil)) shostak)))(QuotientKernelProperties (Kernel_quotient_map 0 (Kernel_quotient_map-1 nil 3243015830 ("" (skosimp*) (("" (expand "quotient_map") (("" (apply-extensionality :hide? t) (("1" (expand "EquivalenceKernel") (("1" (use "EquivClassEq[X1]") (("1" (assert) (("1" (iff) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ((quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (S!1 skolem-const-decl "equivalence[X1]" QuotientKernelProperties nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (Quotient type-eq-decl nil QuotientDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil QuotientKernelProperties nil)) nil)) (PreservesEq_quotient_map 0 (PreservesEq_quotient_map-1 nil 3243665917 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (use "EquivClassEq[X1]") (("" (assert) (("" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (X formal-type-decl nil QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (FALSE const-decl "bool" booleans nil) (restrict_extend formula-decl nil extend nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_extend application-judgement "(transitive?[T])" extend_order_props nil) (symmetric_extend application-judgement "(symmetric?[T])" extend_order_props nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) shostak)) (quotient_map_is_Quotient_EqivalenceRespecting 0 (quotient_map_is_Quotient_EqivalenceRespecting-3 nil 3244167432 ("" (skosimp*) (("" (expand "PreservesEq") (("" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (use "EquivClassEq[X1]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (FALSE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil QuotientKernelProperties nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (restrict_extend formula-decl nil extend nil)) nil (quotient_map_is_Quotient_EqivalenceRespecting subtype "QuotientDefinition[X1].quotient_map(QuotientKernelProperties.S)" "(KernelDefinition[QuotientKernelProperties.X, X1, QuotientDefinition[X1].Quotient(QuotientKernelProperties.S)].PreservesEq(extend[[QuotientKernelProperties.X, QuotientKernelProperties.X], [X1, X1], booleans.bool, booleans.FALSE].extend(QuotientKernelProperties.S)))")) (quotient_map_is_Quotient_EqivalenceRespecting-2 nil 3244167419 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (use "EquivClassEq") (("" (assert) nil)))))))))))))))) nil) nil nil (quotient_map_is_Quotient_EqivalenceRespecting subtype "QuotientDefinition[X1].quotient_map(QuotientKernelProperties.S)" "(KernelDefinition[QuotientKernelProperties.X, X1, QuotientDefinition[X1].Quotient(QuotientKernelProperties.S)].PreservesEq(extend[[QuotientKernelProperties.X, QuotientKernelProperties.X], [X1, X1], booleans.bool, booleans.FALSE].extend(QuotientKernelProperties.S)))")) (quotient_map_is_Quotient_EqivalenceRespecting-1 nil 3243663394 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (use "EquivClassEq") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (X formal-type-decl nil QuotientKernelProperties nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) shostak (quotient_map_is_Quotient_EqivalenceRespecting subtype "QuotientDefinition[X1].quotient_map(QuotientKernelProperties.S)" "(KernelDefinition[QuotientKernelProperties.X, X1, QuotientDefinition[X1].Quotient(QuotientKernelProperties.S)].PreservesEq(extend[[QuotientKernelProperties.X, QuotientKernelProperties.X], [X1, X1], booleans.bool, booleans.FALSE].extend(QuotientKernelProperties.S)))"))) (Kernel_ECquotient_map_TCC1 0 (Kernel_ECquotient_map_TCC1-1 nil 3243663394 ("" (skosimp) (("" (expand "quotient_map") (("" (lemma "EquivalenceCharacterization[X1]") (("" (inst -1 "S!1") (("" (assert) (("" (replace -1 :dir rl) (("" (inst 1 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EquivalenceCharacterization formula-decl nil EquivalenceClosure nil) (X formal-type-decl nil QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil)) shostak (Kernel_ECquotient_map subtype "QuotientDefinition[X1].quotient_map(QuotientKernelProperties.S)" "[X1 -> QuotientDefinition[X1].ECQuotient(QuotientKernelProperties.S)]"))) (Kernel_ECquotient_map 0 (Kernel_ECquotient_map-1 nil 3243666194 ("" (skosimp) (("" (expand "quotient_map") (("" (apply-extensionality :hide? t) (("1" (expand "EquivalenceKernel") (("1" (use "EquivClassEq[X1]") (("1" (assert) (("1" (iff) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (lemma "EquivalenceCharacterization[X1]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivalenceCharacterization formula-decl nil EquivalenceClosure nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (EquivClos const-decl "equivalence[T]" EquivalenceClosure nil) (S!1 skolem-const-decl "equivalence[X1]" QuotientKernelProperties nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (ECQuotient type-eq-decl nil QuotientDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil QuotientKernelProperties nil)) shostak)) (PreservesEq_ECquotient_map 0 (PreservesEq_ECquotient_map-1 nil 3243666401 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (use "EquivClassEq[X1]") (("" (assert) (("" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (X formal-type-decl nil QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (FALSE const-decl "bool" booleans nil) (restrict_extend formula-decl nil extend nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_extend application-judgement "(transitive?[T])" extend_order_props nil) (symmetric_extend application-judgement "(symmetric?[T])" extend_order_props nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) shostak)) (quotient_map_is_ECQuotient_EqivalenceRespecting 0 (quotient_map_is_ECQuotient_EqivalenceRespecting-1 nil 3243663394 ("" (skosimp) (("" (prop) (("1" (skosimp) (("1" (lemma "Kernel_ECquotient_map_TCC1") (("1" (inst -1 "S!1" "x1!1") nil nil)) nil)) nil) ("2" (expand "PreservesEq") (("2" (expand "subset?") (("2" (skosimp*) (("2" (expand "member") (("2" (rewrite "restrict_extend[[X, X], [X1, X1], bool, FALSE]") (("2" (expand "EquivalenceKernel") (("2" (expand "quotient_map") (("2" (use "EquivClassEq[X1]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Kernel_ECquotient_map_TCC1 subtype-tcc nil QuotientKernelProperties nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (X1 formal-subtype-decl nil QuotientKernelProperties nil) (X1_pred const-decl "[X -> boolean]" QuotientKernelProperties nil) (boolean nonempty-type-decl nil booleans nil) (X formal-type-decl nil QuotientKernelProperties nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (FALSE const-decl "bool" booleans nil) (restrict_extend formula-decl nil extend nil) (PreservesEq const-decl "bool" KernelDefinition nil)) shostak (quotient_map_is_ECQuotient_EqivalenceRespecting subtype "QuotientDefinition[X1].quotient_map(QuotientKernelProperties.S)" "(KernelDefinition[QuotientKernelProperties.X, X1, QuotientDefinition[X1].ECQuotient(QuotientKernelProperties.S)].PreservesEq(extend[[QuotientKernelProperties.X, QuotientKernelProperties.X], [X1, X1], booleans.bool, booleans.FALSE].extend(QuotientKernelProperties.S)))"))))(QuotientSubDefinition (quotient_sub_map_TCC1 0 (quotient_sub_map_TCC1-1 nil 3245525335 ("" (grind :exclude "rep" :if-match nil) (("" (inst 1 "x!1") nil nil)) nil) ((equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientSubDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientSubDefinition nil) (X1 formal-subtype-decl nil QuotientSubDefinition nil)) shostak (quotient_sub_map subtype "QuotientDefinition[QuotientSubDefinition.X].EquivClass(QuotientSubDefinition.S)(QuotientSubDefinition.x)" "QuotientSubDefinition.QuotientSub(QuotientSubDefinition.S)"))))(QuotientExtensionProperties (lift_TCC1 0 (lift_TCC1-1 nil 3245193421 ("" (grind :exclude "rep" :if-match nil) (("" (inst 1 "x!1") nil nil)) nil) ((equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil)) shostak (lift subtype "QuotientExtensionProperties.P" "QuotientDefinition[QuotientExtensionProperties.X].Quotient(QuotientExtensionProperties.S)"))) (lift_TCC2 0 (lift_TCC2-3 "" 3658949058 ("" (grind :exclude "rep" :if-match nil) (("" (use "rep_lemma[X]" :if-match all) (("" (expand "EquivClass" -1 1) (("" (inst -6 "(x!1, rep(S!1)(EquivClass(S!1)(x!1)))") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((rep_lemma formula-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil)) shostak (lift subtype "QuotientDefinition[QuotientExtensionProperties.X].rep(QuotientExtensionProperties.S)(QuotientExtensionProperties.P)" "X1")) (lift_TCC2-2 "" 3590861164 ("" (grind :exclude "rep" :if-match nil) (("" (use "rep_lemma[X]" :if-match all) (("" (expand "EquivClass" -1 1) (("" (inst -3 "(x!1, rep(S!1)(EquivClass(S!1)(x!1)))") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((rep_lemma formula-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil)) shostak (lift subtype "QuotientDefinition[QuotientExtensionProperties.X].rep(QuotientExtensionProperties.S)(QuotientExtensionProperties.P)" "X1")) (lift_TCC2-1 nil 3245525012 ("" (grind :exclude "rep" :if-match nil) (("" (use "rep_lemma[X]" :if-match all) (("" (expand "EquivClass" -1 1) (("" (inst -6 "(x!1, rep(S!1)(EquivClass(S!1)(x!1)))") (("1" (assert) nil nil) ("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil) ((rep_lemma formula-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (PreservesEq const-decl "bool" KernelDefinition nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil)) shostak (lift subtype "QuotientDefinition[QuotientExtensionProperties.X].rep(QuotientExtensionProperties.S)(QuotientExtensionProperties.P)" "X1"))) (lift_commutation 0 (lift_commutation-3 "" 3658949262 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (use "rep_lemma[X]") (("" (expand "EquivClass" -1) (("" (inst -6 "(x!1, rep(S!1)({z: X | S!1(x!1, z)}))") (("1" (assert) (("1" (expand "EquivClass" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -5 "(x!1, rep(S!1)(EquivClass(S!1)(x!1)))") (("2" (assert) (("2" (expand "EquivClass") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (expand "EquivClass" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil) (O const-decl "T3" function_props nil) (lift const-decl "Y" QuotientExtensionProperties nil) (quotient_sub_map const-decl "QuotientSub(S)" QuotientSubDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (x!1 skolem-const-decl "X1" QuotientExtensionProperties nil) (S!1 skolem-const-decl "{R: equivalence[X] | PreservesEq[X, X, bool](R)(X1_pred)}" QuotientExtensionProperties nil) (rep_lemma formula-decl nil QuotientDefinition nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil)) shostak) (lift_commutation-2 "" 3590861329 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (use "rep_lemma[X]") (("" (expand "EquivClass" -1) (("" (inst -6 "(x!1, rep(S!1)({z: X | S!1(x!1, z)}))") (("1" (assert) (("1" (expand "EquivClass" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -2 "(x!1, rep(S!1)({z: X | S!1(x!1, z)}))") (("1" (assert) nil nil) ("2" (inst 1 "x!1") (("2" (expand "EquivClass" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (expand "EquivClass" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil) (O const-decl "T3" function_props nil) (lift const-decl "Y" QuotientExtensionProperties nil) (quotient_sub_map const-decl "QuotientSub(S)" QuotientSubDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (rep_lemma formula-decl nil QuotientDefinition nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil)) shostak) (lift_commutation-1 nil 3243666489 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (use "rep_lemma[X]") (("" (expand "EquivClass" -1) (("" (inst -6 "(x!1, rep(S!1)({z: X | S!1(x!1, z)}))") (("1" (assert) (("1" (expand "EquivClass" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -5 "(x!1, rep(S!1)({z: X | S!1(x!1, z)}))") (("1" (assert) nil nil) ("2" (inst 1 "x!1") (("2" (expand "EquivClass" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (expand "EquivClass" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil) (O const-decl "T3" function_props nil) (lift const-decl "Y" QuotientExtensionProperties nil) (quotient_sub_map const-decl "QuotientSub(S)" QuotientSubDefinition nil) (rep const-decl "T" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (rep_lemma formula-decl nil QuotientDefinition nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientExtensionProperties nil) (PRED type-eq-decl nil defined_types nil) (PreservesEq const-decl "bool" KernelDefinition nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (Y formal-type-decl nil QuotientExtensionProperties nil)) shostak)) (lift_unicity 0 (lift_unicity-1 nil 3243666688 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (typepred "x!1") (("" (skosimp*) (("" (case "h!1(x!1) = g!1(x!2)") (("1" (replace -1) (("1" (hide -1 -3) (("1" (expand "lift") (("1" (replace -1) (("1" (hide -1) (("1" (use "rep_lemma[X]") (("1" (grind :exclude "rep" :if-match nil) (("1" (typepred "g!1") (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "EquivalenceKernel") (("1" (expand "restrict") (("1" (inst -1 "(x!2, rep(S!1)(EquivClass[X](S!1)(x!2)))") (("1" (assert) nil nil) ("2" (typepred "S!1") (("2" (expand "PreservesEq") (("2" (expand "subset?") (("2" (expand "member") (("2" (expand "EquivalenceKernel") (("2" (expand "restrict") (("2" (inst -2 "(x!2, rep(S!1)(EquivClass[X](S!1)(x!2)))") (("1" (assert) nil nil) ("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 1 rl) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((X formal-type-decl nil QuotientExtensionProperties nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (X1_pred const-decl "[X -> boolean]" QuotientExtensionProperties nil) (X1 formal-subtype-decl nil QuotientExtensionProperties nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (QuotientSub type-eq-decl nil QuotientSubDefinition nil) (Y formal-type-decl nil QuotientExtensionProperties nil) (lift const-decl "Y" QuotientExtensionProperties nil) (O const-decl "T3" function_props nil) (quotient_sub_map const-decl "QuotientSub(S)" QuotientSubDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (Quotient type-eq-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (rep_lemma formula-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)))(QuotientDistributive (EqualityExtension_is_equivalence 0 (EqualityExtension_is_equivalence-1 nil 3245193423 ("" (grind :if-match nil) (("1" (forward-chain -3) nil nil) ("2" (forward-chain -2) nil nil) ("3" (inst? -1) nil nil)) nil) ((Y formal-type-decl nil QuotientDistributive nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil)) shostak (EqualityExtension_is_equivalence subtype "QuotientDistributive.EqualityExtension(QuotientDistributive.S)" "equivalence[[X, Y]]"))) (EqualityExtensionPreservesEq 0 (EqualityExtensionPreservesEq-1 nil 3245193857 ("" (grind :exclude "rep" :if-match nil) (("" (use "EquivClassEq[X]") (("" (assert) nil nil)) nil)) nil) ((EquivClassEq formula-decl nil QuotientDefinition nil) (Y formal-type-decl nil QuotientDistributive nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak)) (QuotientDistributive_TCC1 0 (QuotientDistributive_TCC1-1 nil 3245193423 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (forward-chain -2) (("" (iff) (("" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (Y formal-type-decl nil QuotientDistributive nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (QuotientDistributive subtype "LAMBDA (x: QuotientDistributive.X, y: QuotientDistributive.Y): (QuotientDefinition[QuotientDistributive.X].quotient_map(QuotientDistributive.S)(x), y)" "(KernelDefinition[[QuotientDistributive.X, QuotientDistributive.Y], [QuotientDistributive.X, QuotientDistributive.Y], [QuotientDefinition[QuotientDistributive.X].Quotient(QuotientDistributive.S), QuotientDistributive.Y]].PreservesEq(QuotientDistributive.EqualityExtension(QuotientDistributive.S)))"))) (QuotientDistributive_TCC2 0 (QuotientDistributive_TCC2-1 nil 3245193423 ("" (grind :exclude "rep" :if-match nil) (("1" (rewrite "restrict_full[[[X, Y], [X, Y]], bool]") (("1" (inst? 1) nil nil)) nil) ("2" (rewrite "restrict_full[[[X, Y], [X, Y]], bool]") (("2" (inst? 1) nil nil)) nil)) nil) ((EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (PreservesEq const-decl "bool" KernelDefinition nil)) shostak (QuotientDistributive subtype "QuotientDistributive.EqualityExtension(QuotientDistributive.S)" "{R: relations[[QuotientDistributive.X, QuotientDistributive.Y]].equivalence | KernelDefinition[[QuotientDistributive.X, QuotientDistributive.Y], [QuotientDistributive.X, QuotientDistributive.Y], booleans.bool].PreservesEq(R)(LAMBDA (x: [QuotientDistributive.X, QuotientDistributive.Y]): booleans.TRUE)}"))) (QuotientDistributive 0 (QuotientDistributive-2 "" 3458173920 ("" (skosimp*) (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (expand "rep") (("1" (flatten) (("1" (typepred "x1!1" "x2!1") (("1" (skosimp*) (("1" (case "nonempty?(x1!1)") (("1" (case "nonempty?(x2!1)") (("1" (name-replace "ch1" "choose(x1!1)") (("1" (name-replace "ch2" "choose(x2!1)") (("1" (typepred "ch1" "ch2") (("1" (replace*) (("1" (hide -3 -4 -5 -6) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "EqualityExtension") (("1" (flatten) (("1" (assert) (("1" (iff) (("1" (lemma "Kernel_quotient_map[X, X]") (("1" (inst?) (("1" (case "EquivalenceKernel[X, X, Quotient[X](S!1)](quotient_map(S!1))(ch1`1, ch2`1)") (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (smash) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (hide -1 -6 -8 -10 -11 -12) (("1" (inst-cp -1 "ch1`1" "ch2`1") (("1" (assert) (("1" (hide -4) (("1" (inst -1 "x!1`1" "ch1`1") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!2`1" "ch2`1" "ch1`1") (("1" (assert) (("1" (inst-cp -3 "x!2`1" "ch1`1" "x!1`1") (("1" (assert) (("1" (inst -3 "x!2`1" "x!1`1" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -5 -7 -8 -9) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst -1 "x!2`1" "ch2`1") (("2" (assert) (("2" (hide -6) (("2" (inst-cp -2 "x!1`1" "ch1`1" "ch2`1") (("2" (assert) (("2" (hide -4 -6) (("2" (inst-cp -2 "x!1`1" "ch2`1" "x!2`1") (("2" (assert) (("2" (hide -1 -4) (("2" (inst -1 "x!1`1" "x!2`1" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "EquivalenceKernel") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1 -2 -3 -4 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1`1") (("2" (skosimp*) (("2" (case "nonempty?(y!1`1)") (("1" (inst 1 "EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2)") (("1" (expand "lift") (("1" (expand "rep") (("1" (case "nonempty?(EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2))") (("1" (name-replace "ch" "choose(EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2))") (("1" (typepred "ch") (("1" (hide -2 -3) (("1" (expand "EquivClass") (("1" (expand "EqualityExtension") (("1" (flatten) (("1" (name-replace "ch1" "choose(y!1`1)") (("1" (typepred "ch1") (("1" (replace -4 -1) (("1" (assert) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (replace -4) (("1" (hide -3 -4) (("1" (assert) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (prop) (("1" (expand "transitive?") (("1" (inst-cp -4 "x!1" "ch1" "ch`1") (("1" (assert) (("1" (hide -2 -3 -6 -7) (("1" (inst -2 "x!1" "ch`1" "x!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst-cp -3 "ch1" "ch`1") (("2" (assert) (("2" (hide -7) (("2" (inst -3 "x!1" "ch1") (("2" (assert) (("2" (hide -2 -6) (("2" (inst-cp -4 "ch`1" "ch1" "x!1") (("2" (assert) (("2" (hide -2 -3) (("2" (inst -2 "ch`1" "x!1" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (grind) (("2" (inst -1 "(choose(y!1`1), y!1`2)") (("1" (assert) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (grind :if-match nil) (("2" (inst -1 "x!1") (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (expand "reflexive?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (y!1 skolem-const-decl "[Quotient[X](S!1), Y]" QuotientDistributive nil) (S!1 skolem-const-decl "equivalence[X]" QuotientDistributive nil) (injective? const-decl "bool" functions nil) (lift const-decl "Y" QuotientExtensionProperties nil) (Kernel_quotient_map formula-decl nil QuotientKernelProperties nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (EqualityExtension_is_equivalence application-judgement "equivalence[[X, Y]]" QuotientDistributive nil) (choose const-decl "(p)" sets nil) (reflexive? const-decl "bool" relations nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil) (Quotient type-eq-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil)) shostak) (QuotientDistributive-1 nil 3245193912 ("" (skosimp*) (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (expand "rep") (("1" (flatten) (("1" (typepred "x1!1" "x2!1") (("1" (skosimp*) (("1" (case "nonempty?(x1!1)") (("1" (case "nonempty?(x2!1)") (("1" (name-replace "ch1" "choose(x1!1)") (("1" (name-replace "ch2" "choose(x2!1)") (("1" (typepred "ch1" "ch2") (("1" (replace*) (("1" (hide -3 -4 -5 -6) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "EqualityExtension") (("1" (flatten) (("1" (assert) (("1" (iff) (("1" (lemma "Kernel_quotient_map[X, X]") (("1" (inst?) (("1" (case "EquivalenceKernel[X, X, Quotient[X](S!1)](quotient_map(S!1))(ch1`1, ch2`1)") (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (smash) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (hide -1 -6 -8 -10 -11 -12) (("1" (inst-cp -1 "ch1`1" "ch2`1") (("1" (assert) (("1" (hide -4) (("1" (inst -1 "x!1`1" "ch1`1") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!2`1" "ch2`1" "ch1`1") (("1" (assert) (("1" (inst-cp -3 "x!2`1" "ch1`1" "x!1`1") (("1" (assert) (("1" (inst -3 "x!2`1" "x!1`1" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -5 -7 -8 -9) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst -1 "x!2`1" "ch2`1") (("2" (assert) (("2" (hide -6) (("2" (inst-cp -2 "x!1`1" "ch1`1" "ch2`1") (("2" (assert) (("2" (hide -4 -6) (("2" (inst-cp -2 "x!1`1" "ch2`1" "x!2`1") (("2" (assert) (("2" (hide -1 -4) (("2" (inst -1 "x!1`1" "x!2`1" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "EquivalenceKernel") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1 -2 -3 -4 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1`1") (("2" (skosimp*) (("2" (case "nonempty?(y!1`1)") (("1" (inst 1 "EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2)") (("1" (expand "lift") (("1" (expand "rep") (("1" (case "nonempty?(EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2))") (("1" (name-replace "ch" "choose(EquivClass[[X, Y]](EqualityExtension(S!1))(choose(y!1`1), y!1`2))") (("1" (typepred "ch") (("1" (hide -2 -3) (("1" (expand "EquivClass") (("1" (expand "EqualityExtension") (("1" (flatten) (("1" (name-replace "ch1" "choose(y!1`1)") (("1" (typepred "ch1") (("1" (replace -4 -1) (("1" (assert) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (replace -4) (("1" (hide -3 -4) (("1" (assert) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (prop) (("1" (expand "transitive?") (("1" (inst-cp -4 "x!1" "ch1" "ch`1") (("1" (assert) (("1" (hide -2 -3 -6 -7) (("1" (inst -2 "x!1" "ch`1" "x!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst-cp -3 "ch1" "ch`1") (("2" (assert) (("2" (hide -7) (("2" (inst -3 "x!1" "ch1") (("2" (assert) (("2" (hide -2 -6) (("2" (inst-cp -4 "ch`1" "ch1" "x!1") (("2" (assert) (("2" (hide -2 -3) (("2" (inst -2 "ch`1" "x!1" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "ch`1") (("2" (apply-extensionality :hide? t) (("2" (expand "EquivClass") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (grind) (("2" (inst -1 "(epsilon(y!1`1), y!1`2)") (("1" (assert) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst?) (("1" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (inst?) nil nil)) nil) ("2" (replace -1) (("2" (hide -1 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (lift const-decl "Y" QuotientExtensionProperties nil) (Kernel_quotient_map formula-decl nil QuotientKernelProperties nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (EqualityExtension_is_equivalence application-judgement "equivalence[[X, Y]]" QuotientDistributive nil) (choose const-decl "(p)" sets nil) (reflexive? const-decl "bool" relations nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (EqualityExtension const-decl "set[[[X, Y], [X, Y]]]" QuotientDistributive nil) (Quotient type-eq-decl nil QuotientDefinition nil) (rep const-decl "T" QuotientDefinition nil)) shostak)) (RelExtension_TCC1 0 (RelExtension_TCC1-2 "" 3332191104 ("" (grind :exclude "rep" :if-match nil) (("1" (forward-chain -6) nil nil) ("2" (forward-chain -3) nil nil) ("3" (forward-chain -5) nil nil) ("4" (forward-chain -2) nil nil) ("5" (inst? -4) nil nil) ("6" (inst? -1) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence type-eq-decl nil relations nil) (Y formal-type-decl nil QuotientDistributive nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (RelExtension subtype "{(z, w) | booleans.AND(QuotientDistributive.S(QuotientDistributive.z`1, QuotientDistributive.w`1), QuotientDistributive.R(QuotientDistributive.z`2, QuotientDistributive.w`2))}" "equivalence[[X, Y]]")) (RelExtension_TCC1-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("1" (forward-chain -3) nil nil) ("2" (forward-chain -6) nil nil) ("3" (forward-chain -2) nil nil) ("4" (forward-chain -5) nil nil) ("5" (inst? -1) nil nil) ("6" (inst? -4) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence type-eq-decl nil relations nil) (Y formal-type-decl nil QuotientDistributive nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (RelExtension subtype "{(z, w) | booleans.AND(QuotientDistributive.S(QuotientDistributive.z`1, QuotientDistributive.w`1), QuotientDistributive.R(QuotientDistributive.z`2, QuotientDistributive.w`2))}" "equivalence[[X, Y]]"))) (RelExtensionPreservesEq 0 (RelExtensionPreservesEq-1 nil 3245194382 ("" (grind :if-match nil) (("1" (use "EquivClassEq[Y]") (("1" (assert) nil nil)) nil) ("2" (use "EquivClassEq[X]") (("2" (assert) nil nil)) nil)) nil) ((EquivClassEq formula-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (X formal-type-decl nil QuotientDistributive nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (RelExtension const-decl "equivalence[[X, Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak)) (RelQuotientDistributive_TCC1 0 (RelQuotientDistributive_TCC1-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("1" (apply-extensionality :hide? t) (("1" (hide -4 -5 -6 -7) (("1" (forward-chain -2) (("1" (iff) (("1" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (hide -1 -2 -3 -4 -8) (("2" (forward-chain -1) (("2" (iff) (("2" (prop) (("1" (forward-chain -3) nil nil) ("2" (hide -2) (("2" (forward-chain -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (X formal-type-decl nil QuotientDistributive nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (RelExtension const-decl "equivalence[[X, Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (RelQuotientDistributive subtype "LAMBDA (x: QuotientDistributive.X, y: QuotientDistributive.Y): (QuotientDefinition[QuotientDistributive.X].quotient_map(QuotientDistributive.S)(x), QuotientDefinition[QuotientDistributive.Y].quotient_map(QuotientDistributive.R)(y))" "(KernelDefinition[[QuotientDistributive.X, QuotientDistributive.Y], [QuotientDistributive.X, QuotientDistributive.Y], [QuotientDefinition[QuotientDistributive.X].Quotient(QuotientDistributive.S), QuotientDefinition[QuotientDistributive.Y].Quotient(QuotientDistributive.R)]].PreservesEq(QuotientDistributive.RelExtension(QuotientDistributive.S, QuotientDistributive.R)))"))) (RelQuotientDistributive_TCC2 0 (RelQuotientDistributive_TCC2-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("1" (rewrite "restrict_full[[[X, Y], [X, Y]], bool]") (("1" (inst?) nil nil)) nil) ("2" (rewrite "restrict_full[[[X, Y], [X, Y]], bool]") (("2" (inst?) nil nil)) nil)) nil) ((RelExtension const-decl "equivalence[[X, Y]]" QuotientDistributive nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (PreservesEq const-decl "bool" KernelDefinition nil)) shostak (RelQuotientDistributive subtype "QuotientDistributive.RelExtension(QuotientDistributive.S, QuotientDistributive.R)" "{R: relations[[QuotientDistributive.X, QuotientDistributive.Y]].equivalence | KernelDefinition[[QuotientDistributive.X, QuotientDistributive.Y], [QuotientDistributive.X, QuotientDistributive.Y], booleans.bool].PreservesEq(R)(LAMBDA (x: [QuotientDistributive.X, QuotientDistributive.Y]): booleans.TRUE)}"))) (RelQuotientDistributive 0 (RelQuotientDistributive-1 nil 3245194514 ("" (skosimp*) (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (flatten) (("1" (typepred "x1!1" "x2!1") (("1" (skosimp*) (("1" (case "nonempty?(x1!1)") (("1" (case "nonempty?(x2!1)") (("1" (expand "rep") (("1" (name-replace "ch1" "choose(x1!1)") (("1" (name-replace "ch2" "choose(x2!1)") (("1" (typepred "ch1" "ch2") (("1" (replace -5) (("1" (hide -5) (("1" (replace -5) (("1" (hide -5) (("1" (hide -3 -4) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "RelExtension") (("1" (flatten) (("1" (assert) (("1" (iff) (("1" (lemma "Kernel_quotient_map[X, X]") (("1" (lemma "Kernel_quotient_map[Y, Y]") (("1" (inst?) (("1" (inst?) (("1" (case "EquivalenceKernel[X, X, Quotient[X](S!1)](quotient_map(S!1))(ch1`1, ch2`1)") (("1" (case "EquivalenceKernel[Y, Y, Quotient[Y](R!1)](quotient_map(R!1))(ch1`2, ch2`2)") (("1" (replace -3) (("1" (replace -4) (("1" (hide -3 -4) (("1" (assert) (("1" (smash) (("1" (typepred "R!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (hide -1 -5 -6 -8 -10 -12 -13) (("1" (inst-cp -1 "ch1`2" "ch2`2") (("1" (assert) (("1" (hide -4) (("1" (inst -1 "x!1`2" "ch1`2") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!2`2" "ch2`2" "ch1`2") (("1" (assert) (("1" (hide -6 -2) (("1" (inst-cp -2 "x!2`2" "ch1`2" "x!1`2") (("1" (assert) (("1" (hide -4 -1) (("1" (inst -1 "x!2`2" "x!1`2" "x!4") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -6 -8 -9 -10) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (hide -1) (("2" (inst-cp -1 "ch1`1" "ch2`1") (("2" (assert) (("2" (hide -4) (("2" (inst -1 "x!1`1" "ch1`1") (("2" (assert) (("2" (hide -5) (("2" (inst-cp -3 "x!2`1" "ch2`1" "ch1`1") (("2" (assert) (("2" (hide -6 -2) (("2" (inst-cp -2 "x!2`1" "ch1`1" "x!1`1") (("2" (assert) (("2" (hide -4 -1) (("2" (inst -1 "x!2`1" "x!1`1" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -3 -5 -7 -9 -10) (("3" (typepred "R!1") (("3" (expand "equivalence?") (("3" (flatten) (("3" (hide -1) (("3" (expand "symmetric?") (("3" (expand "transitive?") (("3" (inst -1 "x!2`2" "ch2`2") (("3" (assert) (("3" (hide -6) (("3" (inst-cp -2 "x!1`2" "ch1`2" "ch2`2") (("3" (assert) (("3" (hide -6 -4) (("3" (inst-cp -2 "x!1`2" "ch2`2" "x!2`2") (("3" (assert) (("3" (hide -4 -1) (("3" (inst -1 "x!1`2" "x!2`2" "x!4") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -4 -6 -8 -9 -10) (("4" (typepred "S!1") (("4" (expand "equivalence?") (("4" (flatten) (("4" (expand "symmetric?") (("4" (expand "transitive?") (("4" (hide -1) (("4" (inst -1 "x!2`1" "ch2`1") (("4" (assert) (("4" (hide -6) (("4" (inst-cp -2 "x!1`1" "ch1`1" "ch2`1") (("4" (assert) (("4" (hide -6 -4) (("4" (inst-cp -2 "x!1`1" "ch2`1" "x!2`1") (("4" (assert) (("4" (hide -4 -1) (("4" (inst -1 "x!1`1" "x!2`1" "x!3") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "EquivalenceKernel") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "EquivalenceKernel") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) (("1" (typepred "R!1") (("1" (grind) nil nil)) nil) ("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1 -2 -3 -4 2) (("2" (grind) (("1" (typepred "R!1") (("1" (grind) nil nil)) nil) ("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1`1") (("2" (typepred "y!1`2") (("2" (skosimp*) (("2" (case "nonempty?(y!1`1)") (("1" (case "nonempty?(y!1`2)") (("1" (inst 1 "EquivClass[[X, Y]](RelExtension(S!1,R!1))(choose(y!1`1), choose(y!1`2))") (("1" (case "nonempty?(EquivClass[[X, Y]]
                                             (RelExtension(S!1, R!1))(choose(y!1`1), choose(y!1`2)))") (("1" (expand "lift") (("1" (expand "rep") (("1" (name-replace "ch" "choose(EquivClass[[X, Y]]
                                            (RelExtension(S!1, R!1))(choose(y!1`1), choose(y!1`2)))") (("1" (typepred "ch") (("1" (expand "EquivClass") (("1" (expand "RelExtension") (("1" (flatten) (("1" (name-replace "ch1" "choose(y!1`1)") (("1" (name-replace "ch2" "choose(y!1`2)") (("1" (typepred "ch1" "ch2") (("1" (replace -8 -2) (("1" (replace -9 -1) (("1" (assert) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (replace -9 1) (("1" (assert) (("1" (iff) (("1" (hide -2 -4 -5 -6 -7 -8 -9) (("1" (typepred "S!1") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (prop) (("1" (hide -2) (("1" (inst-cp -2 "x!2" "ch1" "ch`1") (("1" (assert) (("1" (hide -4 -5) (("1" (inst -2 "x!2" "ch`1" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -2 "ch1" "ch`1") (("2" (assert) (("2" (hide -6) (("2" (inst -2 "x!2" "ch1") (("2" (assert) (("2" (hide -5) (("2" (inst-cp -4 "ch`1" "ch1" "x!2") (("2" (assert) (("2" (hide -3 -2) (("2" (inst -2 "ch`1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (replace -8 1) (("2" (assert) (("2" (iff) (("2" (typepred "R!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1 -4 -6 -8 -9 -10 -11 -12) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (prop) (("1" (hide -2) (("1" (inst-cp -2 "x!1" "ch2" "ch`2") (("1" (assert) (("1" (hide -4 -5) (("1" (inst -2 "x!1" "ch`2" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -2 "ch2" "ch`2") (("2" (assert) (("2" (hide -6) (("2" (inst -2 "x!1" "ch2") (("2" (assert) (("2" (hide -5) (("2" (inst-cp -4 "ch`2" "ch2" "x!1") (("2" (assert) (("2" (hide -3 -2) (("2" (inst -2 "ch`2" "x!1" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "EquivClass") (("3" (inst 1 "ch`2") nil nil)) nil) ("4" (expand "EquivClass") (("4" (inst 1 "ch`1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?" 1) (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "EquivClass" -1) (("2" (expand "RelExtension" -1) (("2" (inst -1 "(choose(y!1`1), choose(y!1`2))") (("2" (typepred "S!1" "R!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -2 -3 -5 -6) (("2" (expand "reflexive?") (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil) ("2" (expand "EquivClass" 1) (("2" (expand "RelExtension" 1) (("2" (inst 1 "(choose(y!1`1), choose(y!1`2))") nil nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (replace -1) (("2" (hide -1) (("2" (grind) (("2" (typepred "R!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 1) (("2" (hide -1 -2 2) (("2" (grind) (("2" (typepred "S!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (S!1 skolem-const-decl "equivalence[X]" QuotientDistributive nil) (R!1 skolem-const-decl "equivalence[Y]" QuotientDistributive nil) (y!1 skolem-const-decl "[Quotient[X](S!1), Quotient[Y](R!1)]" QuotientDistributive nil) (injective? const-decl "bool" functions nil) (lift const-decl "Y" QuotientExtensionProperties nil) (Quotient type-eq-decl nil QuotientDefinition nil) (RelExtension const-decl "equivalence[[X, Y]]" QuotientDistributive nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (rep const-decl "T" QuotientDefinition nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (Kernel_quotient_map formula-decl nil QuotientKernelProperties nil) (choose const-decl "(p)" sets nil)) shostak)) (FunExtension_TCC1 0 (FunExtension_TCC1-3 "" 3658949833 ("" (grind :exclude "rep" :if-match nil) (("1" (typepred "F!1(x!2)") (("1" (inst?) (("1" (inst?) (("1" (grind :exclude "rep" :if-match nil) (("1" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "F!1(x!2)") (("2" (grind :exclude "rep" :if-match nil) (("2" (inst? -4) (("2" (inst -2 "x!1(x!2)" "y!1(x!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "F!1(x!2)") (("3" (grind :exclude "rep" :if-match nil) (("3" (inst? -1) nil nil)) nil)) nil)) nil) ((equivalence type-eq-decl nil relations nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (Y formal-type-decl nil QuotientDistributive nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (FunExtension subtype "{(f, g) | FORALL (x: QuotientDistributive.X): QuotientDistributive.F(x)(QuotientDistributive.f(x), QuotientDistributive.g(x))}" "equivalence[[X -> Y]]")) (FunExtension_TCC1-2 "" 3590861483 ("" (grind :exclude "rep" :if-match nil) (("1" (typepred "F!1(x!2)") (("1" (hide -2) (("1" (inst?) (("1" (inst?) (("1" (grind :exclude "rep" :if-match nil) (("1" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (inst?) (("2" (typepred "F!1(x!2)") (("2" (grind :exclude "rep" :if-match nil) (("2" (forward-chain -2) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "F!1(x!2)") (("3" (grind :exclude "rep" :if-match nil) (("3" (inst? -1) nil nil)) nil)) nil)) nil) ((equivalence type-eq-decl nil relations nil) (X formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (Y formal-type-decl nil QuotientDistributive nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (FunExtension subtype "{(f, g) | FORALL (x: QuotientDistributive.X): QuotientDistributive.F(x)(QuotientDistributive.f(x), QuotientDistributive.g(x))}" "equivalence[[X -> Y]]")) (FunExtension_TCC1-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("1" (typepred "F!1(x!2)") (("1" (inst?) (("1" (inst?) (("1" (grind :exclude "rep" :if-match nil) (("1" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil) ("2" (inst?) (("2" (typepred "F!1(x!2)") (("2" (grind :exclude "rep" :if-match nil) (("2" (forward-chain -2) nil nil)) nil)) nil)) nil) ("3" (typepred "F!1(x!2)") (("3" (grind :exclude "rep" :if-match nil) (("3" (inst? -1) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (FunExtension subtype "{(f, g) | FORALL (x: QuotientDistributive.X): QuotientDistributive.F(x)(QuotientDistributive.f(x), QuotientDistributive.g(x))}" "equivalence[[X -> Y]]"))) (FunExtensionPreservesEq 0 (FunExtensionPreservesEq-4 "" 3658950104 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) (("" (inst?) (("" (iff) (("" (typepred "F!1(x!2)") (("" (expand "equivalence?") (("" (flatten) (("" (hide -1) (("" (expand "symmetric?") (("" (expand "transitive?") (("" (prop) (("1" (inst -2 "x!1`1(x!2)" "x!1`2(x!2)") (("1" (assert) (("1" (forward-chain -3) nil nil)) nil)) nil) ("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak) (FunExtensionPreservesEq-3 "" 3590861688 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) (("" (hide -1) (("" (inst?) (("" (iff) (("" (typepred "F!1(x!2)") (("" (expand "equivalence?") (("" (flatten) (("" (hide -1) (("" (expand "symmetric?") (("" (expand "transitive?") (("" (prop) (("1" (inst -2 "x!1`1(x!2)" "x!1`2(x!2)") (("1" (assert) (("1" (forward-chain -3) nil nil)) nil)) nil) ("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak) (FunExtensionPreservesEq-2 "Fix for 3.2" 3307984197 ("" (grind) (("" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (inst?) (("1" (iff) (("1" (typepred "F!1(x!2)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (prop) (("1" (inst -2 "x!1`1(x!2)" "x!1`2(x!2)") (("1" (assert) (("1" (forward-chain -3) nil nil)) nil)) nil) ("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst? 1) nil nil)) nil) ("3" (skolem!) (("3" (inst? 1) nil nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak) (FunExtensionPreservesEq-1 nil 3245194994 ("" (grind) (("" (apply-extensionality :hide? t) (("" (apply-extensionality :hide? t) (("" (inst?) (("" (iff) (("" (typepred "F!1(x!2)") (("" (expand "equivalence?") (("" (flatten) (("" (hide -1) (("" (expand "symmetric?") (("" (expand "transitive?") (("" (prop) (("1" (inst -2 "x!1`1(x!2)" "x!1`2(x!2)") (("1" (assert) (("1" (forward-chain -3) nil nil)) nil)) nil) ("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (Quotient type-eq-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak)) (FunQuotientDistributive_TCC1 0 (FunQuotientDistributive_TCC1-4 "" 3658950169 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (inst?) (("" (typepred "F!1(x!2)") (("" (apply-extensionality :hide? t) (("" (flatten) (("" (forward-chain -2) (("" (iff) (("" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (FunQuotientDistributive subtype "LAMBDA (f: [QuotientDistributive.X -> QuotientDistributive.Y]): LAMBDA (x: QuotientDistributive.X): (QuotientDefinition[QuotientDistributive.Y].quotient_map(QuotientDistributive.F(x))(f(x)))" "(KernelDefinition[[QuotientDistributive.X -> QuotientDistributive.Y], [QuotientDistributive.X -> QuotientDistributive.Y], [x: QuotientDistributive.X -> QuotientDefinition[QuotientDistributive.Y].Quotient(QuotientDistributive.F(x))]].PreservesEq(QuotientDistributive.FunExtension(QuotientDistributive.F)))")) (FunQuotientDistributive_TCC1-3 "" 3590861839 ("" (grind :exclude "rep" :if-match nil) (("" (hide -1) (("" (apply-extensionality :hide? t) (("" (inst?) (("" (typepred "F!1(x!2)") (("" (apply-extensionality :hide? t) (("" (flatten) (("" (forward-chain -2) (("" (iff) (("" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (FunQuotientDistributive subtype "LAMBDA (f: [QuotientDistributive.X -> QuotientDistributive.Y]): LAMBDA (x: QuotientDistributive.X): (QuotientDefinition[QuotientDistributive.Y].quotient_map(QuotientDistributive.F(x))(f(x)))" "(KernelDefinition[[QuotientDistributive.X -> QuotientDistributive.Y], [QuotientDistributive.X -> QuotientDistributive.Y], [x: QuotientDistributive.X -> QuotientDefinition[QuotientDistributive.Y].Quotient(QuotientDistributive.F(x))]].PreservesEq(QuotientDistributive.FunExtension(QuotientDistributive.F)))")) (FunQuotientDistributive_TCC1-2 "" 3307985072 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("1" (inst?) (("1" (typepred "F!1(x!2)") (("1" (apply-extensionality :hide? t) (("1" (flatten) (("1" (forward-chain -2) (("1" (iff) (("1" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem!) (("2" (inst?) nil nil)) nil) ("3" (skolem!) (("3" (inst?) nil nil)) nil)) nil)) nil) ((transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (set type-eq-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (FunQuotientDistributive subtype "LAMBDA (f: [QuotientDistributive.X -> QuotientDistributive.Y]): LAMBDA (x: QuotientDistributive.X): (QuotientDefinition[QuotientDistributive.Y].quotient_map(QuotientDistributive.F(x))(f(x)))" "(KernelDefinition[[QuotientDistributive.X -> QuotientDistributive.Y], [QuotientDistributive.X -> QuotientDistributive.Y], [x: QuotientDistributive.X -> QuotientDefinition[QuotientDistributive.Y].Quotient(QuotientDistributive.F(x))]].PreservesEq(QuotientDistributive.FunExtension(QuotientDistributive.F)))")) (FunQuotientDistributive_TCC1-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (inst?) (("" (typepred "F!1(x!2)") (("" (apply-extensionality :hide? t) (("" (flatten) (("" (forward-chain -2) (("" (iff) (("" (prop) (("1" (forward-chain -4) nil nil) ("2" (hide -2) (("2" (forward-chain -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (Quotient type-eq-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil)) shostak (FunQuotientDistributive subtype "LAMBDA (f: [QuotientDistributive.X -> QuotientDistributive.Y]): LAMBDA (x: QuotientDistributive.X): (QuotientDefinition[QuotientDistributive.Y].quotient_map(QuotientDistributive.F(x))(f(x)))" "(KernelDefinition[[QuotientDistributive.X -> QuotientDistributive.Y], [QuotientDistributive.X -> QuotientDistributive.Y], [x: QuotientDistributive.X -> QuotientDefinition[QuotientDistributive.Y].Quotient(QuotientDistributive.F(x))]].PreservesEq(QuotientDistributive.FunExtension(QuotientDistributive.F)))"))) (FunQuotientDistributive_TCC2 0 (FunQuotientDistributive_TCC2-1 nil 3245193424 ("" (grind :exclude "rep" :if-match nil) (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (inst?) nil nil)) nil) ("2" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("2" (inst?) nil nil)) nil)) nil) ((FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (PreservesEq const-decl "bool" KernelDefinition nil)) shostak (FunQuotientDistributive subtype "QuotientDistributive.FunExtension(QuotientDistributive.F)" "{R: relations[[QuotientDistributive.X -> QuotientDistributive.Y]].equivalence | KernelDefinition[[QuotientDistributive.X -> QuotientDistributive.Y], [QuotientDistributive.X -> QuotientDistributive.Y], booleans.bool].PreservesEq(R)(LAMBDA (x: [QuotientDistributive.X -> QuotientDistributive.Y]): booleans.TRUE)}"))) (FunQuotientDistributive 0 (FunQuotientDistributive-3 "" 3342937949 ("" (skosimp) (("" (lemma "FunExtensionPreservesEq") (("" (expand "bijective?") (("" (inst -1 "F!1") (("" (prop) (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (skosimp*) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "FunExtension" 1) (("1" (expand "lift") (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (skosimp*) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (expand "quotient_map" -2) (("1" (expand "EquivClass" -2) (("1" (decompose-equality) (("1" (inst -1 "x!1(x!4)") (("1" (expand "rep") (("1" (expand "FunExtension") (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "EquivalenceKernel") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (prop) (("1" (decompose-equality) (("1" (inst -1 "x!4") (("1" (decompose-equality) (("1" (typepred "ch1") (("1" (typepred "ch2") (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "x!2(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (assert) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst -1 "x!1(x!4)" "ch1(x!4)") (("1" (assert) (("1" (replace -1) (("1" (hide -1 -4 -5) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("1" (assert) (("1" (hide -3 -4) (("1" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ch1" "ch2") (("2" (hide 1) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (typepred "F!1(x!4)") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst -1 "x!1(x!4)" "ch1(x!4)") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (hide -2) (("2" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("2" (assert) (("2" (hide -3 -4) (("2" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!2") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!1") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :if-match nil) (("2" (expand "EquivClass" 1) (("2" (expand "FunExtension" 1) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (expand "quotient_map") (("2" (expand "EquivClass") (("2" (decompose-equality) (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "FunExtension") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "EquivalenceKernel") (("1" (expand "rep") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (typepred "ch1" "ch2") (("1" (hide -5) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "ch1(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst -1 "ch1(x!4)") (("1" (assert) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst-cp -1 "ch2(x!4)" "ch1(x!4)") (("1" (assert) (("1" (hide -6) (("1" (inst -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!1(x!4)" "ch1(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5 -2) (("1" (inst-cp -2 "x!1(x!4)" "ch2(x!4)" "x!2(x!4)") (("1" (assert) (("1" (hide -4 -1) (("1" (forward-chain -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind :if-match nil) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!2") (("2" (apply-extensionality :hide? t) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!2") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (inst 1 "x!1") (("4" (apply-extensionality :hide? t) (("4" (expand "EquivClass") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (inst 1 "x!1") (("5" (apply-extensionality :hide? t) (("5" (expand "EquivClass") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "surjective?") (("2" (skosimp) (("2" (inst 1 "{ f : [X -> Y] | FORALL (x: X): (y!1(x))(f(x)) }") (("1" (expand "lift") (("1" (apply-extensionality :hide? t) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "rep") (("1" (name-replace "ch" "choose({f: [X -> Y] | FORALL (x: X): y!1(x)(f(x))})") (("1" (typepred "ch") (("1" (typepred "F!1(x!1)") (("1" (inst -2 "x!1") (("1" (typepred "y!1(x!1)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (inst-cp -1 "x!2") (("1" (inst -1 "ch(x!1)") (("1" (replace -4) (("1" (replace -2) (("1" (hide -2 -4) (("1" (iff) (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -2) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (prop) (("1" (inst -4 "x!3" "ch(x!1)" "x!2") (("1" (assert) nil nil)) nil) ("2" (inst -3 "x!3" "ch(x!1)") (("2" (assert) (("2" (hide -2) (("2" (inst -3 "ch(x!1)" "x!3" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :if-match nil) (("2" (inst -1 "LAMBDA (x: X): choose(y!1(x))") (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (replace -1) (("1" (beta) (("1" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (propax) nil nil)) nil) ("2" (inst -1 "x!4") (("2" (hide -1 2) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (expand "EquivClass") (("2" (decompose-equality) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (replace -1 :hide? t) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "EquivClass") (("2" (expand "FunExtension") (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -3 "x!3") (("1" (inst-cp -2 "ch") (("1" (replace -1) (("1" (inst -2 "x!2(x!3)") (("1" (replace -4) (("1" (hide -1 -4) (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -4) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!3") (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1 -2) (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind :if-match nil) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind :if-match nil) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -2 "x!3") (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (inst -2 "x!3") (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1 -2) (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!2))") (("1" (typepred "ch") (("1" (typepred "y!1(x!2)") (("1" (skosimp) (("1" (inst -3 "x!2") (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!2)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!3" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!3" "x!1(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (inst -2 "x!2") (("2" (name-replace "ch" "choose(y!1(x!2))") (("2" (typepred "ch") (("2" (replace -2 :hide? t) (("2" (expand "EquivClass") (("2" (typepred "F!1(x!2)") (("2" (grind :if-match nil) (("2" (hide -1 -2) (("2" (inst -1 "x!3" "ch" "x!1(x!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FunExtensionPreservesEq formula-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (Y formal-type-decl nil QuotientDistributive nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (F!1 skolem-const-decl "[X -> equivalence[Y]]" QuotientDistributive nil) (y!1 skolem-const-decl "[x: X -> Quotient[Y](F!1(x))]" QuotientDistributive nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (lift const-decl "Y" QuotientExtensionProperties nil) (restrict const-decl "R" restrict nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (restrict_full formula-decl nil restrict_props nil) (member const-decl "bool" sets nil) (PreservesEq const-decl "bool" KernelDefinition nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rep const-decl "T" QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil)) shostak) (FunQuotientDistributive-2 "Fix for 3.2" 3307985259 ("" (skosimp) (("" (lemma "FunExtensionPreservesEq") (("" (expand "bijective?") (("" (inst -1 "F!1") (("" (prop) (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (skosimp*) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "FunExtension" 1) (("1" (expand "lift") (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (skosimp*) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (expand "quotient_map" -2) (("1" (expand "EquivClass" -2) (("1" (decompose-equality) (("1" (inst -1 "x!1(x!4)") (("1" (expand "rep") (("1" (expand "FunExtension") (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "EquivalenceKernel") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (prop) (("1" (decompose-equality) (("1" (inst -1 "x!4") (("1" (decompose-equality) (("1" (typepred "ch1") (("1" (typepred "ch2") (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "x!2(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (assert) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst -1 "x!1(x!4)" "ch1(x!4)") (("1" (assert) (("1" (replace -1) (("1" (hide -1 -4 -5) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("1" (assert) (("1" (hide -3 -4) (("1" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "EquivClass") (("2" (inst?) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "EquivClass") (("3" (inst?) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (expand "EquivClass") (("4" (inst?) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "EquivClass") (("5" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "ch1" "ch2") (("2" (hide 1) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (typepred "F!1(x!4)") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst -1 "x!1(x!4)" "ch1(x!4)") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (hide -2) (("2" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("2" (assert) (("2" (hide -3 -4) (("2" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!2") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!1") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :if-match nil) (("2" (expand "EquivClass" 1) (("2" (expand "FunExtension" 1) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (expand "quotient_map") (("2" (expand "EquivClass") (("2" (decompose-equality) (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "FunExtension") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "EquivalenceKernel") (("1" (expand "rep") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (typepred "ch1" "ch2") (("1" (hide -5) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "ch1(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst -1 "ch1(x!4)") (("1" (assert) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst-cp -1 "ch2(x!4)" "ch1(x!4)") (("1" (assert) (("1" (hide -6) (("1" (inst -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!1(x!4)" "ch1(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5 -2) (("1" (inst-cp -2 "x!1(x!4)" "ch2(x!4)" "x!2(x!4)") (("1" (assert) (("1" (hide -4 -1) (("1" (forward-chain -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind :if-match nil) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!2") (("2" (apply-extensionality :hide? t) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!2") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (inst 1 "x!1") (("4" (apply-extensionality :hide? t) (("4" (expand "EquivClass") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (inst 1 "x!1") (("5" (apply-extensionality :hide? t) (("5" (expand "EquivClass") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "surjective?") (("2" (skosimp) (("2" (inst 1 "{ f : [X -> Y] | FORALL (x: X): (y!1(x))(f(x)) }") (("1" (expand "lift") (("1" (apply-extensionality :hide? t) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "rep") (("1" (name-replace "ch" "choose({f: [X -> Y] | FORALL (x: X): y!1(x)(f(x))})") (("1" (typepred "ch") (("1" (typepred "F!1(x!1)") (("1" (inst -2 "x!1") (("1" (typepred "y!1(x!1)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (inst-cp -1 "x!2") (("1" (inst -1 "ch(x!1)") (("1" (replace -4) (("1" (replace -2) (("1" (hide -2 -4) (("1" (iff) (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -2) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (prop) (("1" (inst -4 "x!3" "ch(x!1)" "x!2") (("1" (assert) nil nil)) nil) ("2" (inst -3 "x!3" "ch(x!1)") (("2" (assert) (("2" (hide -2) (("2" (inst -3 "ch(x!1)" "x!3" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :if-match nil) (("2" (inst -1 "LAMBDA (x: X): choose(y!1(x))") (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (replace -1) (("1" (beta) (("1" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (propax) nil nil)) nil) ("2" (inst -1 "x!4") (("2" (hide -1 2) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (expand "EquivClass") (("2" (decompose-equality) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (replace -1 :hide? t) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "EquivClass") (("2" (expand "FunExtension") (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -3 "x!3") (("1" (inst-cp -2 "ch") (("1" (replace -1) (("1" (inst -2 "x!2(x!3)") (("1" (replace -4) (("1" (hide -1 -4) (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -4) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!3") (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1 -2) (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -2 "x!3") (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (inst -2 "x!3") (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1 -2) (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!2))") (("1" (typepred "ch") (("1" (typepred "y!1(x!2)") (("1" (skosimp) (("1" (inst -3 "x!2") (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!2)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!3" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!3" "x!1(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (inst -2 "x!2") (("2" (name-replace "ch" "choose(y!1(x!2))") (("2" (typepred "ch") (("2" (replace -2 :hide? t) (("2" (expand "EquivClass") (("2" (typepred "F!1(x!2)") (("2" (grind :if-match nil) (("2" (hide -1 -2) (("2" (inst -1 "x!3" "ch" "x!1(x!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (Quotient type-eq-decl nil QuotientDefinition nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rep const-decl "T" QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (PreservesEq const-decl "bool" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict_full formula-decl nil restrict_props nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (symmetric_restrict application-judgement "(symmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (equivalence_restrict application-judgement "(equivalence?[S])" restrict_order_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (restrict const-decl "R" restrict nil) (lift const-decl "Y" QuotientExtensionProperties nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (FunExtensionPreservesEq formula-decl nil QuotientDistributive nil)) shostak) (FunQuotientDistributive-1 nil 3245195217 ("" (skosimp) (("" (lemma "FunExtensionPreservesEq") (("" (expand "bijective?") (("" (inst -1 "F!1") (("" (prop) (("1" (expand "injective?") (("1" (skolem-typepred) (("1" (skosimp*) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "FunExtension" 1) (("1" (expand "lift") (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (skosimp*) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (expand "quotient_map" -2) (("1" (expand "EquivClass" -2) (("1" (decompose-equality) (("1" (inst -1 "x!1(x!4)") (("1" (expand "rep") (("1" (expand "FunExtension") (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "EquivalenceKernel") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (prop) (("1" (decompose-equality) (("1" (inst -1 "x!4") (("1" (decompose-equality) (("1" (typepred "ch1") (("1" (typepred "ch2") (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "x!2(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (assert) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst -1 "x!1(x!4)" "ch1(x!4)") (("1" (assert) (("1" (replace -1) (("1" (hide -1 -4 -5) (("1" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("1" (assert) (("1" (hide -3 -4) (("1" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ch1" "ch2") (("2" (hide 1) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (typepred "F!1(x!4)") (("2" (expand "equivalence?") (("2" (flatten) (("2" (hide -1) (("2" (expand "symmetric?") (("2" (expand "transitive?") (("2" (inst -1 "x!1(x!4)" "ch1(x!4)") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (hide -2) (("2" (inst-cp -1 "x!2(x!4)" "ch2(x!4)" "x!1(x!4)") (("2" (assert) (("2" (hide -3 -4) (("2" (inst -1 "x!2(x!4)" "x!1(x!4)" "x!3(x!4)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!2") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "x!1") (("2" (expand "member") (("2" (skosimp) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :if-match nil) (("2" (expand "EquivClass" 1) (("2" (expand "FunExtension" 1) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (expand "quotient_map") (("2" (expand "EquivClass") (("2" (decompose-equality) (("1" (expand "PreservesEq") (("1" (expand "subset?") (("1" (expand "member") (("1" (expand "FunExtension") (("1" (rewrite "restrict_full[[[X -> Y], [X -> Y]], bool]") (("1" (expand "EquivalenceKernel") (("1" (expand "rep") (("1" (name-replace "ch1" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!1(x), z(x))})") (("1" (name-replace "ch2" "choose({z: [X -> Y] | FORALL (x: X): F!1(x)(x!2(x), z(x))})") (("1" (inst -3 "(ch1, ch2)") (("1" (typepred "ch1" "ch2") (("1" (hide -5) (("1" (inst -1 "x!4") (("1" (inst -2 "x!4") (("1" (inst -3 "ch1(x!4)") (("1" (typepred "F!1(x!4)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "reflexive?") (("1" (inst -1 "ch1(x!4)") (("1" (assert) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst-cp -1 "ch2(x!4)" "ch1(x!4)") (("1" (assert) (("1" (hide -6) (("1" (inst -1 "x!2(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5) (("1" (inst-cp -3 "x!1(x!4)" "ch1(x!4)" "ch2(x!4)") (("1" (assert) (("1" (hide -5 -2) (("1" (inst-cp -2 "x!1(x!4)" "ch2(x!4)" "x!2(x!4)") (("1" (assert) (("1" (hide -4 -1) (("1" (forward-chain -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind) (("2" (typepred "F!1(x!5)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (grind :if-match nil) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!1") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!2") (("2" (apply-extensionality :hide? t) (("2" (expand "FunExtension") (("2" (expand "EquivClass") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "x!2") (("3" (apply-extensionality :hide? t) (("3" (expand "FunExtension") (("3" (expand "EquivClass") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (inst 1 "x!1") (("4" (apply-extensionality :hide? t) (("4" (expand "EquivClass") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (inst 1 "x!1") (("5" (apply-extensionality :hide? t) (("5" (expand "EquivClass") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "surjective?") (("2" (skosimp) (("2" (inst 1 "{ f : [X -> Y] | FORALL (x: X): (y!1(x))(f(x)) }") (("1" (expand "lift") (("1" (apply-extensionality :hide? t) (("1" (expand "quotient_map") (("1" (expand "EquivClass") (("1" (apply-extensionality :hide? t) (("1" (expand "rep") (("1" (name-replace "ch" "choose({f: [X -> Y] | FORALL (x: X): y!1(x)(f(x))})") (("1" (typepred "ch") (("1" (typepred "F!1(x!1)") (("1" (inst -2 "x!1") (("1" (typepred "y!1(x!1)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (inst-cp -1 "x!2") (("1" (inst -1 "ch(x!1)") (("1" (replace -4) (("1" (replace -2) (("1" (hide -2 -4) (("1" (iff) (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -2) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (prop) (("1" (inst -4 "x!3" "ch(x!1)" "x!2") (("1" (assert) nil nil)) nil) ("2" (inst -3 "x!3" "ch(x!1)") (("2" (assert) (("2" (hide -2) (("2" (inst -3 "ch(x!1)" "x!3" "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :if-match nil) (("2" (inst -1 "LAMBDA (x: X): choose(y!1(x))") (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (replace -1) (("1" (beta) (("1" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (propax) nil nil)) nil) ("2" (inst -1 "x!4") (("2" (hide -1 2) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (expand "EquivClass") (("2" (decompose-equality) (("2" (inst -1 "x!4") (("2" (inst -2 "x!4") (("2" (replace -1 :hide? t) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "EquivClass") (("2" (expand "FunExtension") (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (expand "EquivClass") (("1" (decompose-equality) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -3 "x!3") (("1" (inst-cp -2 "ch") (("1" (replace -1) (("1" (inst -2 "x!2(x!3)") (("1" (replace -4) (("1" (hide -1 -4) (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1) (("1" (expand "symmetric?") (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -4) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (expand "EquivClass") (("2" (decompose-equality) (("2" (inst -1 "x!5") (("2" (inst -2 "x!5") (("2" (replace 1) (("2" (assert) (("2" (hide 2) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "x!3") (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (expand "equivalence?") (("1" (flatten) (("1" (hide -1 -2) (("1" (expand "transitive?") (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!3))") (("1" (typepred "ch") (("1" (inst -2 "x!3") (("1" (typepred "y!1(x!3)") (("1" (skosimp) (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!4" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!4" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!4") (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!3)") (("2" (skosimp) (("2" (inst -2 "x!3") (("2" (replace -1 :hide? t) (("2" (expand "EquivClass") (("2" (name-replace "ch" "choose({z: Y | F!1(x!3)(x!4, z)})") (("1" (typepred "ch") (("1" (typepred "F!1(x!3)") (("1" (grind :if-match nil) (("1" (hide -1 -2) (("1" (inst -1 "x!4" "ch" "x!2(x!3)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "F!1(x!3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x: X): choose(y!1(x))") (("1" (expand "EquivClass") (("1" (expand "FunExtension") (("1" (apply-extensionality :hide? t) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (name-replace "ch" "choose(y!1(x!2))") (("1" (typepred "ch") (("1" (typepred "y!1(x!2)") (("1" (skosimp) (("1" (inst -3 "x!2") (("1" (replace -1 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!2)") (("1" (grind :if-match nil) (("1" (hide -1) (("1" (inst -1 "x!3" "ch") (("1" (assert) (("1" (hide -3) (("1" (inst -2 "ch" "x!3" "x!1(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!3") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (inst -2 "x!2") (("2" (name-replace "ch" "choose(y!1(x!2))") (("1" (typepred "ch") (("1" (replace -2 :hide? t) (("1" (expand "EquivClass") (("1" (typepred "F!1(x!2)") (("1" (grind :if-match nil) (("1" (hide -1 -2) (("1" (inst -1 "x!3" "ch" "x!1(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) (("2" (typepred "y!1(x!2)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!4") (("2" (grind) (("2" (typepred "F!1(x!2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (grind) (("2" (typepred "y!1(x!1)") (("2" (skosimp) (("2" (replace -1 :hide? t) (("2" (inst -1 "x!2") (("2" (grind) (("2" (typepred "F!1(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (FunExtension const-decl "equivalence[[X -> Y]]" QuotientDistributive nil) (Quotient type-eq-decl nil QuotientDefinition nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rep const-decl "T" QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (PreservesEq const-decl "bool" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict_full formula-decl nil restrict_props nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (lift const-decl "Y" QuotientExtensionProperties nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Y formal-type-decl nil QuotientDistributive nil) (X formal-type-decl nil QuotientDistributive nil) (FunExtensionPreservesEq formula-decl nil QuotientDistributive nil)) shostak)))(QuotientIteration (action_TCC1 0 (action_TCC1-1 nil 3243015883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientIteration nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (x!1 skolem-const-decl "X" QuotientIteration nil) (S!1 skolem-const-decl "equivalence[X]" QuotientIteration nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) nil (action subtype "QuotientDefinition[QuotientIteration.X].EquivClass(QuotientIteration.S)(QuotientIteration.x)" "QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S)"))) (action_TCC2 0 (action_TCC2-1 nil 3243015883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientIteration nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (y!1 skolem-const-decl "X" QuotientIteration nil) (S!1 skolem-const-decl "equivalence[X]" QuotientIteration nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) nil (action subtype "QuotientDefinition[QuotientIteration.X].EquivClass(QuotientIteration.S)(QuotientIteration.y)" "QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S)"))) (action_equivalence_is_equivalence 0 (action_equivalence_is_equivalence-1 nil 3243663397 ("" (skosimp*) (("" (typepred "S!1" "R!1") (("" (expand "equivalence?") (("" (flatten) (("" (expand "reflexive?") (("" (expand "symmetric?") (("" (expand "transitive?") (("" (expand "action") (("" (prop) (("1" (skosimp*) (("1" (inst? -4) (("1" (inst 1 "x!1") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -6 "EquivClass(S!1)(x!1)" "EquivClass(S!1)(y!1)") (("1" (assert) nil nil) ("2" (inst 1 "y!1") nil nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst -8 "EquivClass(S!1)(x!1)" "EquivClass(S!1)(y!1)" "EquivClass(S!1)(z!1)") (("1" (assert) nil nil) ("2" (inst 1 "z!1") nil nil) ("3" (inst 1 "y!1") nil nil) ("4" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Quotient type-eq-decl nil QuotientDefinition nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (X formal-type-decl nil QuotientIteration nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (symmetric? const-decl "bool" relations nil) (action const-decl "bool" QuotientIteration nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) shostak (action_equivalence_is_equivalence subtype "QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R)" "equivalence[X]"))) (QuotientAction_TCC1 0 (QuotientAction_TCC1-1 nil 3243015883 ("" (grind :exclude "rep" :if-match nil) (("" (apply-extensionality :hide? t) (("" (lemma "PreservesEq_quotient_map[X, X]") (("" (inst?) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (expand "member") (("" (rewrite "restrict_full[[X, X], bool]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((action const-decl "bool" QuotientIteration nil) (restrict_full formula-decl nil restrict_props nil) (PreservesEq_quotient_map formula-decl nil QuotientKernelProperties nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (X formal-type-decl nil QuotientIteration nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (Quotient type-eq-decl nil QuotientDefinition nil) (action_equivalence_is_equivalence application-judgement "equivalence[X]" QuotientIteration nil) (PreservesEq const-decl "bool" KernelDefinition nil) (subset? const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil)) nil (QuotientAction subtype "QuotientDefinition[QuotientIteration.X].quotient_map(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))" "(KernelDefinition[QuotientIteration.X, QuotientIteration.X, QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))].PreservesEq(QuotientIteration.S))"))) (QuotientAction_TCC2 0 (QuotientAction_TCC2-1 nil 3243015883 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (expand "member") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (rewrite "restrict_full[[Quotient[X](S!1), Quotient[X](S!1)], bool]") (("" (rewrite "restrict_full[[X, X], bool]") (("" (prop) (("1" (skosimp*) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (typepred "x!1`1" "x!1`2") (("2" (expand "lift") (("2" (lemma "EquivClassEq[X]") (("2" (auto-rewrite "EquivClassNonEmpty[X]") (("2" (skosimp*) (("2" (replace -2) (("2" (replace -3) (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "action") (("1" (rewrite "restrict_full[[X, X], bool]") (("1" (case "FORALL(x : X) :
                   EquivClass(S!1)(choose(EquivClass[X](S!1)(x))) = EquivClass(S!1)(x)") (("1" (inst-cp -1 "x!2") (("1" (expand "rep") (("1" (replace -2) (("1" (inst -1 "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (skosimp*) (("2" (lemma "EquivClassEq[X]") (("2" (inst?) (("2" (assert) (("2" (use "EquivClassChoose[X]") (("2" (hide 2) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (expand "symmetric?") (("2" (flatten) (("2" (expand "repEC") (("2" (forward-chain -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "restrict_full[[X, X], bool]") (("2" (inst 1 "x!3") nil nil)) nil) ("3" (rewrite "restrict_full[[X, X], bool]") (("3" (assert) nil nil)) nil) ("4" (rewrite "restrict_full[[X, X], bool]") (("4" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil)) nil (QuotientAction subtype "QuotientIteration.S" "{R: relations[QuotientIteration.X].equivalence | KernelDefinition[QuotientIteration.X, QuotientIteration.X, booleans.bool].PreservesEq(R)(LAMBDA (x: QuotientIteration.X): booleans.TRUE)}"))) (QuotientAction_TCC3 0 (QuotientAction_TCC3-2 "Fix for 3.2" 3307986379 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (expand "member") (("" (skosimp*) (("" (rewrite "restrict_full[[Quotient[X](S!1), Quotient[X](S!1)], bool]") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (typepred "x!1`1" "x!1`2") (("" (expand "lift") (("" (lemma "EquivClassEq[X]") (("" (auto-rewrite "EquivClassNonEmpty[X]") (("" (skosimp*) (("" (replace -2) (("" (replace -3) (("" (inst?) (("" (assert) (("" (hide 2) (("" (expand "action") (("" (case "FORALL(x : X) :
                            EquivClass(S!1)(choose(EquivClass[X](S!1)(x))) = EquivClass(S!1)(x)") (("1" (inst-cp -1 "x!2") (("1" (expand "rep") (("1" (replace -2) (("1" (inst -1 "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (skosimp*) (("2" (lemma "EquivClassEq[X]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (use "rep_lemma[X]") (("2" (expand "EquivClass") (("2" (expand "rep") (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (flatten) (("2" (expand "symmetric?") (("2" (forward-chain -2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "x!4") (("2" (expand "reflexive?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict_full formula-decl nil restrict_props nil) (X formal-type-decl nil QuotientIteration nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (Quotient type-eq-decl nil QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (lift const-decl "Y" QuotientExtensionProperties nil) (action_equivalence_is_equivalence application-judgement "equivalence[X]" QuotientIteration nil) (rep const-decl "T" QuotientDefinition nil) (action const-decl "bool" QuotientIteration nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (x!4 skolem-const-decl "X" QuotientIteration nil) (S!1 skolem-const-decl "equivalence[X]" QuotientIteration nil) (empty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (rep_lemma formula-decl nil QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil)) shostak (QuotientAction subtype "QuotientExtensionProperties[QuotientIteration.X, QuotientIteration.X, QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))].lift(QuotientIteration.S)(QuotientDefinition[QuotientIteration.X].quotient_map(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R)))" "(KernelDefinition[QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))].PreservesEq(QuotientIteration.R))")) (QuotientAction_TCC3-1 nil 3245193427 ("" (skosimp*) (("" (expand "PreservesEq") (("" (expand "subset?") (("" (expand "member") (("" (skosimp*) (("" (rewrite "restrict_full[[Quotient[X](S!1), Quotient[X](S!1)], bool]") (("" (expand "EquivalenceKernel") (("" (expand "quotient_map") (("" (typepred "x!1`1" "x!1`2") (("" (expand "lift") (("" (lemma "EquivClassEq[X]") (("" (auto-rewrite "EquivClassNonEmpty[X]") (("" (skosimp*) (("" (replace -2) (("" (replace -3) (("" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "action") (("1" (case "FORALL(x : X) :
                   EquivClass(S!1)(choose(EquivClass[X](S!1)(x))) = EquivClass(S!1)(x)") (("1" (inst-cp -1 "x!2") (("1" (expand "rep") (("1" (replace -2) (("1" (inst -1 "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (skosimp*) (("2" (lemma "EquivClassEq[X]") (("2" (inst?) (("2" (assert) (("2" (use "EquivClassChoose[X]") (("2" (hide 2) (("2" (typepred "S!1") (("2" (expand "equivalence?") (("2" (expand "symmetric?") (("2" (flatten) (("2" (inst -2 "x!4" "choose(EquivClass[X](S!1)(x!4))") (("2" (assert) (("2" (expand "repEC") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PreservesEq const-decl "bool" KernelDefinition nil) (member const-decl "bool" sets nil) (restrict_full formula-decl nil restrict_props nil) (X formal-type-decl nil QuotientIteration nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (PRED type-eq-decl nil defined_types nil) (equivalence? const-decl "bool" relations nil) (equivalence type-eq-decl nil relations nil) (Quotient type-eq-decl nil QuotientDefinition nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (lift const-decl "Y" QuotientExtensionProperties nil) (rep const-decl "T" QuotientDefinition nil) (action const-decl "bool" QuotientIteration nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (empty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (rep_lemma formula-decl nil QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (NOT const-decl "[bool -> bool]" booleans nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil)) shostak (QuotientAction subtype "QuotientExtensionProperties[QuotientIteration.X, QuotientIteration.X, QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))].lift(QuotientIteration.S)(QuotientDefinition[QuotientIteration.X].quotient_map(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R)))" "(KernelDefinition[QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.action(QuotientIteration.S)(QuotientIteration.R))].PreservesEq(QuotientIteration.R))"))) (QuotientAction_TCC4 0 (QuotientAction_TCC4-1 nil 3245525352 ("" (grind :exclude "rep" :if-match nil) nil nil) ((restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (EquivalenceKernel const-decl "equivalence[X1]" KernelDefinition nil) (subset? const-decl "bool" sets nil) (PreservesEq const-decl "bool" KernelDefinition nil)) shostak (QuotientAction subtype "QuotientIteration.R" "{R: relations[QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S)].equivalence | KernelDefinition[QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S), booleans.bool].PreservesEq(R)(LAMBDA (x: QuotientDefinition[QuotientIteration.X].Quotient(QuotientIteration.S)): booleans.TRUE)}"))) (QuotientAction 0 (QuotientAction-3 "" 3658951612 ("" (skosimp*) (("" (typepred "S!1" "R!1") (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (typepred "x1!1" "x2!1") (("1" (auto-rewrite-theories "QuotientDefinition[X]" "QuotientDefinition[Quotient[X](S!1)]") (("1" (skosimp*) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!1))") (("1" (name-replace "ch2" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!2))") (("1" (typepred "ch1" "ch2") (("1" (skosimp*) (("1" (replace -1) (("1" (replace -3) (("1" (hide -1 -3) (("1" (name-replace "ch3" "choose(EquivClass[X](S!1)(x!3))") (("1" (name-replace "ch4" "choose(EquivClass[X](S!1)(x!4))") (("1" (typepred "ch3" "ch4") (("1" (stop-rewrite "EquivClassEq[X]") (("1" (assert) (("1" (case "EquivClass[X](action(S!1)(R!1))(ch3)(ch3)") (("1" (replace -6) (("1" (hide -6) (("1" (assert) (("1" (expand "action") (("1" (lemma "EquivClassEq[X]") (("1" (inst?) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "S!1" "ch4" "x!4") (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (hide -2 -3) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst-cp -8 "EquivClass[X](S!1)(x!4)" "EquivClass(S!1)(ch3)") (("1" (prop) (("1" (hide -2) (("1" (inst -8 "x!2" "EquivClass[X](S!1)(x!4)") (("1" (expand "transitive?") (("1" (inst-cp -9 "x!1" "EquivClass(S!1)(ch3)" "EquivClass[X](S!1)(x!4)") (("1" (assert) (("1" (inst-cp -9 "x!1" "EquivClass[X](S!1)(x!4)" "x!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "equivalence?") (("2" (expand "symmetric?") (("2" (flatten) (("2" (inst -7 "x!4" "ch4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 2) (("2" (expand "EquivClass") (("2" (expand "action") (("2" (expand "equivalence?") (("2" (expand "reflexive?") (("2" (flatten) (("2" (inst -4 "EquivClass(S!1)(ch3)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1") (("2" (skosimp*) (("2" (inst 1 "EquivClass(R!1)(EquivClass(S!1)(x!1))") (("1" (expand "lift") (("1" (expand "quotient_map") (("1" (replace -1) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "action(S!1)(R!1)" "_" "_") (("1" (case "nonempty?(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (typepred "ch1") (("1" (skosimp*) (("1" (case "nonempty?(ch1)") (("1" (name-replace "ch2" "choose(ch1)") (("1" (typepred "ch2") (("1" (inst -6 "ch2" "x!1") (("1" (assert) (("1" (hide 2) (("1" (expand "action" 1) (("1" (expand "EquivClass" -3) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst -11 "LAMBDA (z: X): S!1(x!1, z)" "ch1") (("1" (assert) (("1" (case-replace "EquivClass(S!1)(ch2) = ch1") (("1" (expand "EquivClass" 1) (("1" (replace 1) (("1" (expand "EquivClass" -5) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -3) (("2" (assert) (("2" (lemma "EquivClassEq[X]") (("2" (inst -1 "S!1" "x!2" "ch2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "EquivClass[X](S!1)(x!1)") (("2" (inst 1 "x!1") nil nil)) nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Quotient type-eq-decl nil QuotientDefinition nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (X formal-type-decl nil QuotientIteration nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rep const-decl "T" QuotientDefinition nil) (action_equivalence_is_equivalence application-judgement "equivalence[X]" QuotientIteration nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (action const-decl "bool" QuotientIteration nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (lift const-decl "Y" QuotientExtensionProperties nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (R!1 skolem-const-decl "equivalence[Quotient[X](S!1)]" QuotientIteration nil) (x!1 skolem-const-decl "X" QuotientIteration nil) (S!1 skolem-const-decl "equivalence[X]" QuotientIteration nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) shostak) (QuotientAction-2 "" 3590873023 ("" (skosimp*) (("" (typepred "S!1" "R!1") (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (typepred "x1!1" "x2!1") (("1" (auto-rewrite-theories "QuotientDefinition[X]" "QuotientDefinition[Quotient[X](S!1)]") (("1" (skosimp*) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!1))") (("1" (name-replace "ch2" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!2))") (("1" (typepred "ch1" "ch2") (("1" (skosimp*) (("1" (replace -2) (("1" (replace -4) (("1" (hide -2 -4) (("1" (name-replace "ch3" "choose(EquivClass[X](S!1)(x!3))") (("1" (name-replace "ch4" "choose(EquivClass[X](S!1)(x!4))") (("1" (typepred "ch3" "ch4") (("1" (stop-rewrite "EquivClassEq[X]") (("1" (assert) (("1" (case "EquivClass[X](action(S!1)(R!1))(ch3)(ch3)") (("1" (replace -6) (("1" (hide -6) (("1" (assert) (("1" (expand "action") (("1" (lemma "EquivClassEq[X]") (("1" (inst?) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "S!1" "ch4" "x!4") (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (hide -2 -3) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst-cp -8 "EquivClass[X](S!1)(x!4)" "EquivClass(S!1)(ch3)") (("1" (prop) (("1" (hide -2) (("1" (inst -8 "x!2" "EquivClass[X](S!1)(x!4)") (("1" (expand "transitive?") (("1" (inst-cp -9 "x!1" "EquivClass(S!1)(ch3)" "EquivClass[X](S!1)(x!4)") (("1" (assert) (("1" (inst-cp -9 "x!1" "EquivClass[X](S!1)(x!4)" "x!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "equivalence?") (("2" (expand "symmetric?") (("2" (flatten) (("2" (inst -7 "x!4" "ch4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 2) (("2" (expand "EquivClass") (("2" (expand "action") (("2" (expand "equivalence?") (("2" (expand "reflexive?") (("2" (flatten) (("2" (inst -4 "EquivClass(S!1)(ch3)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1") (("2" (skosimp*) (("2" (inst 1 "EquivClass(R!1)(EquivClass(S!1)(x!1))") (("1" (expand "lift") (("1" (expand "quotient_map") (("1" (replace -1) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "action(S!1)(R!1)" "_" "_") (("1" (case "nonempty?(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (typepred "ch1") (("1" (skosimp*) (("1" (case "nonempty?(ch1)") (("1" (name-replace "ch2" "choose(ch1)") (("1" (typepred "ch2") (("1" (inst -6 "ch2" "x!1") (("1" (assert) (("1" (hide 2) (("1" (expand "action" 1) (("1" (expand "EquivClass" -3) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst -11 "LAMBDA (z: X): S!1(x!1, z)" "ch1") (("1" (assert) (("1" (case-replace "EquivClass(S!1)(ch2) = ch1") (("1" (expand "EquivClass" 1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5 -6 -10 -11 -12) (("2" (replace -2) (("2" (hide -2) (("2" (assert) (("2" (expand "EquivClass" -1) (("2" (lemma "EquivClassEq[X]") (("2" (inst -1 "S!1" "x!2" "ch2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "EquivClass[X](S!1)(x!1)") (("2" (inst 1 "x!1") nil nil)) nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Quotient type-eq-decl nil QuotientDefinition nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (X formal-type-decl nil QuotientIteration nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rep const-decl "T" QuotientDefinition nil) (action_equivalence_is_equivalence application-judgement "equivalence[X]" QuotientIteration nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (action const-decl "bool" QuotientIteration nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (lift const-decl "Y" QuotientExtensionProperties nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) shostak) (QuotientAction-1 nil 3243015883 ("" (skosimp*) (("" (typepred "S!1" "R!1") (("" (expand "bijective?") (("" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (expand "lift") (("1" (typepred "x1!1" "x2!1") (("1" (auto-rewrite-theories "QuotientDefinition[X]" "QuotientDefinition[Quotient[X](S!1)]") (("1" (skosimp*) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!1))") (("1" (name-replace "ch2" "choose(EquivClass[Quotient[X](S!1)](R!1)(x!2))") (("1" (typepred "ch1" "ch2") (("1" (skosimp*) (("1" (replace -1) (("1" (replace -3) (("1" (hide -1 -3) (("1" (name-replace "ch3" "choose(EquivClass[X](S!1)(x!3))") (("1" (name-replace "ch4" "choose(EquivClass[X](S!1)(x!4))") (("1" (typepred "ch3" "ch4") (("1" (stop-rewrite "EquivClassEq[X]") (("1" (assert) (("1" (case "EquivClass[X](action(S!1)(R!1))(ch3)(ch3)") (("1" (replace -6) (("1" (hide -6) (("1" (assert) (("1" (expand "action") (("1" (lemma "EquivClassEq[X]") (("1" (inst?) (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "S!1" "ch4" "x!4") (("1" (prop) (("1" (replace -1) (("1" (hide -1 -2) (("1" (hide -2 -3) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst-cp -8 "EquivClass[X](S!1)(x!4)" "EquivClass(S!1)(ch3)") (("1" (prop) (("1" (hide -2) (("1" (inst -8 "x!2" "EquivClass[X](S!1)(x!4)") (("1" (expand "transitive?") (("1" (inst-cp -9 "x!1" "EquivClass(S!1)(ch3)" "EquivClass[X](S!1)(x!4)") (("1" (assert) (("1" (inst-cp -9 "x!1" "EquivClass[X](S!1)(x!4)" "x!2") (("1" (assert) nil nil) ("2" (expand "reflexive?") (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil) ("2" (expand "reflexive?") (("2" (inst 1 "x!4") nil nil)) nil) ("3" (expand "reflexive?") (("3" (inst 1 "ch3") nil nil)) nil)) nil)) nil) ("2" (expand "reflexive?") (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "reflexive?") (("2" (inst 1 "ch3") nil nil)) nil) ("3" (expand "reflexive?") (("3" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "equivalence?") (("2" (expand "symmetric?") (("2" (flatten) (("2" (inst -7 "x!4" "ch4") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 2) (("2" (expand "EquivClass") (("2" (expand "action") (("2" (expand "equivalence?") (("2" (expand "reflexive?") (("2" (flatten) (("2" (inst -4 "EquivClass(S!1)(ch3)") (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp*) (("2" (typepred "y!1") (("2" (skosimp*) (("2" (inst 1 "EquivClass(R!1)(EquivClass(S!1)(x!1))") (("1" (expand "lift") (("1" (expand "quotient_map") (("1" (replace -1) (("1" (lemma "EquivClassEq[X]") (("1" (inst -1 "action(S!1)(R!1)" "_" "_") (("1" (case "nonempty?(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (expand "rep") (("1" (name-replace "ch1" "choose(EquivClass(R!1)(EquivClass(S!1)(x!1)))") (("1" (typepred "ch1") (("1" (skosimp*) (("1" (case "nonempty?(ch1)") (("1" (name-replace "ch2" "choose(ch1)") (("1" (typepred "ch2") (("1" (inst -6 "ch2" "x!1") (("1" (assert) (("1" (hide 2) (("1" (expand "action" 1) (("1" (expand "EquivClass" -4) (("1" (expand "equivalence?") (("1" (flatten) (("1" (expand "symmetric?") (("1" (inst -11 "LAMBDA (z: X): S!1(x!1, z)" "ch1") (("1" (assert) (("1" (case-replace "EquivClass(S!1)(ch2) = ch1") (("1" (expand "EquivClass" 1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (hide -2 -4 -5 -6 -10 -11 -12) (("2" (replace -2) (("2" (hide -2) (("2" (assert) (("2" (expand "EquivClass" -1) (("2" (lemma "EquivClassEq[X]") (("2" (inst -1 "S!1" "x!2" "ch2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x!1") (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1 -2 -3 -4 -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "EquivClass[X](S!1)(x!1)") (("2" (inst 1 "x!1") nil nil)) nil) ("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Quotient type-eq-decl nil QuotientDefinition nil) (EquivClass const-decl "set[T]" QuotientDefinition nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (equivalence type-eq-decl nil relations nil) (equivalence? const-decl "bool" relations nil) (PRED type-eq-decl nil defined_types nil) (X formal-type-decl nil QuotientIteration nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rep const-decl "T" QuotientDefinition nil) (action_equivalence_is_equivalence application-judgement "equivalence[X]" QuotientIteration nil) (quotient_map const-decl "Quotient(S)" QuotientDefinition nil) (EquivClassEq formula-decl nil QuotientDefinition nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (action const-decl "bool" QuotientIteration nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (lift const-decl "Y" QuotientExtensionProperties nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) nil)))(PartialFunctionDefinitions (LPartFun_to_SPartFun_TCC1 0 (LPartFun_to_SPartFun_TCC1-1 nil 3243663400 ("" (subtype-tcc) nil nil) nil shostak (LPartFun_to_SPartFun subtype "PartialFunctionDefinitions.f(PartialFunctionDefinitions.y)" "(lift_adt[PartialFunctionDefinitions.Y].up?)"))) (SPartFun_to_LPartFun_to_SPartFun 0 (SPartFun_to_LPartFun_to_SPartFun-1 nil 3243715985 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((X formal-type-decl nil PartialFunctionDefinitions nil) (PRED type-eq-decl nil defined_types nil) (Y formal-type-decl nil PartialFunctionDefinitions nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (SPartFun_to_LPartFun const-decl "LiftPartialFunction" PartialFunctionDefinitions nil) (LPartFun_to_SPartFun const-decl "SubsetPartialFunction" PartialFunctionDefinitions nil) (LiftPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (lift type-decl nil lift_adt nil) (boolean nonempty-type-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil)) shostak)) (LPartFun_to_SPartFun_to_LPartFun 0 (LPartFun_to_SPartFun_to_LPartFun-1 nil 3243716027 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (grind) (("" (rewrite "lift_up_eta") nil nil)) nil)) nil)) nil) ((X formal-type-decl nil PartialFunctionDefinitions nil) (Y formal-type-decl nil PartialFunctionDefinitions nil) (lift type-decl nil lift_adt nil) (LPartFun_to_SPartFun const-decl "SubsetPartialFunction" PartialFunctionDefinitions nil) (SPartFun_to_LPartFun const-decl "LiftPartialFunction" PartialFunctionDefinitions nil) (LiftPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (PRED type-eq-decl nil defined_types nil) (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil) (boolean nonempty-type-decl nil booleans nil) (lift_up_eta formula-decl nil lift_adt nil)) shostak)))(PartialFunctionComposition (oh_TCC1 0 (oh_TCC1-1 nil 3243015884 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Y formal-type-decl nil PartialFunctionComposition nil) (PRED type-eq-decl nil defined_types nil) (Z formal-type-decl nil PartialFunctionComposition nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (X formal-type-decl nil PartialFunctionComposition nil) (CompDom const-decl "PRED[X]" PartialFunctionComposition nil)) nil (oh subtype "PartialFunctionComposition.x" "(PartialFunctionComposition.h`dom)"))) (oh_TCC2 0 (oh_TCC2-1 nil 3243015884 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Y formal-type-decl nil PartialFunctionComposition nil) (PRED type-eq-decl nil defined_types nil) (Z formal-type-decl nil PartialFunctionComposition nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (X formal-type-decl nil PartialFunctionComposition nil) (CompDom const-decl "PRED[X]" PartialFunctionComposition nil)) nil (oh subtype "fun(PartialFunctionComposition.h)(PartialFunctionComposition.x)" "(PartialFunctionComposition.k`dom)"))) (SPartFun_to_LPartFun_CompositionPreservation 0 (SPartFun_to_LPartFun_CompositionPreservation-1 nil 3243716138 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) ((X formal-type-decl nil PartialFunctionComposition nil) (Z formal-type-decl nil PartialFunctionComposition nil) (lift type-decl nil lift_adt nil) (O const-decl "LiftPartialFunction[X, Z]" PartialFunctionComposition nil) (O const-decl "SubsetPartialFunction[X, Z]" PartialFunctionComposition nil) (Y formal-type-decl nil PartialFunctionComposition nil) (SPartFun_to_LPartFun const-decl "LiftPartialFunction" PartialFunctionDefinitions nil) (LiftPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (PRED type-eq-decl nil defined_types nil) (CompDom const-decl "PRED[X]" PartialFunctionComposition nil)) shostak)) (LPartFun_to_SPartFun_CompositionPreservation 0 (LPartFun_to_SPartFun_CompositionPreservation-1 nil 3243716183 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (grind) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((X formal-type-decl nil PartialFunctionComposition nil) (PRED type-eq-decl nil defined_types nil) (Z formal-type-decl nil PartialFunctionComposition nil) (SubsetPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (O const-decl "SubsetPartialFunction[X, Z]" PartialFunctionComposition nil) (O const-decl "LiftPartialFunction[X, Z]" PartialFunctionComposition nil) (Y formal-type-decl nil PartialFunctionComposition nil) (LPartFun_to_SPartFun const-decl "SubsetPartialFunction" PartialFunctionDefinitions nil) (LiftPartialFunction type-eq-decl nil PartialFunctionDefinitions nil) (lift type-decl nil lift_adt nil) (CompDom const-decl "PRED[X]" PartialFunctionComposition nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)))
