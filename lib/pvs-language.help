			  PVS Language Summary
			  --------------------
This simply provides examples of the various language elements available in
PVS, and allows a quick reference for "typical" uses of these elements.
For the complete grammar, see the BNF (M-x help-pvs-bnf).
For a complete description, see the PVS Language Reference.

============================Example Theories==================================

orderings[t: TYPE] : THEORY
  BEGIN
    x, y, z: VAR t
    pp, qq: VAR PRED[t]
    <= : VAR PRED[[t,t]]

    reflexive?(<=) : bool = (FORALL x: x <= x)

    antisymmetric?(<=) : bool =
      (FORALL x, y: (x <= y & y <= x) => x = y)

    transitive?(<=) : bool =
      (FORALL x, y, z: (x <= y & y <= z) => x <= z)

    partial_order?(<=) : bool =
      reflexive?(<=) & antisymmetric?(<=)
                     & transitive?(<=)

    linear?(<=) : bool =
      (FORALL x, y : x <= y OR y <= x)

    total_order?(<=) : bool =
      partial_order?(<=) & linear?(<=)
  END orderings

sort [domain, range: TYPE,
      (IMPORTING orderings[range], orderings[domain])
      d_order: (total_order?[domain]),
      r_order: (partial_order?[range])] : THEORY
  BEGIN
    A, B, C: VAR ARRAY[domain->range]
    sorted?(A): bool =
      (FORALL (x, y: domain): (d_order(x, y) & x /= y)
                    => NOT r_order(A(y), A(x)))
  END sort


list[t:TYPE] : DATATYPE
  BEGIN
    null: null?
    cons (car: t, cdr :list) :cons?
  END list
state: THEORY
   BEGIN
    CONVERSION+ K_conversion
    state: TYPE+
    l: [state -> list[int]]
    x: [state -> real]
    b: [state -> bool]
    box(bv: pred[state]): bool = FORALL (s: state): bv(s)
    F: FORMULA box(b IMPLIES length(l) + 3 > x)
   END state

% K_conversion automatically converts F to

  F2: FORMULA
    box(LAMBDA (x3: state):
          b(x3) IMPLIES
           (LAMBDA (x2: state):
              (LAMBDA (x1: state): (LAMBDA (x: state): length(l(x)))(x1) + 3)
                  (x2)
               > x(x2))
               (x3))

	       
assum[x, y: int]: THEORY
 BEGIN
  ASSUMING
   diff: ASSUMPTION x /= y
  ENDASSUMING
  ...
 END assum

 
interp: THEORY
 BEGIN
  IMPORTING group{{G := int, + := +, 0 := 0, - := -}} AS G1
  G2: THEORY group{{G := nzreal, + := *,
                    - := (lambda (x:nzreal): 1/x), 0 := 1}}
 END interp

=============================Lexical Rules====================================

Comments start with '%' and go to the end of the line

Identifiers are composed of letters, digits, question mark, and underscores;
they must begin with a letter.

Numbers are composed of digits; floating point numbers are not supported.


============================Reserved Words====================================

AND             CODATATYPE      ENDIF           JUDGEMENT       RECURSIVE
ANDTHEN         COINDUCTIVE     ENDTABLE        LAMBDA          SUBLEMMA
ARRAY           COND            EXISTS          LAW             SUBTYPES
AS              CONJECTURE      EXPORTING       LEMMA           SUBTYPE_OF
ASSUMING        CONTAINING      FACT            LET             TABLE
ASSUMPTION      CONVERSION      FALSE           LIBRARY         THEN
AUTO_REWRITE    CONVERSION+     FORALL          MACRO           THEOREM
AUTO_REWRITE+   CONVERSION-     FORMULA         MEASURE         THEORY
AUTO_REWRITE-   CORECURSIVE     FROM            NONEMPTY_TYPE   TRUE
AXIOM           COROLLARY       FUNCTION        NOT             TYPE
BEGIN           DATATYPE        HAS_TYPE        O               TYPE+
BUT             ELSE            IF              OBLIGATION      VAR
BY              ELSIF           IFF             OF              WHEN
CASES           END             IMPLIES         OR              WHERE
CHALLENGE       ENDASSUMING     IMPORTING       ORELSE          WITH
CLAIM           ENDCASES        IN              POSTULATE       XOR
CLOSURE         ENDCOND         INDUCTIVE       PROPOSITION     

===============================Special Symbols================================

#      (#     ++     /\     <<     =>     [#     ^      |)     |}
##     (:     ,      :      <<=    >      []     ^^     |-     }
#)     (|     -      :)     <=     >=     [|     `      |->    }}
#]     (||)   ->     ::     <=>    >>     [||]   {      |=     ~
%      )      .      ::=    <>     >>=    \      {{     |>     
&      *      /      :=     <|     @      \/     {|     |[     
&&     **     //     ;      =      @@     ]      {||}   |]     
(      +      /=     <      ==     [      ]|     |      ||     


==============================Type Declarations===============================

----------------------Uninterpreted types and subtypes------------------------
foo: TYPE
some_nums: TYPE FROM number
nat_to_10: TYPE+ = {x:nat | x <= 10}    % TYPE+ == NONEMPTY_TYPE
posint: NONEMPTY_TYPE = {x:integer | x > 0} CONTAINING 1
ptype: TYPE = (pred?)                    % == {x | pred?(x)}

-------------------------------Function types---------------------------------

intf: TYPE = [int, int -> int]
altf: TYPE = [int, int -> int]           % same as above
inta: TYPE = ARRAY[int,int -> int]       % same as above
intp: TYPE = pred[int]                   % == [int -> bool]
ints: TYPE = setof[int]                  % == [int -> bool]

---------------------------------Tuple Types----------------------------------

tuptype: TYPE = [int, bool, [int -> int]]

--------------------------------Record types----------------------------------

stack: TYPE = [# pointer: nat, astack: [nat -> t] #]

-------------------------------Dependent Types--------------------------------

pfun: TYPE = [# dom: PRED[t1], pfn:[(dom)->t2] #]
date: TYPE = [y,m:nat, {d:nat | d <= days(m,y))}]
tmod: TYPE = [n,m:int -> {x:nat | x < m}]

------------------------------Enumeration Types-------------------------------

color: TYPE = {red, green, blue}

----------------------------------Datatypes-----------------------------------

list[t:TYPE] : DATATYPE 
 BEGIN
  null: null?
  cons (car: t, cdr :list) :cons?
 END list

-----------------Imports, Exports, and Theory Abbreviations-------------------

IMPORTING orderings[int], set[foo[nat]]
EXPORTING foo, bar WITH set[foo]
pset: THEORY = sets[list[nat]]

---------------------Constants and Recursive Definitions----------------------

some_int: int
max: int = 10
abs: [int -> nat] = (LAMBDA x: IF x < 0 THEN -x ELSE x ENDIF)
abs(x:int): nat = IF x < 0 THEN -x ELSE x ENDIF
sum(f,x,y): int                      % f,x,y prev declared VAR
sum(f,(x,y:int)): int                % f prev declared VAR
fac(n): RECURSIVE nat =
   (IF n = 0 THEN 1 ELSE n * fac(n-1) ENDIF)
   MEASURE n
depth(l: list) RECURSIVE nat =
  CASES l OF
    null: 0,
    cons(a, b): depth(b) + 1
  ENDCASES
  MEASURE l BY <<    % uses subterm ordering
even(n: nat) INDUCTIVE bool = n = 0 OR (n > 1 AND even(n - 2))

----------------------------Variable Declarations-----------------------------

x, y, z: VAR int
f: VAR [int -> [int -> int]]

----------------------------Formula Declarations------------------------------

transitive: AXIOM x < y AND y < z IMPLIES x < z
nonzero_fac: THEOREM fac(n) /= 0
poset: ASSUMPTION poset?(T,<=)   % Only in ASSUMINGs

--------------------------Judgement Declarations------------------------------

nzrat_is_nzreal: JUDGEMENT nonzero_rational SUBTYPE_OF nonzero_real
seventeen_is_prime: JUDGEMENT 17 HAS_TYPE prime
rat_plus_rat_is_rat: JUDGEMENT +(x, y: rat) HAS_TYPE rat

-------------------------------Conversions------------------------------------

CONVERSION extend[T, S, bool, false]

=================================Expressions==================================

------------------------------Equality (=, /=)--------------------------------
Defined for any type; both sides must be the same type.  With boolean,
= is treated as IFF.

x * y = 4
true /= 1            % Illegal

-------------Arithmetic (+, -, *, /, <, <=, >, >=, 0, 1, 2, ...)--------------

((x + 1) * x) / 2 < x * x

--------Logical (true, false, AND, &, OR, IMPLIES, =>, NOT, IFF, <=>,
			 FORALL, ALL, EXISTS, SOME)                  ---------

(FORALL e: (EXISTS d: abs(f(x) - f(y)) < d) IMPLIES abs(x - y) < e)

--------------------------------IF-THEN-ELSE----------------------------------

The {\tt THEN} and {\tt ELSE} parts must have compatible types.

IF x=0 THEN 1 ELSIF y=0 THEN 2 ELSE y/x ENDIF

------------------------------------CASES-------------------------------------

Pattern matching on datatypes.

  CASES x OF
    cons(x,y): append(reverse(y), cons(x, null))
    ELSE null
  ENDCASES

-----------------------------------COND---------------------------------------
  Generates coverage & disjoint TCCs:     Generates disjoint TCC:
    COND                                    COND
      x<0 -> -1,                              x<0 -> -1,
      x=0 -> 0,                               x=0 -> 0,
      x>0 -> 1                                ELSE -> 1
    ENDCOND                                ENDCOND

----------------------------------TABLE---------------------------------------
TABLE                  TABLE                             TABLE state, input 
  %-------+----++        %--------+-------+------++           %+---+---++   
  | x < 0 | -1 ||        |[ x < 0 | x = 0 | ELSE ]|           |[ x | y ]|   
  %-------+----++        %--------+-------+------++        %---+---+---++   
  | x = 0 | 0  ||        | -1     | 0     | 1    ||        | a | a | b ||   
  %-------+----++        %--------+-------+------++        %---+---+---++   
  | ELSE  | 1  ||      ENDTABLE                            | b | b | b ||   
  %-------+----++				           %---+---+---++   
ENDTABLE					         ENDTABLE           

TABLE
         %+---------------------+---------------------+---------------------++
         |[ y = 27              | y > 27              | y < 27              ]|
  %-------+---------------------+---------------------+---------------------++
  | x = 3 | 27 + sqrt(27)       | 54 + sqrt(27)       | y ^ 2 + 3           ||
  %-------+---------------------+---------------------+---------------------++
  | x < 3 | 27 + sqrt(-(x - 4)) | y + sqrt(-(x - 5))  | y ^ 2 + (x - 3) ^ 2 ||
  %-------+---------------------+---------------------+---------------------++
  | x > 3 | 27 + sqrt(x - 3)    | 2 * y + sqrt(x - 3) | y ^ 2 + (3 - x) ^ 2 ||
  %-------+---------------------+---------------------+---------------------++
ENDTABLE                                                    

---------Function application, lambda-abstraction & function update-----------

f(1,2)(0)
(lambda x: x + 1)
f WITH [(0) := 1, (1) := 0]

------------Record construction, field selection & record update--------------

(# pointer := 1, astack := (LAMBDA x: 0) #)
astack(r)                                   % r.astack NOT allowed
r WITH [pointer := 2, (astack)(1) := 1]

-----------------------Tuple construction & projection------------------------

(1, true, (LAMBDA (x:int) x + 37))
tup`3    % same as proj_3(tup)

----------------------------LET & WHERE------------------------------

WHERE is like LET, but with the assignments and expression reversed.

LET x = 2, y:nat = x*x IN f(x,y)   % == f(2,4)
f(x,y) WHERE x = 2, y:nat = x*x    % Like LET
LET sq(x: int): int = x * x IN sq(sq(3))

----------------------------------Coercion------------------------------------

Coercion indicates the expected type to the typechecker to resolve ambiguity.

a + b::nat    % Same as a + (LAMBDA (x: nat): x)(b)

------------------------------------Names-------------------------------------

If foo is declared in theory bar, then the following are allowable references
(the first three may be ambiguous).

foo
foo[int]
bar[int].foo
lib@bar[int].foo
