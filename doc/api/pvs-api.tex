% Master File: pvs-api.tex
\documentclass[12pt]{book}

\usepackage{alltt}
\usepackage{array}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{makeidx}
\usepackage{relsize}
\usepackage{boxedminipage}
\usepackage{fancyhdr}
%\usepackage{../../pvs}
\usepackage{url}
\usepackage{../makebnf}
\usepackage{latexsym}
%\usepackage{showidx} % shows index entries in the margin
\usepackage[chapter]{tocbibind}
\input{../pvstex}
\usepackage{ifpdf}
\ifpdf
\usepackage[pdftex,dvipsnames,usenames]{color}
\usepackage[bookmarks=true,hyperindex=true,colorlinks=true,linkcolor=Brown,citecolor=blue,backref=page,pagebackref=true,plainpages=false,pdfpagelabels]{hyperref}
\else
\usepackage[bookmarks=true,hyperindex=true]{hyperref}
\fi

% \makeatletter
% \@ifpackagelater{hyperref}{2000/03/23}%
% {}{\PackageWarning{language}{Package hyperref too old (older than v6.70a).}%
% \makeatother

\topmargin -10pt
\textheight 8.5in
\textwidth 6.0in
\headheight 15 pt
\columnwidth \textwidth
\oddsidemargin 0.5in
\evensidemargin 0.5in   % fool system for page 0
\setcounter{topnumber}{9}
\renewcommand{\topfraction}{.99}
\setcounter{bottomnumber}{9}
\renewcommand{\bottomfraction}{.99}
\setcounter{totalnumber}{10}
\renewcommand{\textfraction}{.5}
\renewcommand{\floatpagefraction}{.1}

\raggedbottom

%\setcounter{secnumdepth}{1}

\index{type correctness condition|see{TCC}}
\makeindex

\def\tilde{\symbol{'176}}
\newcommand{\indtt}[1]{\texttt{#1}\index{#1@\texttt{#1}}}  %text+index in tt
\def\htgt#1{\hypertarget{#1}{\indtt{#1}}}
\def\hlnk#1{\hyperlink{#1}{\texttt{#1}}}
\def\ampoptional{{\smaller\sc {\smaller\smaller \&}optional\ }}
\def\amprest{{\smaller\sc {\smaller\smaller \&}rest\ }}
\def\ampkey{{\smaller\sc {\smaller\smaller \&}key\ }}

\newenvironment{function}[3]% name, arguments, type
{\par\noindent\begin{boxedminipage}{\textwidth}%
 \par\noindent\begin{tabularx}{\linewidth}{l>{\raggedright}Xr}%
 \functionhtgt{#1}&(\texttt{\textit{#2}})&[\emph{#3}]%
 \end{tabularx}\par\flushright\begin{minipage}{.97\textwidth}}
{\end{minipage}\end{boxedminipage}}

\newcommand{\functionarg}[1]{\texttt{\textit{#1}}}
\newcommand{\functionnm}[1]{\texttt{\textit{#1}}}
\newcommand{\functionhln}[1]{\hyperlink{#1}{\functionnm{#1}}}
\newcommand{\functionidx}[1]{\functionnm{#1}\index{#1@\functionnm{#1}}}
\newcommand{\functionhtgt}[1]{\hypertarget{#1}{\functionnm{#1}}\index{#1@\functionnm{#1}|underline}}
\newenvironment{lispfunction}[2]% name, arguments
{\begin{function}{#1}{#2}{function}}{\end{function}}

\newenvironment{functioni}[3]% name, indexname, arguments
{\par\noindent\begin{boxedminipage}{\textwidth}%
 \par\noindent\begin{tabularx}{\linewidth}{lXr}%
 \hypertarget{#1}{\functionnm{#1}}\index{#2@\functionnm{#2}|underline}%
   &(\texttt{\textit{#2}})&[\emph{function}]%
 \end{tabularx}\par}
{\end{boxedminipage}}

\newenvironment{macro}[2]% name, arguments
{\begin{function}{#1}{#2}{macro}}{\end{function}}

\newenvironment{emacsmacro}[2]% name, arguments
{\begin{function}{#1}{#2}{Emacs macro}}{\end{function}}

\newenvironment{emacsfunction}[2]% name, arguments
{\begin{function}{#1}{#2}{Emacs function}}{\end{function}}

\newcommand{\classnm}[1]{\texttt{\textup{#1}}}
\newcommand{\classhln}[1]{\hyperlink{#1}{\classnm{#1}}}
\newcommand{\classidx}[1]{\classnm{#1}\index{#1@\classnm{#1}}}
\newcommand{\classhtgt}[1]{\hypertarget{#1}{\classnm{#1}}\index{#1@\classnm{#1}|underline}}
\newcommand{\slotnm}[1]{{\itshape\ttfamily #1}}
\newcommand{\slotidx}[1]{\slotnm{#1}\index{#1@\slotnm{#1}}}
\newcommand{\slotidxi}[2]{\slotnm{#1}\index{#2@\slotnm{#2}}}
\newenvironment{class}[4]% name, kind, superclasses, slots
{\par\noindent\begin{boxedminipage}{\textwidth}\par\noindent\classhtgt{#1} %
$\subset$ \ifx!#3!$\emptyset$\else\classnm{#3}\fi%
\ifx!#2!\hfill[\emph{class}]\else\hfill[\emph{#2 class}]\fi%
\ifx!#4!\else\newline%
\begin{tabularx}{\linewidth}{l<{\dotfill}X}
#4
\end{tabularx}\fi\par\dotfill\par}%
{\end{boxedminipage}}

\newcommand{\globalnm}[1]{\texttt{\textup{#1}}}
\newcommand{\globalhln}[1]{\hyperlink{#1}{\globalnm{#1}}}
\newcommand{\globalidx}[1]{\globalnm{#1}\index{#1@\globalnm{#1}}}

\newenvironment{globalvar}[1]% name
{\par\noindent\begin{boxedminipage}{\textwidth}%
 \par\noindent\texttt{\htgt{#1}}\hfill[\emph{global}]%
 \par\flushright\begin{minipage}{.97\textwidth}}
{\end{minipage}\end{boxedminipage}}

\newenvironment{emacsglobalvar}[1]% name
{\par\noindent\begin{boxedminipage}{\textwidth}%
 \par\noindent\texttt{\htgt{#1}}\hfill[\emph{Emacs global}]%
 \par\flushright\begin{minipage}{.97\textwidth}}
{\end{minipage}\end{boxedminipage}}


\begin{document}

\begin{titlepage}
\renewcommand{\thepage}{title}
\vspace*{1in}
\noindent
\rule[1pt]{\textwidth}{2pt}
\begin{center}
\newfont{\pvstitle}{cmss17 scaled \magstep4}
\textbf{\pvstitle PVS API Reference}
\end{center}
\begin{flushright}
{\Large Version 3.0 {\smaller$\bullet$} September 2003}
\end{flushright}
\rule[1in]{\textwidth}{2pt}
\vspace*{2in}
\begin{flushleft}
S.~Owre\\
N.~Shankar\\
{\smaller\url{{Owre,Shankar}@csl.sri.com}}\\
{\smaller\url{http://pvs.csl.sri.com/}}
\end{flushleft}
\vspace*{1in}
\vbox{\hbox to \textwidth{{\Large SRI International\hfill}}%
\hbox to \textwidth{{\small\sf%
Computer Science Laboratory $\bullet$ 333 Ravenswood Avenue $\bullet$ Menlo Park CA 94025\hfil}}}
\end{titlepage}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{{\em #1}}{}\markright{{\em #1}}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \em \ #1}}
\lhead[\thepage]{\rightmark}
\cfoot{Draft}
\rhead[\leftmark]{\thepage}
\thispagestyle{empty}

\newpage
\renewcommand{\thepage}{ack}
\vspace*{6in}\noindent
The initial development of PVS was funded by SRI International.
Subsequent enhancements were partially funded by SRI and by NASA
Contracts NAS1-18969 and NAS1-20334, NRL Contract N00014-96-C-2106,
NSF Grants CCR-9300044, CCR-9509931, and CCR-9712383, AFOSR contract
F49620-95-C0044, and DARPA Orders E276, A721, D431, D855, and E301.
\newpage
\pagenumbering{roman}
\setcounter{page}{1}

\tableofcontents
%\listoffigures

\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}

\setcounter{topnumber}{9}
\renewcommand{\topfraction}{.99}
\setcounter{bottomnumber}{9}
\renewcommand{\bottomfraction}{.99}
\setcounter{totalnumber}{10}
\renewcommand{\textfraction}{.01}
\renewcommand{\floatpagefraction}{.01}

\chapter{Introduction}

The Prototype Verification System (PVS) is a comprehensive framework for
formal specification and verification that features an expressive
specification language based on higher-order logic, and powerful tools for
interactive proof construction.  Use of PVS is documented in a series of
manuals~\cite{PVS:userguide,PVS:language,PVS:prover}; the present document
focuses exclusively on the API used to extend PVS, or to integrate it with
other software.

Conceptually, the PVS API consists of three interfaces: the front end
or user interface, the middle or strategies interface, and the back
end or proof engine interface. The organization of the document
follows this three-part structure, beginning with the user interface,
which underlies the PVS Emacs interface, and includes, among many
functions, those for parsing, typechecking, and proving. The
strategies interface consists of built-in strategies such as {\tt ..},
as well as user-defined strategies specified via {\tt defstep}. In
many cases, strategies are written in Lisp and rely heavily on
underlying parser, typechecker, and prover functions; much of the
chapter on the strategies interface is devoted to a description of
these functions. The chapter on the proof engine interface describes
functions used to add new logical engines (e.g., new decision
procedures, new model checkers, etc.) to the prover.

The descriptions that follow are based on the code for PVS version
3.2.  We view PVS as a work in progress and continually strive to
refine and improve the system. To this end, we solicit comments and
suggestions on the presentation of the PVS API, as well as proposals
for changes to PVS datastructures and code.

%% Prototype Verification System (PVS) is a comprehensive framework for
%% formal specification and verification.  It features an expressive
%% specification language based on higher-order logic and powerful tools for
%% interactive proof construction.  The use of PVS is documented in several
%% manuals.  The present document describes the API that can be used for
%% extending PVS or integrating it with other software.

%% The PVS API has roughly three parts: the \emph{user interface}, the
%% \emph{strategies interface}, and the \emph{proof engine interface}.  These
%% are essentially the front end, middle, and back end.

%% The user interface is what the Emacs interface builds on, and consists of
%% functions for parsing, typechecking, and proving, as well as a multitude
%% of other functions.

%% The strategies interface consists of existing strategies, as well as new
%% strategies defined using \texttt{defstep}.  In many cases the strategies
%% need to drop to the Lisp level, to search through the sequent for formulas
%% of a given pattern, or to build new terms, etc.  Thus this relies heavily
%% on the underlying functions of the parser, typechecker, and prover, and
%% much of this section is devoted to a description of these.

%% The proof engine interface allows new logical engines to be added to the
%% prover.  For exampe, new decision procedures may be added by creating a
%% set of methods that provide these to the prover.  In addition, rules may be 
%% defined that allow new model checkers, etc., to be used by the prover.

%% The following chapters describe these APIs.

%% The descriptions that follow are for PVS version 3.2, and reflect the code
%% as it exists.  Due to lack of time, we have resisted the urge to improve
%% the code.  However, once this document is complete we would like to hear
%% of any suggestions for improvement, and that includes the presentation,
%% descriptions, and changes to the datastructures and code itself.

\chapter{The Front End: User Interface}

This chapter describes the functions supporting the user interface.  The
interaction in PVS is primarily through customized Emacs scripts.  The
Emacs commands themselves are described in the User Manual.  Here we
describe the interaction between Emacs and the PVS Lisp image, and the
functions in the Lisp image that are invoked by the Emacs commands.

The information provided here should make it easy to add new Emacs
commands, or to replace Emacs with a different user interface.  Even if
you are going to replace Emacs, reading the following sections should make
this easier.

It is important to remember that both Emacs and the PVS image are written
in Lisp, though they are not the same.  In this document, we will refer to
Emacs Lisp as Elisp, and Common Lisp as Lisp.  We will also refer to the
PVS Lisp image as Lisp, context should make it obvious whether it refers
to the language or the image.

Note that the Emacs source files are provided with the PVS distribution.

\section{The Emacs Interface}
\label{emacs-interface}

In this chapter we discuss the Emacs interface, including functions that
are useful in defining new commands, various utility functions, and
techniques we have found useful in developing and debugging Emacs code.
This chapter can be skipped by those wishing to replace Emacs with a
different fromt end.

\subsection{Versions of Emacs}

There are many versions of Emacs around.  PVS is intended to support GNU
Emacs versions 19.34 and later, and all versions of XEmacs.  This is not
always easy, as there are subtle differences between GNU Emacs and XEmacs,
and even between different versions of the same system.  For this reason,
byte-compiled files go into separate directories, and some parts of the
Emacs code test the version.

\begin{emacsglobalvar}{pvs-emacs-system}
The version of Emacs in which PVS is running. Set in go-pvs.el.  Defined
as one of \texttt{xemacs21}, \texttt{xemacs20}, \texttt{xemacs19},
\texttt{emacs20}, or \texttt{emacs19} and defaults to \texttt{emacs20} if
the current version cannot be determined.  Note that under GNU Emacs
version 21 \functionnm{pvs-emacs-system} has value \texttt{emacs20},
because the differences between these versions had little impact on PVS.
\end{emacsglobalvar}

\subsection{Defining New PVS Commands}

New commands are generally provided to PVS by providing a command in
Emacs, optionally giving it a key binding and/or an abbreviated form,
defining a corresponding function in Lisp, and adding the command to the
PVS menu.

\begin{emacsmacro}{defpvs}{name class arglist docstring \amprest body}
This is similar to Emacs \functionnm{defun}, but includes a
\functionnm{class} identifier that is intended to be used for creation of
menus and documentation.  The \functionnm{class} associated with the
\functionnm{name} can be obtained using the Emacs built-in function
\functionnm{get} using property name \texttt{pvs-command}, e.g.,
\texttt{(get 'prove-theory 'pvs-command)} yields the symbol
\texttt{prove}.

Otherwise \functionnm{defpvs} simply invokes \functionnm{defun}.  Note
that to become an Emacs command the first form after the docstring must be
an \functionnm{interactive} form; see the Emacs Lisp reference manual for
details.
\end{emacsmacro}

\section{Emacs/Lisp interaction}

The Emacs code of PVS is built on ILISP, which is an interface from Emacs
to an inferior Lisp.  The basic model is simple: the PVS Lisp image runs
as a subprocess of Emacs, lisp forms are sent from Emacs to Lisp, and the
results are acted on by Emacs.  This simple model has many details that
will be described here.

\subsection{PVS Initialization}

PVS initialization starts from the \texttt{pvs} shell script, which in
turn sets up environment variables and arguments with which to invoke
Emacs (unless the \texttt{-raw} flag was provided).

Emacs then loads the PVS Emacs files, and runs the \functionhln{pvs}
function, which does some Emacs PVS initialization, then starts the
interactive Lisp subprocess, and when it is ready, some initialization
commands are sent to it.

The interactive buffer associated with the Lisp process is named
\texttt{*pvs*}.  Anything typed into this buffer is sent to the Lisp
process when the \texttt{Return} key is pressed---unless the input is
nufinished, for example because of unbalanced parentheses or a missing
double quote.  Output and errors are generally sent to this buffer, though
as described later some are filtered out by the output filter.

The \texttt{pvs} buffer tracks the low-level interaction between Emacs and
Lisp.  It is bounded by the Emacs variable \globalnm{comint-log-size},
initially 15000 (characters).  This can be made larger if something of
interest scrolls out of the buffer.

Once initialized, both Emacs and Lisp simply wait for input.

\begin{emacsfunction}{pvs}{}
The \functionnm{pvs} command starts the pvs lisp process.  This is used
for PVS initialization, but it is also useful if the Lisp process has died
for some reason, and you wish to keep using the same Emacs session.
\end{emacsfunction}

\subsection{The Lisp Status}

It is important for Emacs (or an alternative interface) to know what Lisp
is doing.  The main things one is interested in are whether it is busy
processing a command or waiting for input, and whether it is in an error
state.  The Lisp process takes a command, produces output, and then
prompts for the next input.  Emacs recognizes that Lisp is ready for more
input when it sees the prompt.  The prompt is not fixed; history indices,
break levels, package changes, etc. all change the prompt string, so it is
recognized using a regular expression (regexp).

This prompt is specific to Allegro Common Lisp, if and when PVS is ported
to other lisps, the prompt regexp will have to be modified accordingly.

\begin{emacsglobalvar}{comint-prompt-regexp}
The prompt regexp is one long string (ignore the line breaks)

\hspace*{3ex}\verb*#"^[ ]*\\(\\[[0-9]+i?c?\\] \\|\\[step\\] \\)?#

\hspace*{3ex}\verb*#\\(\\(<[-A-Za-z]* ?[0-9]*> \\)\\3?\\|[-A-Za-z0-9]+([0-9]+): \\)#

\hspace*{3ex}\verb*#\\|Rule\\? \\|(Y or N)\\|(Yes or No)\\|Please enter"#

This can be understood as follows:
\begin{description}
\item[] \verb*#^[ ]*# - prompt starts with any number (including 0) of
spaces.

\item[] \verb*#\\(\\[[0-9]+i?c?\\] \\|\\[step\\] \\)?# - optionally
followed by a prefix from a break, e.g., \texttt[3], where \texttt{3} is
the break level, and the optional \texttt{c} indicates a continuable
break, and optional \texttt{i} indicates an inspector break.  If the
stepper is running, the prefix is simply \texttt{[step]}.
\end{description}

After this the prompt must match one of six possibilities:
\begin{description}
\item[] \verb*#\\(<[-A-Za-z]* ?[0-9]*> \\)\\3?# - this is for the ground
evaluator, which is of the form \texttt{<GndEval>}.  Not sure why the
regexp includes digits and possible repitition (the \verb*#\\3?# pattern
matches the third occurrence of a \verb*#\\(...\\)#, which in this case is
the immediately preceding pattern).  This is possibly left over from some
ground evaluator experiments.

\item[] \verb*#[-A-Za-z0-9]+([0-9]+): # - this is the normal Lisp prompt,
usually of the form \verb*#pvs(25): #.

\item[] \verb*#Rule\\? # - the prover prompt (backslashes are needed for
literal \texttt{?}).
\end{description}
The other three prompts are obvious, and come up when Lisp asks a
question.
\end{emacsglobalvar}

Emacs also must recognize when Lisp has been interrupted, because some
commands will interrupt any running command.  To do this, Emacs sends an
interrupt signal to Lisp, and waits for the interrupt to be accepted.
Then the interrupting command is sent, and when control returns the
original command is allowed to continue.

\begin{emacsglobalvar}{comint-interrupt-regexp}
This has the following value.

\hspace*{3ex}\verb*#"Error: [^\n]* interrupt\)"#

And matches strings such as

\texttt{Error: Received signal number 2 (Keyboard interrupt)}

Note that this is not a prompt, though a prompt usually follows shortly
thereafter.
\end{emacsglobalvar}


\subsection{Emacs to Lisp}

Most PVS commands take input from the user, create a Lisp form, and send
it to Lisp using one of the following functions.  Most of this process can
be seen in the \texttt{pvs} buffer, which records the low-level
interactino between Emacs and Lisp.

\begin{emacsfunction}{pvs-send}{string \ampoptional message status}
This sends the \functionarg{string} to Lisp, but does not expect a
result.  If Lisp is currently processing another command, this is put in
an ILISP queue, and will be executed when all other commands before it are
completed.  The \functionarg{message} is a string that is displayed in the
minibuffer when the command is executed, and the \functionarg{status}
string is put on the status bar (it's best to keep this short).
\end{emacsfunction}

\begin{emacsfunction}{pvs-send-and-wait}
{string \ampoptional message status expected}

This is similar to \functionnm{pvs-send}, but waits for the result, which
should be of type \functionarg{expected}.  If another command is currently
running it is interrupted and when the interrupt is acknowledged, the
\functionarg{string} is passed to Lisp, and the result of evaluating the
\functionarg{string} is passed back to the waiting function.  Typically
this is only used for short functions such as status or display commands.
The \functionarg{expected} can be any value, but if it is
\texttt{'dont-care}, the result is automatically \texttt{nil}, otherwise
the result is read from the Lisp output string.
\end{emacsfunction}

\begin{emacsfunction}{pvs-file-send-and-wait}
{string \ampoptional message status expected}

Exactly like \functionnm{pvs-send-and-wait}, except that the result is 
inserted into a temporary file, and the file name is returned.  This
is useful when the result is large, or if it may contain substrings that
could match the prompt or other regexps.  You can switch from
\functionnm{pvs-send-and-wait} to \functionnm{pvs-file-send-and-wait}
without modifying the Lisp code that is invoked.
\end{emacsfunction}


\subsection{Lisp to Emacs}
\label{lisp-to-emacs}

The Lisp subprocess of Emacs has an associated \emph{process
filter}\index{process filter}, \functionhln{pvs-process-filter}, that is
invoked asynchronously when some output has been generated from lisp.
This output is collected until a carriage return is seen, and then sent to
the \functionnm{pvs-output-filter}, which filters out and acts on specific
patterns of output; anything not filtered is then appended to the
\texttt{*pvs*} buffer, and compared to the prompt regexp.  If it matches,
the next command in the queue, if any, is sent.

\begin{emacsfunction}{pvs-output-filter}{output}
The \functionnm{pvs-output-filter} basically looks for patterns in the
output, chops them out, acts on them, and returns what is left.  There are
several possibilities, all having the form
\begin{alltt}
  :pvs-\textit{key} arg\(\sb{1}\) \& \ldots \& arg\(\sb{n}\) :end-pvs-\textit{key}
\end{alltt}
The possible \textit{key}s, their arguments, and their actions are described
below.
\end{emacsfunction}

\noindent
\begin{tabularx}{\linewidth}{|>{\tt}l|%
                              >{\hsize=.35\hsize\ttfamily\itshape}X|%
                              >{\hsize=1.65\hsize}X|}\hline
\textrm{\textbf{Key}} & \textrm{\textup{\textbf{Arguments}}}
                      & \textbf{[Invoking Lisp Functions] Action} \\ \hline\hline
msg & string
    & [\functionhln{pvs-message}, \functionhln{verbose-msg}] Displays
      \functionarg{string} in the minibuffer, and adds it to the
      \texttt{PVS Log} buffer. \\ \hline 
log & string & [\functionhln{pvs-log}] Quietly adds the
               \functionarg{string} to the \texttt{PVS Log} buffer.  \\ \hline
%% warn & string & Quietly adds the \functionarg{string} to the \texttt{PVS Log}
%%                 buffer.  [\functionhln{pvs-warning}] \\ \hline
out & file
    & [\functionhln{pvs-output}]  This is used in Batch Mode to force the
      \functionarg{file} contents that usually go into the \texttt{*pvs*}
      buffer to be output to stdout.   \\ \hline
err & {\raggedright file\\} {\raggedright dir\\} {\raggedright msg\\}
      {\raggedright err\\} {\raggedright place}
    & [\functionhln{pvs-error}]  Switches to a boffer containing the PVS
      \functionarg{file} (in directory \functionarg{dir} if not
      \texttt{nil}), and places the cursor at the row and column of
      \functionarg{place} (which is simply two nonnegative integers with a
      space between).  Then the contents of file \functionarg{err} are
      displayed in the \texttt{PVS Error} buffer, and the
      \functionarg{err} file is deleted. Finally, the \functionarg{msg}
      string is displayed in the minibuffer. \\ \hline
%% qry & {\raggedright file\\} {\raggedright dir\\} {\raggedright query\\}
%%       {\raggedright mitems\\} {\raggedright place}
%%     &  \\ \hline
buf & {\raggedright bufname\\} {\raggedright file\\}
      {\raggedright display\\} {\raggedright read-only\\}
      {\raggedright append}
    & [\functionhln{pvs-buffer}] Creates a buffer with name
      \functionarg{bufname} and contents from \functionarg{file}.  The
      buffer is displayed if \functionarg{display} is \texttt{t}, set to
      read-only if \functionarg{read-only} is \texttt{t}, and the
      \functionarg{file} contents are appended if the optional
      \functionarg{append} argument is \texttt{t}, otherwise they replace
      earlier buffer contents. \\ \hline
yn & {\raggedright msg\\} {\raggedright yesno-p\\}
     {\raggedright timeout-p}
   & [\functionhln{pvs-yn}] Uses \functionarg{msg} as a prompt for a
     \texttt{y} or \texttt{n} answer from the user in the minibuffer.
     Both the other args are optional, if \functionarg{yesno-p} is
     \texttt{t}, then prompts for \texttt{yes} or \texttt{no}, and if
     \functionarg{timeout-p} is \texttt{t}, defaults to \texttt{y} (or
     \texttt{yes}) after \globalnm{pvs-default-timeout} seconds. \\ \hline
bel & & [\functionhln{beep}] Simply beeps. \\ \hline
loc & {\raggedright dir\\} {\raggedright file\\} {\raggedright place}
    & [\functionhln{pvs-locate}] Adds a message to the \texttt{PVS Log}
      buffer indicating that this action was taken, and switches to a
      boffer containing the \functionarg{file} of directory
      \functionarg{dir}, and places the cursor at the row and column of
      \functionarg{place} (which is simply two nonnegative integers with a
      space between). \\ \hline
mod & {\raggedright dir\\} {\raggedright file\\} {\raggedright region\\}
      {\raggedright textfile}
    & [\functionhln{pvs-modify-buffer}] Replaces the \functionarg{region}
      (four nonnegative integers separated by a space) in the given
      \functionarg{file} of directory \functionarg{dir} with the text in
      file \functionarg{textfile}. \\ \hline
pmt & {\raggedright kind\\} {\raggedright prompt}
    & [\functionhln{pvs-prompt}] Prompts the user for input using the
      minibuffer.  The \functionarg{prompt} string is displayed, and the
      \functionarg{kind} allows Emacs to use normal input techniques
      (completion, etc.) for the result.  Currently, the kind supported is
      just \texttt{directory}. \\ \hline 
%% dis & {\raggedright proof\\} {\raggedright instance\\}
%%       {\raggedright type\\} {\raggedright value}
%%     & \\ \hline
wish & Tcl/Tk-form
     & [\functionhln{pvs-wish}, \functionhln{pvs-wish-source}] Sends the
       \functionarg{Tcl/Tk-form} to the wish subprocess (see
       Subsection~\ref{tcl-tk-interface}). \\ \hline
eval & Emacs-form
     & [\functionhln{pvs-emacs-eval}] Evaluates the
       \functionarg{Emacs-form} string in Emacs, returning the result to
       Lisp. \\ \hline 
\end{tabularx}

The following functions are used to create the forms described above.
However, if they are not invoked from Emacs, they simply produce their
results in the \texttt{*pvs*} buffer.  This is useful for debugging, as it
is then easier to tell the sequence of events.  This is controlled by the
\texttt{*to-emacs*} Lisp global variable, which is set to \texttt{t} by
the Lisp \functionnm{pvs-errors} macro, which is wrapped around the
strings sent by the Emacs \functionnm{pvs-send},
\functionnm{pvs-send-and-wait}, and \functionnm{pvs-file-send-and-wait}.

\begin{lispfunction}{pvs-message}{ctl \amprest args}
The \functionarg{ctl} argument is a \functionnm{format} control string,
and it should correspond to the \functionarg{args}.  If the Lisp global
variable \globalnm{*suppress-msg*} is \texttt{t}, nothing is output,
otherwise the \functionnm{format} macro (see CLtL2) is applied to the
\functionarg{args}, for the \functionarg{string} argument to the
\texttt{:pvs-msg} form, or simply output if \globalnm{*to-emacs*} is
\texttt{nil}.
\end{lispfunction}

\begin{lispfunction}{pvs-log}{ctl \amprest args}
This is exactly like \functionnm{pvs-message}, except the results are not
printed if \globalnm{*to-emacs*} is \texttt{nil}, and uses the
\texttt{:pvs-log} form otherwise.
\end{lispfunction}

\begin{lispfunction}{pvs-output}{ctl \amprest args}
As in \functionnm{pvs-message}, \functionnm{format} is applied to
\functionarg{ctl} and \functionarg{args}.  In batch mode
(\globalnm{*noninteractive*} is \texttt{t}), the result is put into a
temporary file for the \functionarg{file} argument to the \texttt{:pvs-out}
form, otherwise it is simply output if \globalnm{*to-emacs*} is
\texttt{nil}.
\end{lispfunction}

\begin{lispfunction}{pvs-error}{msg err \ampoptional ifile iplace}
This function is used to indicate a user error, such as a parse or type
error.  If \globalhln{*rerunning-proof*} is not \texttt{nil},
\texttt{(restore)} is called, so the error is skipped when rerunning a
proof.  If \globalnm{*to-emacs*} is set, it builds the \texttt{:pvs-err}
form arguments as follows:
\begin{description}
\item[\functionarg{file}] - if currently processing a declaration generated
for a recursive type (\globalnm{*adt-decl*} is not \texttt{nil}), the
\functionarg{file} is the filename being generated.  Otherwise, if
\globalhln{*from-buffer*} is set, it is used, else \functionarg{ifile}.
\item[\functionarg{dir}] - unless \globalhln{*from-buffer*} is set, the
\globalhln{*pvs-context-path*} is used for \functionarg{dir}.
\item[\functionarg{msg}] - use the \functionnm{pvs-error}
\functionarg{msg} argument.
\item[\functionarg{err}] - use the \functionnm{pvs-error}
\functionarg{err} argument.
\item[\functionarg{place}] - if \globalhln{*adt-decl*} is set, use its
place, otherwise use \functionarg{iplace} to extract the line and column.
\end{description}
\end{lispfunction}

\begin{lispfunction}{pvs-buffer}
  {name contents \ampoptional display? read-only? append?}
If \globalhln{*to-emacs*} is not \texttt{nil}, sends the \texttt{:pvs-buf}
form with the given buffer \functionarg{name}, a temporary
\functionarg{file} containing \functionarg{contents}, and the three flag
values.
\end{lispfunction}

\begin{lispfunction}{pvs-yn}{msg full? timeout?}
This function prompts with \functionarg{msg} for a yes or no answer.
If \globalhln{*noninteractive*} is \texttt{t}, this function simply
returns \texttt{t}.  If \globalhln{*pvs-emacs-interface*} and
\globalhln{*to-emacs*} are both \texttt{t}, the \texttt{:pvs-yn} form is
created and output.  Then the Lisp \functionnm{read} is called to read
whatever is passed to it.  If the value read is the keyword
\texttt{:abort}\index{:abort@\texttt{:abort}}, then
\functionhln{pvs-abort} is called, otherwise the value is returned.

If \globalhln{*pvs-emacs-interface*} and \globalhln{*to-emacs*} are not
both \texttt{t}, then if \functionarg{full?} is \texttt{t},
\functionhln{yes-or-no-p-with-prompt} is called, otherwise
\functionhln{y-or-n-p-with-prompt} is called.
\end{lispfunction}

\begin{lispfunction}{beep}{}
If \globalhln{*to-emacs*} is not \texttt{nil}, sends the \texttt{:pvs-bel}
form.
\end{lispfunction}

\begin{lispfunction}{pvs-locate}{theory obj \ampoptional loc}
If \globalhln{*to-emacs*} is not \texttt{nil}, sends the \texttt{:pvs-loc}
form.  The \functionnm{theory} is either a theory or datatype.  The
\functionnm{dir} argument is \texttt{nil} unless the theory or datatype is
from the prelude or a library, in which case it is the corresponding
directory.  The \functionnm{file} is the file containing the theory or
datatype, and the \functionnm{place} is \functionnm{loc} if non-nil, or
the place of \functionnm{obj}.
\end{lispfunction}

\begin{lispfunction}{pvs-modify-buffer}{dir name place contents}
This function is used to modify a specified pvs file.  Given a
\functionnm{dir} string, pvs file \functionnm{name}, \functionnm{place} (a
\classnm{place}, and \functionnm{contents} string, the region determined
by the \functionnm{place} is replaced by the \functionnm{contents}.  Note
that if \functionnm{contents} is \texttt{nil} or the empty string, this
simply deletes the region.

If \globalhln{*to-emacs*} is \texttt{nil}, this simply outputs the
\functionnm{contents}.  Otherwise a \texttt{:pvs-mod} form is output, with
the given \functionnm{dir}, and \functionnm{file} is set to
\functionnm{name}.  The \functionnm{region} is created by invoking
\functionhln{place-list} on the \functionnm{place} argument.  The
\functionnm{contents}, if non-nil, are written to a temporary file (using
\functionhln{write-to-temp-file}) which is used for the
\functionnm{textfile}.
\end{lispfunction}

\begin{lispfunction}{pvs-prompt}{type msg \amprest args}
This function is used to prompt for a value.  It creates the prompt string
by invoking \texttt{format} on \functionnm{msg} and \functionnm{args}.  If
\globalhln{*to-emacs*} is \texttt{nil}, it outputs the prompt, otherwise
it sends the \texttt{:pvs-pmt} form to Emacs, with \functionnm{type} (as
the \functionnm{kind}) and the \functionnm{prompt} string.  In either
case, the Common Lisp \texttt{read} function is invoked, which reads the
result.
\end{lispfunction}

\begin{lispfunction}{pvs-wish}{cmd}
This simply sends the \texttt{:pvs-wish} form with the given Tcl/Tk
\functionnm{cmd}.
\end{lispfunction}

\begin{lispfunction}{pvs-wish-source}{file}
This function sends the \texttt{:pvs-wish} form with the Tcl/Tk string
\begin{alltt}
  "catch \{source \functionnm{file}\}; exec rm -f \functionnm{file}"
\end{alltt}
This causes the Tcl/Tk process to load the file, and then to delete it.
\end{lispfunction}

\begin{lispfunction}{pvs-emacs-eval}{form}
If \globalhln{*pvs-emacs-interface*} is not \texttt{nil}, this function
creates a \texttt{:pvs-eval} form, which causes the \functionnm{form} to
be evaluated by Emacs.  It then invokes the Common Lisp \texttt{read}
function to read the result.
\end{lispfunction}


\subsection{Lisp Functions invoked by Emacs Commands}

Commands to PVS are normally entered through the Emacs interface,
described in Section~\ref{emacs-interface}.  Here we describe the
functions invoked by Emacs.  This is useful for debugging, and provides
the information needed for providing an alternative User Interface.

Most of the functions have obvious arguments, but many of the PVS Emacs
commands pass in the current location of the cursor as well.  Most of the
time this is the line number, with line $1$ at the beginning of the file.
If a column is given, it starts at $0$.  This is also true of the PVS
output.

In the following, when a function is said to return a buffer with a
certain name, it means that it returns a \texttt{:pvs-buf} form as
described in Subsection~\ref{lisp-to-emacs}.

The following sections correspond to the PVS menu structure, and for each
menu entry shows the corresponding Lisp functions that are invoked, if
any.  Some of these functions are subsidiary, and simply provide, for
example, the list of known PVS theories so that completion may be used.
Such functions are marked with a daggar ($^\dagger$).

\subsubsection{Getting Help}

\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  help-pvs & \\
  help-pvs-language & \\
  help-pvs-bnf & \\
  help-pvs-prover & \functionhln{help-prover} \\
  help-pvs-prover-command
    & \functionhln{collect-strategy-names}$^\dagger$,
      \functionhln{help-prover} \\
  help-pvs-prover-strategy
    & \functionhln{collect-strategy-names}$^\dagger$,
      \functionhln{show-strategy} \\
  help-pvs-prover-emacs & \\
  pvs-release-notes & \\ \hline
\end{tabularx}

Most of the help commands simply load a file from the \texttt{lib}
subdirectory of the PVS installation directory.

\begin{lispfunction}{help-prover}{\ampoptional name}
Returns a buffer with the corresponding prover help.  If the
\functionarg{name} is provided, help for that name is returned.  If the
\functionarg{name} is not known, the contents will be
\begin{alltt}
  No such rule, defined rule or strategy.
\end{alltt}
If the \functionarg{name} is not provided (or is \texttt{nil}), help for
all the prover commands is returned.
\end{lispfunction}

\begin{lispfunction}{show-strategy}{strat-name}
\end{lispfunction}

\begin{lispfunction}{collect-strategy-names}{\ampoptional all?}
Returns a sorted list of the rule and strategy names.  If
\functionarg{all?} is not \texttt{nil}, the list includes helper
strategies as well.  The strategies files, if any are loaded first, so
user-defined rules and strategies are included.
\end{lispfunction}

\subsubsection{Editing PVS Files}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  forward-theory & \\
  backward-theory & \\
  find-unbalanced-pvs & \\
  comment-region & \\ \hline
\end{tabularx}

These functions are entirely in Emacs, and do not invoke any Lisp functions.

\subsubsection{Parsing and Typechecking}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  parse & \functionhln{pvs-current-directory}$^\dagger$,
          \functionhln{parse-file} \\
  typecheck
    & \functionhln{pvs-current-directory}$^\dagger$,
      \functionhln{typecheck-file} \\
  typecheck-importchain
    & \functionhln{pvs-current-directory}$^\dagger$,
      \functionhln{typecheck-file} \\
  typecheck-prove
    & \functionhln{pvs-current-directory}$^\dagger$,
      \functionhln{typecheck-file} \\
  typecheck-prove-importchain
    & \functionhln{pvs-current-directory}$^\dagger$,
      \functionhln{typecheck-file} \\ \hline
\end{tabularx}

\begin{lispfunction}{parse-file}
  {filename \ampoptional forced? no-message?}
This parses the specified \functionarg{filename}, returning multiple
values:
\begin{itemize}
\item a list of theories and datatypes
\item a flag indicating whether the file was loaded from bin files
(\texttt{t} if it was)
\item the list of theories that changed since the last time the file was
parsed
\end{itemize}

If \functionarg{forced?} is \texttt{t}, then any bin files are ignored,
and the file is parsed even if it hasn't changed.  Otherwise it is only
parsed if it is not up to date, based on the file modification time, or if
the prover or ground evaluator are currently running.  If binfiles are
available and up to date, they are loaded, otherwise the file is parsed.
\end{lispfunction}

\begin{lispfunction}{typecheck-file}
  {filename \ampoptional forced? prove-tccs? importchain? nomsg?}  This
function is the main function for typechecking PVS files.  It starts by
calling \functionhln{parse-file} to get the abstract syntax of the
theories and datatypes in the \functionarg{filename}.  If
\functionarg{forced?} is \texttt{nil}, and the theories are already
typechecked, a corresponding message is output unless \functionarg{nomsg?}
and \functionarg{restored?} are \texttt{nil}.  Similarly, if
\globalhln{*in-checker*} or \globalhln{*in-evaluator*} are \texttt{t}, a
message is output and the function exits.  Finally, if the theories are
not typechecked, or \functionarg{forced?} is \texttt{t}, the theories are
typechecked.  Finally, if \functionarg{prove-tccs?} is \texttt{t},
\functionhln{prove-unproved-tccs} is invoked to attempt to prove the TCCs.
\end{lispfunction}

\subsubsection{Prover Invocation}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  prove & \functionhln{typecheck-file},
          \functionhln{typechecked?}$^\dagger$,
          \functionhln{rerun-proof-at?}$^\dagger$,
          \functionhln{prove-file-at} \\
  x-prove & \functionhln{typecheck-file},
            \functionhln{typechecked?}$^\dagger$,
            \functionhln{rerun-proof-at?}$^\dagger$,
            \functionhln{prove-file-at} \\
  step-proof & \functionhln{typecheck-file},
               \functionhln{typechecked?}$^\dagger$,
               \functionhln{rerun-proof-at?}$^\dagger$,
               \functionhln{prove-file-at} \\
  x-step-proof & \functionhln{typecheck-file},
                 \functionhln{typechecked?}$^\dagger$,
                 \functionhln{rerun-proof-at?}$^\dagger$,
                 \functionhln{prove-file-at} \\
  redo-proof & \functionhln{typecheck-file},
               \functionhln{typechecked?}$^\dagger$,
               \functionhln{rerun-proof-at?}$^\dagger$,
               \functionhln{prove-file-at} \\
  prove-theory & \functionhln{collect-theories}$^\dagger$,
                 \functionhln{prove-theory} \\
  prove-theories & \functionhln{collect-theories}$^\dagger$,
                   \functionhln{prove-pvs-theories} \\
  prove-pvs-file & \functionhln{prove-pvs-file} \\
  prove-importchain & \functionhln{collect-theories}$^\dagger$,
                      \functionhln{prove-usingchain} \\
  prove-proofchain & \functionhln{prove-proofchain} \\ \hline
\end{tabularx}


\begin{lispfunction}{prove-file-at}{name declname line rerun? \ampoptional origin buffer prelude-offset background? display? unproved?}
This function is called to prove a specific formula.  The
\functionarg{name} is the buffer name, without extension.  The
\functionarg{origin} is one of \texttt{pvs}, \texttt{ppe}, \texttt{tccs},
or \texttt{prelude}.  The \functionarg{declname} is \texttt{nil}, unless
this is from a declaration TCCs buffer, in which case it is needed in
order to uniquely identify the declaration associated with the TCC (see
\functionhln{decl-to-declname}).  The \functionarg{line} is the line
number the cursor was on (the first line is 1).  The \functionarg{rerun?}
flag indicates whether the proof is to be rerun.  The \functionarg{buffer}
is the name of the buffer, which is needed because files from different
directories can have the same name in Emacs, though the buffer names are
unique.  For example, there might be a \texttt{foo.pvs} from two different
directories, in which case the buffer name for one of them is likely to be
\texttt{foo.pvs<2>}.  The \functionarg{background?} flag indicates whether
the proof is to be run in the background, \functionarg{display?} indicates
the Tcl/Tk display should be used, and \functionarg{unproved?} indicates
whether to look for the next formula following the cursor position, or the
next unproved formula, skipping over any proved ones.

The function works as follows.  First the \functionarg{line} is checked,
if it is not an integer, then the arguments are all shifted one to the
right, setting the \functionarg{declname} to \texttt{nil}.  This is just
to handle calls from older versions, as the \functionarg{declname} is a
recent addition.

If \globalhln{*in-checker*} or \globalhln{*in-evaluator*} are \texttt{t},
the function exits with a message.  Otherwise, \globalhln{*to-emacs*} is
bound to the value of \functionarg{background?}, and the formula
declaration is retrieved using \functionhln{formula-decl-to-prove}.  If
\functionarg{rerun?} is \texttt{t} and the formula has no associated
proof, a message is output and the function exits.  Otherwise
\globalhln{*current-context*} and \globalhln{*current-theory*} are bound
to the context and theory of the declaration.  Note that the context does
not include the declaration itself.  The \globalhln{*start-proof-display*}
variable is bound to the value of \functionarg{display?}, the proof script
is extracted using \functionhln{extract-justification-sexp}, and the
relevant strategies files are loaded using
\functionhln{read-strategies-files}.

Then the proof is actually run.  If \functionarg{background?} is
\texttt{t}, \functionhln{pvs-prove-decl} is called, otherwise
\functionhln{auto-save-proof-setup} is called, followed by
\functionhln{prove} with the \texttt{(rerun)} strategy if
\functionarg{rerun?} is \texttt{t}.

When the prover returns control, \globalhln{*last-proof*} is set to the
resulting prooftree.  If the proof has changed, it is written to file
using \functionhln{save-all-proofs}, and the proof status associated with
the formula in \globalhln{*pvs-context*} is set.  Note that the proof does
not change if \functionarg{background?} is \texttt{t}.  The
\functionhln{remove-auto-save-proof-file} function is called, and finally,
if \globalhln{*to-emacs*} is \texttt{t}, \functionhln{pvs-locate} is
called to make the buffer containing the formula current, and place the
cursor at the beginning of it.
\end{lispfunction}

\begin{lispfunction}{prove-theory}
  {theoryname \ampoptional retry? filename use-default-dp?}
\end{lispfunction}

\begin{lispfunction}{prove-pvs-file}
  {file retry? \ampoptional use-default-dp?}
\end{lispfunction}

\begin{lispfunction}{prove-usingchain}
  {theoryname retry? \ampoptional exclude use-default-dp?}
\end{lispfunction}

\begin{lispfunction}{prove-proofchain}
  {filename declname line origin retry? \ampoptional use-default-dp?}
\end{lispfunction}

\begin{lispfunction}{typechecked?}{theory}
\end{lispfunction}

\begin{lispfunction}{rerun-proof-at?}
  {name declname line \ampoptional origin rerun? unproved?}
\end{lispfunction}

\subsubsection{Proof Editing}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  edit-proof & \functionhln{typecheck-file},
               \functionhln{typechecked?}$^\dagger$,
               \functionhln{edit-proof-at} \\
  install-proof & \functionhln{install-proof},
                  \functionhln{prove-proof-at} \\
  display-proofs-formula & \functionhln{display-proofs-formula-at} \\
  display-proofs-theory & \functionhln{collect-theories}$^\dagger$,
                          \functionhln{display-proofs-theory} \\
  display-proofs-pvs-file & \functionhln{display-proofs-pvs-file} \\
  revert-proof & \\
  remove-proof & \functionhln{remove-proof-at} \\
  show-proof-file & \functionhln{show-proof-file} \\
  show-orphaned-proofs & \functionhln{show-orphaned-proofs} \\
  show-proofs-theory & \functionhln{show-proofs-theory} \\
  show-proofs-pvs-file & \functionhln{show-proofs-pvs-file} \\
  show-proofs-importchain & \functionhln{collect-theories}$^\dagger$,
                            \functionhln{show-proofs-importchain} \\
  install-pvs-proof-file & \functionhln{install-pvs-proof-file} \\
  load-pvs-strategies & \functionhln{read-strategies-files} \\
  toggle-proof-prettyprinting & \functionhln{toggle-proof-prettyprinting} \\
  set-print-depth & \\
  set-print-length & \\
  set-rewrite-depth & \\
  set-rewrite-length & \\ \hline
\end{tabularx}

\begin{lispfunction}{edit-proof-at}
  {filename declname line origin buffer prelude-offset full-label}
\end{lispfunction}

\begin{lispfunction}{install-proof}
  {tmpfilename name declname line origin buffer prelude-offset}
\end{lispfunction}

\begin{lispfunction}{prove-proof-at}{line step? display?}
\end{lispfunction}

\begin{lispfunction}{display-proofs-formula-at}{name declname origin line}
\end{lispfunction}

\begin{lispfunction}{display-proofs-theory}{theoryname}
\end{lispfunction}

\begin{lispfunction}{display-proofs-pvs-file}{filename}
\end{lispfunction}

\begin{lispfunction}{remove-proof-at}{name declname line origin}
\end{lispfunction}

\begin{lispfunction}{show-proof-file}{context filename}
Given the \functionnm{context} and PVS \functionnm{filename}, this invokes
\functionhln{pvs-buffer} to create a \texttt{Proofs} buffer containing all
the default proof scripts associated with the \functionnm{filename}.
\end{lispfunction}

\begin{lispfunction}{show-orphaned-proofs}{}
Like 
\end{lispfunction}

\begin{lispfunction}{show-proofs-theory}{theoryname}
\end{lispfunction}

\begin{lispfunction}{show-proofs-pvs-file}{file}
\end{lispfunction}

\begin{lispfunction}{show-proofs-importchain}{theoryname}
\end{lispfunction}

\begin{lispfunction}{install-pvs-proof-file}{filename}
\end{lispfunction}

\begin{lispfunction}{read-strategies-files}{}
\end{lispfunction}

\begin{lispfunction}{toggle-proof-prettyprinting}{}
\end{lispfunction}


\subsubsection{Proof Information}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  show-current-proof & \functionhln{call-show-proof} \\
  explain-tcc & \functionhln{call-explain-tcc} \\
  show-last-proof & \functionhln{show-last-proof} \\
  ancestry & \functionhln{call-ancestry} \\
  siblings & \functionhln{call-siblings} \\
  show-hidden-formulas & \functionhln{call-show-hidden} \\
  show-auto-rewrites & \functionhln{show-auto-rewrites} \\
  show-expanded-sequent & \functionhln{show-expanded-sequent} \\
  show-skolem-constants & \functionhln{show-skolem-constants} \\
  pvs-set-proof-parens & \\
  pvs-set-proof-prompt-behavior & \\
  pvs-set-proof-default-description & \\ \hline
\end{tabularx}

\begin{lispfunction}{call-show-proof}{}
\end{lispfunction}

\begin{lispfunction}{call-explain-tcc}{}
\end{lispfunction}

\begin{lispfunction}{show-last-proof}{\ampoptional terse?}
\end{lispfunction}

\begin{lispfunction}{call-ancestry}{}
\end{lispfunction}

\begin{lispfunction}{call-siblings}{}
\end{lispfunction}

\begin{lispfunction}{call-show-hidden}{}
\end{lispfunction}

\begin{lispfunction}{show-auto-rewrites}{}
\end{lispfunction}

\begin{lispfunction}{show-expanded-sequent}{\ampoptional all?}
\end{lispfunction}

\begin{lispfunction}{show-skolem-constants}{}
\end{lispfunction}

\subsubsection{Adding and Modifying Declarations}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  add-declaration & \functionhln{add-declaration-at} \\
  modify-declaration & \functionhln{modify-declaration-at} \\ \hline
\end{tabularx}

\begin{lispfunction}{add-declaration-at}{filename line}
\end{lispfunction}

\begin{lispfunction}{modify-declaration-at}{filename line}
\end{lispfunction}


\subsubsection{Prettyprint}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  prettyprint-theory & \functionhln{collect-theories}$^\dagger$,
                       \functionhln{prettyprint-theory} \\
  prettyprint-pvs-file & \functionhln{prettyprint-pvs-file} \\
  prettyprint-declaration & \functionhln{prettyprint-region} \\
  prettyprint-region & \functionhln{prettyprint-region} \\ \hline
\end{tabularx}

\begin{lispfunction}{prettyprint-theory}{theoryname filename}
\end{lispfunction}

\begin{lispfunction}{prettyprint-pvs-file}{filename}
\end{lispfunction}

\begin{lispfunction}{prettyprint-region}
  {filename pos1 \ampoptional (pos2 pos1)}
\end{lispfunction}

\subsubsection{Viewing TCCs}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  show-tccs & \functionhln{collect-theories}$^\dagger$,
              \functionhln{show-tccs} \\
  prettyprint-expanded & \functionhln{collect-theories}$^\dagger$,
                         \functionhln{prettyprint-expanded} \\ \hline
\end{tabularx}

\begin{lispfunction}{show-tccs}{theoryref \ampoptional unproved-only?}
\end{lispfunction}

\begin{lispfunction}{prettyprint-expanded}{theoryref}
\end{lispfunction}


\subsubsection{Files and Theories}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  find-pvs-file & \\
  find-theory & \functionhln{collect-theories}$^\dagger$ \\
  view-prelude-file & \\
  view-prelude-theory & \\
  view-library-file & \functionhln{library-files}$^\dagger$ \\
  view-library-theory & \functionhln{library-theories}$^\dagger$ \\
  new-pvs-file & \\
  new-theory & \functionhln{collect-theories}$^\dagger$ \\
  import-pvs-file & \\
  import-theory & \\
  delete-pvs-file & \functionhln{delete-pvs-file} \\
  delete-theory & \functionhln{collect-theories}$^\dagger$,
                  \functionhln{delete-theory} \\
  save-pvs-file & \\
  save-some-pvs-files & \\
  smail-pvs-files & \\
  rmail-pvs-files & \\
  dump-pvs-files & \\
  undump-pvs-files & \\
  save-pvs-buffer & \\ \hline
\end{tabularx}

\begin{lispfunction}{library-files}{}
\end{lispfunction}

\begin{lispfunction}{library-theories}{}
\end{lispfunction}

\begin{lispfunction}{delete-pvs-file}{filename \ampoptional delete-file?}
\end{lispfunction}


\subsubsection{Printing}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  pvs-print-buffer & \\
  pvs-print-region & \\
  print-theory & \functionhln{collect-theories}$^\dagger$ \\
  print-pvs-file & \\
  print-importchain & \functionhln{collect-theories}$^\dagger$ \\
  alltt-theory & \functionhln{collect-theories}$^\dagger$ \\
  alltt-pvs-file & \\
  alltt-importchain & \functionhln{collect-theories}$^\dagger$ \\
  alltt-proof & \functionhln{alltt-proof} \\
  latex-theory & \functionhln{collect-theories}$^\dagger$,
                 \functionhln{latex-theory} \\
  latex-pvs-file & \functionhln{latex-pvs-file} \\
  latex-importchain & \functionhln{collect-theories}$^\dagger$,
                      \functionhln{latex-usingchain} \\
  latex-proof & \functionhln{latex-proof} \\
  latex-theory-view & \functionhln{collect-theories}$^\dagger$,
                      \functionhln{latex-theory-view} \\
  latex-set-linelength & \\ \hline
\end{tabularx}

\begin{lispfunction}{alltt-proof}{file terse?}
\end{lispfunction}

\begin{lispfunction}{latex-theory}{theoryname filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-pvs-file}{filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-usingchain}
  {theoryname filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-proof}{texfile \ampoptional terse? show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-theory-view}
  {theoryname filename viewer \ampoptional show-subst}
\end{lispfunction}


\subsubsection{Display Commands}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  x-theory-hierarchy & \functionhln{collect-theories}$^\dagger$,
                       \functionhln{x-module-hierarchy}\\
  x-show-proof & \functionhln{call-x-show-proof-at} \\
  x-show-current-proof & \functionhln{call-x-show-proof} \\
  x-prover-commands & \functionhln{x-prover-commands} \\ \hline
\end{tabularx}

\begin{lispfunction}{x-module-hierarchy}
  {theoryname \ampoptional include-libraries?}
\end{lispfunction}

\begin{lispfunction}{call-x-show-proof-at}{filename declname line origin}
\end{lispfunction}

\begin{lispfunction}{call-x-show-proof}{}
\end{lispfunction}

\begin{lispfunction}{x-prover-commands}{}
\end{lispfunction}


\subsubsection{Context}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  list-pvs-files & \\
  list-theories & \functionhln{context-files-and-theories} \\
  change-context & \functionhln{pvs-current-directory}$^\dagger$,
                   \functionhln{change-context} \\
  save-context & \functionhln{save-context} \\
  pvs-remove-bin-files & \\
  pvs-dont-write-bin-files & \\
  pvs-do-write-bin-files & \\
  context-path & \functionhln{pvs-current-directory} \\ \hline
\end{tabularx}

\begin{lispfunction}{context-files-and-theories}{\ampoptional context}
\end{lispfunction}

\begin{lispfunction}{change-context}{directory}
\end{lispfunction}

\begin{lispfunction}{save-context}{}
\end{lispfunction}

\begin{lispfunction}{pvs-current-directory}{}
\end{lispfunction}


\subsubsection{Browsing}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  show-declaration & \functionhln{show-declaration} \\
  find-declaration & \functionhln{find-declaration} \\
  whereis-declaration-used & \functionhln{whereis-declaration-used} \\
  list-declarations & \functionhln{collect-theories}$^\dagger$,
                      \functionhln{list-declarations} \\
  show-expanded-form & \functionhln{show-expanded-form} \\ \hline
\end{tabularx}

\begin{lispfunction}{show-declaration}{oname origin pos \ampoptional x?}
\end{lispfunction}

\begin{lispfunction}{find-declaration}{string}
\end{lispfunction}

\begin{lispfunction}{whereis-declaration-used}
  {oname origin pos \ampoptional x?}
\end{lispfunction}

\begin{lispfunction}{list-declarations}{theoryref}
\end{lispfunction}

\begin{lispfunction}{show-expanded-form}
  {oname origin pos1 \ampoptional (pos2 pos1) all?}
\end{lispfunction}


\subsubsection{Status}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  status-theory & \functionhln{collect-theories}$^\dagger$,
                  \functionhln{status-theory} \\
  status-pvs-file & \functionhln{status-pvs-file} \\
  status-importchain & \functionhln{collect-theories}$^\dagger$,
                       \functionhln{status-importchain} \\
  status-importbychain & \functionhln{collect-theories}$^\dagger$,
                         \functionhln{status-importbychain} \\
  show-theory-warnings & \functionhln{collect-theories}$^\dagger$,
                         \functionhln{show-theory-warnings} \\
  show-pvs-file-warnings & \functionhln{show-pvs-file-warnings} \\
  show-theory-messages & \functionhln{collect-theories}$^\dagger$,
                         \functionhln{show-theory-messages} \\
  show-pvs-file-messages & \functionhln{show-pvs-file-messages} \\
  show-theory-conversions & \functionhln{collect-theories}$^\dagger$,
                            \functionhln{show-theory-conversions} \\
  show-pvs-file-conversions & \functionhln{show-pvs-file-conversions} \\
  status-proof & \functionhln{proof-status-at} \\
  status-proof-theory & \functionhln{collect-theories}$^\dagger$,
                        \functionhln{status-proof-theory} \\
  status-proof-pvs-file & \functionhln{status-proof-pvs-file} \\
  status-proof-importchain & \functionhln{collect-theories}$^\dagger$,
                             \functionhln{status-proof-importchain} \\
  status-proofchain & \functionhln{proofchain-status-at} \\
  status-proofchain-theory & \functionhln{collect-theories}$^\dagger$,
                             \functionhln{status-proofchain-theory} \\
  status-proofchain-pvs-file & \functionhln{status-proofchain-pvs-file} \\
  status-proofchain-importchain & \functionhln{collect-theories}$^\dagger$,
                                  \functionhln{status-proofchain-importchain} \\ \hline
\end{tabularx}

\begin{lispfunction}{status-theory}{theoryref}
\end{lispfunction}

\begin{lispfunction}{status-pvs-file}{filename}
\end{lispfunction}

\begin{lispfunction}{status-importchain}{theory}
\end{lispfunction}

\begin{lispfunction}{status-importbychain}{theory}
\end{lispfunction}

\begin{lispfunction}{show-theory-warnings}{theoryname}
\end{lispfunction}

\begin{lispfunction}{show-pvs-file-warnings}{filename}
\end{lispfunction}

\begin{lispfunction}{show-theory-messages}{theoryname}
\end{lispfunction}

\begin{lispfunction}{show-pvs-file-messages}{filename}
\end{lispfunction}

\begin{lispfunction}{show-theory-conversions}{theoryname}
\end{lispfunction}

\begin{lispfunction}{show-pvs-file-conversions}{filename}
\end{lispfunction}

\begin{lispfunction}{proof-status-at}
  {filename declname line \ampoptional \textup{(}origin \textup{"pvs"}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{status-proof-theory}{theoryname}
\end{lispfunction}

\begin{lispfunction}{status-proof-pvs-file}{filename}
\end{lispfunction}

\begin{lispfunction}{status-proof-importchain}{theoryname}
\end{lispfunction}

\begin{lispfunction}{proofchain-status-at}
  {filename declname line \ampoptional \textup{(}origin \textup{"pvs"}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{status-proofchain-theory}{theoryname}
\end{lispfunction}

\begin{lispfunction}{status-proofchain-pvs-file}{filename}
\end{lispfunction}

\begin{lispfunction}{status-proofchain-importchain}{theoryname}
\end{lispfunction}


\subsubsection{Environment}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  whereis-pvs & \\
  pvs-version & \\
  pvs-log & \\
  pvs-mode & \\
  status-display & \\
  pvs-status & \\
  remove-popup-buffer & \\
  pvs & \functionhln{pvs-init} \\
  pvs-load-patches & \functionhln{load-pvs-patches} \\
  pvs-interrupt-subjob & \\
  reset-pvs & \\ \hline
  report-pvs-bug & \\ \hline
\end{tabularx}

\begin{lispfunction}{pvs-init}
  {\ampoptional dont-load-patches dont-load-user-lisp}
\end{lispfunction}

\begin{lispfunction}{load-pvs-patches}{}
\end{lispfunction}


\subsubsection{Exiting}
\noindent\begin{tabularx}{\linewidth}{|>{\itshape\ttfamily}l|>{\raggedright\arraybackslash}X|}\hline
  suspend-pvs & \functionhln{save-context} \\
  exit-pvs & \functionhln{exit-pvs} \\ \hline
\end{tabularx}

\begin{lispfunction}{exit-pvs}{}
\end{lispfunction}


\subsection{Other Lisp Functions invoked by Emacs}

Aside from the PVS commands, there are Lisp functions invoked from Emacs
indirectly, usually due to buffer-specific key bindings.  Here we list
such functions, under the associated buffers.

\begin{lispfunction}{pvs-select-proof}{num}
\end{lispfunction}

\begin{lispfunction}{pvs-view-proof}{num}
\end{lispfunction}

\begin{lispfunction}{pvs-delete-proof}{num}
\end{lispfunction}

\begin{lispfunction}{whereis-identifier-used}{string}
\end{lispfunction}

\begin{lispfunction}{status-proof-theories}{theories}
\end{lispfunction}

\begin{lispfunction}{theory-status-string}{theoryref}
\end{lispfunction}

\begin{lispfunction}{full-status-theory}{theoryname}
\end{lispfunction}

\begin{lispfunction}{show-all-proofs-file}{proofs outstr valid?}
\end{lispfunction}

\begin{lispfunction}{show-all-proofs-theory}{theory proofs outstr valid?}
\end{lispfunction}

\begin{lispfunction}{usedby-proofs}{bufname origin line}
\end{lispfunction}

\begin{lispfunction}{get-decl-at-origin}{bufname origin line}
\end{lispfunction}

\begin{lispfunction}{set-proofs-default}{line}
\end{lispfunction}

\begin{lispfunction}{proofs-delete-proof}{line}
\end{lispfunction}

\begin{lispfunction}{proofs-rename}{line id}
\end{lispfunction}

\begin{lispfunction}{proofs-show-proof}{line}
\end{lispfunction}

\begin{lispfunction}{proofs-change-description}{line description}
\end{lispfunction}

\begin{lispfunction}{proofs-rerun-proof}{line}
\end{lispfunction}

\begin{lispfunction}{proofs-edit-proof}{line}
\end{lispfunction}

\begin{lispfunction}{load-prelude-library}{lib \ampoptional force?}
\end{lispfunction}

\begin{lispfunction}{list-pvs-libraries}{}
\end{lispfunction}

\begin{lispfunction}{remove-prelude-library}{lib}
\end{lispfunction}

\begin{lispfunction}{list-prelude-libraries}{}
\end{lispfunction}

\begin{lispfunction}{latex-theory}{theoryname filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-pvs-file}{filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-usingchain}
  {theoryname filename \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-proof}{texfile \ampoptional terse? show-subst}
\end{lispfunction}

\begin{lispfunction}{alltt-proof}{file terse?}
\end{lispfunction}

\begin{lispfunction}{latex-theory-view}
  {theoryname filename viewer \ampoptional show-subst}
\end{lispfunction}

\begin{lispfunction}{latex-proof-view}
  {texfile viewer \ampoptional terse? show-subst}
\end{lispfunction}

\subsection{ILISP}

\subsection{Batch Mode}

\subsection{The Tcl/Tk Interface}
\label{tcl-tk-interface}

\subsection{Debugging Emacs}

There are many useful techniques for debugging Emacs code, some of these
are listed in the GNU Emacs Lisp Reference Manual~\cite{Elisp}.  We will
not discuss those techniques further; here we list some other techniques
specific to PVS.

The \texttt{pvs} buffer shows the interaction between Emacs and Lisp.  By
default, it only shows the last 15000 characters; if more are needed set
the Emacs global variable \globalnm{comint-log-size} to a larger value.



\section{Prover Interaction}
\label{prover-interaction}

The basic interaction of the prover is to print the \texttt{Rule?}
prompt, read the input, process it, and print a commentary and the new
current sequent.  This is repeated until the proof is completed, or the
user quits.

The input is similar to lisp, and consists of balanced parentheses,
keywords (identifiers starting with a colon), identifiers, strings, etc.
Note that the input is not processed until a proper form is sent.  Thus it
is important for parentheses and string quotes to be balanced properly.
If running from Emacs with the ILISP interface (the default), the form is
not sent to lisp until it is balanced.  In the raw interface, it is read
as soon as there is a balanced prefix.  Hence with Emacs,
\texttt{(grind))} will not be processed, while in raw mode, \texttt{grind}
will be processed, followed by the warning
\begin{alltt}
Warning: ignoring extra right parenthesis on
         #<TERMINAL-SIMPLE-STREAM [initial terminal io] fd 0/1>
\end{alltt}
When balanced input is received, it is checked to see that it is a valid
prover command, and that the arguments are of the correct form.

The command is then processed, comentary is output, followed by the next
sequent, if any.

\subsection{Proof Commentary}

Proof commentary consists of command commentary and proofstate
commentary.  The command commentary is specific to the given rule or
strategy.  In many cases, it is simply the \texttt{format} string applied
to the given arguments.  But it may consist of more, for example
\texttt{assert} reports on the auto-rewrites that it does, depending on
the settings of \globalnm{*rewrite-print-depth*} and
\globalnm{*rewrite-print-length*}.  Warnings and errors maya also be
output.  After the command commentary, proofstate commentary is output.
This indicates the results of the preceding command, such as if there was
no change, how many subgoals were generated, etc.  Here is a complete list
of such messages.

\noindent\begin{tabular}{|>{\tt}l|l|}\hline
which is trivially true. & the current branch is proved \\
this yields \tilde a subgoals: & command generated subgoals \\
this simplifies to:  & one subgoal was generated \\
% Subgoal completed & \\
No change. False TCCs: & proofstate is unchanged because of false TCCs \\
No change on: \tilde s & proofstate is unchanged \\
Q.E.D. & The formula is proved \\
Failed! & The formula is known to be false (rare) \\
% Bad rule: \tilde a \\
\hline
\end{tabular}

For simple rules, the commentary is relatively easy to predict, but for
complex derived rules and strategies, things get more complicated,
especially if they use control based on failure and backtracking.  In
general, derived rules keep a stack of error messages, and only outputs
the last few error messages if the command fails completely.

\subsection{The Current Sequent}

After the commentary, the formula and branch number of the current sequent
are presented, and then the sequent itself, followed by the \texttt{Rule?}
prompt.  The formula and branch number is of the form
\begin{alltt}
  fname.1.2.2
\end{alltt}
where \texttt{fname} is the name of the formula being proved, and the
numbers following indicate the branch the sequent is on.  This may be
followed by \texttt{(TCC)} if the sequent is a TCC branch.

\subsection{An Example}

The following example illustrates what can happen with \texttt{grind}:
\begin{alltt}
FF :  

  |-------
\{1\}   F(17, 17)

Rule? (grind)
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
FF :  

  |-------
[1]   F(17, 17)

Rule? (grind)
The following errors occurred within the strategy:

Couldn't find a suitable quantified formula.

No suitable (+ve FORALL/-ve EXISTS) quantified expression found.

No change on: (grind)
FF :  

  |-------
[1]   F(17, 17)

Rule?
\end{alltt}
Note that the first invocation of \texttt{grind} simply outputs the
command commentary, and indicates that a single new subgoal was
generated.  Note that the sequent looks identical; the change is due to
the updated state of the decision procedure, which is not directly
visible.  The second invocation results in no change, and the commentary
attempts to explain why.  In this case, \texttt{grind} invokes
\texttt{bash}, whose definition is
\begin{alltt}
  (then (assert :let-reduce? let-reduce?) (bddsimp)
   (if if-match
       (let ((command
              (generate-instantiator-command if-match polarity?
                instantiator)))
         command)
     (skip))
   (repeat (then (skolem-typepred) (flatten)))
   (lift-if :updates? updates?))
\end{alltt}
The \texttt{lift-if} does not give an error, but the preceding
\texttt{skolem-typepred} does, and it is that error that is made visible.
Of course, all errors may be seen by running \texttt{grind\$}.

\subsection{Prover Interaction without Emacs}

Though the prover was designed for interaction, there is nothing in its
design or implementation that assumes a human using Emacs is part of the
interaction.  Thus in principle it should be possible to use the prover as
the back end to a symbolic algebra package~\cite{Maple-PVS:TPHOLS01}, or
as a client to a web based proof tool.  In this section we discuss some of
the factors involved in using the prover as a back end.  Note that this
section does not deal with noninteractive back end use of the prover, as
supported by the functions \functionhtgt{prove-as-black-box} or
\functionhtgt{prove-formula-decl}, which take a formula and a strategy and
simply run it in the backgroud.

The Emacs interface is quite simple; it just waits for the \texttt{Rule?}
prompt, and sends the next input when it is seen.  All other output is
simply displayed, without attempting to match it.  Unfortunately, external
systems may want to separately display the sequent, the commentary, and
the input, and determine the prooftree structure.

Recognizing the proof sequent itself would not be too difficult, but there
is a much easier way than figuring out the pattern.  The proofstate and
associated sequent are actually printed using the Common Lisp
\functionnm{print-object} methods.  New \texttt{:around} methods may
easily be defined that make it simple to find the components of the
proofstate.  For example,
\begin{alltt}
  (defmethod print-object :around ((ps proofstate) stream)
    (format stream "\tilde\%-------Proofstate Start--------")
    (call-next-method)
    (format stream "\tilde\%-------Proofstate End--------"))

  (defmethod print-object :around ((sequent sequent) stream)
    (format stream "\tilde\%-------Sequent Start--------")
    (call-next-method)
    (format stream "\tilde\%-------Sequent End--------"))
\end{alltt}
With these definitions, the output looks like
\begin{alltt}
  Rule? (grind)
  Trying repeated skolemization, instantiation, and if-lifting,
  this simplifies to: 
  -------Proofstate Start--------
  FF.1 :  

  -------Sequent Start--------
  [-1]  F(17, 16)
    |-------
  [1]   F(17, 17)

  -------Sequent End--------
  -------Proofstate End--------
  Rule?
\end{alltt}
It is now obvious how to find the branching number and the sequent.

\subsection{Proof Tree Display}

Creating a prooftree corresponding to the proofstate is not as
straightforward.  The branching number helps, but it only changes when
more than one subgoal is generated.  Also this doesn't help much when
\texttt{undo} or \texttt{postpone} are used.

The current proof tree display is generated by creating Tcl/Tk commands
that are interpreted using the \texttt{pvs-support.tcl} file loaded into a
Tcl/Tk subprocess of Emacs.  The lisp functions for supporting this are
currently closely integrated with the specific Tcl/Tk functions.  Rather
than try and describe those here, we will in the future separate the code
that determines the prooftree structure from the Tcl/Tk specific code.
The generic code will be defined so that it will be easy to provide hooks
to alternate interfaces.\footnote{The recent releases of Allegro Common
Lisp have builtin Gtk functions, which we intend to make use of, as it is
a better alternative, since the functions are in Lisp, and do not require
the Emacs or Tcl/Tk processes in order to run.}

\begin{globalvar}{*start-proof-display*}
If this is set to \texttt{t} at the beginning of a a proof, then the
prover will invoke \functionhln{call-x-show-proof} to initialize the proof
display.  Note that \functionhln{call-x-show-proof} is also invoked by the
Emacs commands \functionhln{x-show-current-proof} and
\functionhln{x-show-proof}.
\end{globalvar}

\begin{globalvar}{*displaying-proof*}
A list of integers, representing the proofs currently being displayed.
Multiple proofs may be dislpayed, and each is given a unique integer
identifier.
\end{globalvar}

\begin{globalvar}{*current-displayed*}
The proofstate currently being displayed.  See
\functionhln{display-proofstate} for its use.
\end{globalvar}

\begin{globalvar}{*flush-displayed*}
When undo is invoked, \globalnm{*flush-displayed*} is set to the resulting
proofstate.
\end{globalvar}

\begin{lispfunction}{call-x-show-proof}{}
\end{lispfunction}

\begin{lispfunction}{display-proofstate}{proofstate}
This function is called by the \functionhln{proofstepper} when the
proofstate is not a strat-proofstate, and either it is a root or it has an
associated rule or input.  Essentially, this means that the proofstate is
stable, and the prover is not currently working on a state that may
potentially fail and disappear.  In addition, this function checks that
\globalnm{*in-apply*} is \texttt{nil}, and that
\globalnm{*displaying-proof*} and \globalnm{*current-displayed*} are set.

The given \functionarg{proofstate} is compared to
\globalnm{*current-displayed*} and if they are different,
\functionhln{dislpay-proof-from} is invoked on
\globalnm{*flush-displayed*} if it is set, and
\globalnm{*current-displayed*} otherwise.  \globalnm{*flush-displayed*} is
set to \texttt{nil}.
\end{lispfunction}

\begin{lispfunction}{display-proof-from}{ps}
This function creates a file with a series of Tcl/Tk commands that results
in updating the prooftree display.  See Appendix~\ref{prooftree-example}
for details.
\end{lispfunction}

\begin{lispfunction}{wish-done-proof}{proofstate}
When \globalnm{*in-apply*} is \texttt{nil}, and
\globalnm{*displaying-proof*} is set, this sends the form
\begin{alltt}
  proof-done \functionarg{fid thid path}
\end{alltt}
to indicate that that path of the proof tree is complete.
\end{lispfunction}

If you wish to create a different form of display than Tcl/Tk under Emacs,
probably the simplest thing to do is to have PVS generate the forms above,
and interpret them in a different display engine.  To do this, set
\globalnm{*start-proof-display*} to \texttt{t}, redefine
\functionhln{pvs-wish-source} to simply print the file name in an easily
interceptable form, and read the files to create your own display.
A complete example is given in Appendix~\ref{prooftree-example}


\section{Replacing Emacs with a Different Interface}

Here we discuss what is needed to replace Emacs with another interface.
There are several reasons that one might want to do this.  For example, to
provide PVS as a proof engine within a system that already has a user
interface, as was done in the Maple interface~\cite{maple}.  Another
reason is to provide an interface on an operating system that does not
directly support PVS, and use remote procedure calls to interact.  PVS
could also act as a client on a web server.

\subsection{Invoking PVS without Emacs}

The \texttt{pvs} shell script takes a \texttt{-raw} flag that starts up
the PVS lisp image directly.  However, some initialization must be done
before the image is ready.  In particular, the package should be set to
\texttt{:pvs}, and  \functionhln{pvs-init} must be invoked.

In this mode, PVS acts as a standard interactive unix process, reading
\texttt{stdin}, and outputing to \texttt{stdout} and \texttt{stderr}.

Once the pvs process is started, it prints out the prompt as described
above, and waits for input.

\subsection{Remote PVS Interface}

In some cases it may be desirable to use PVS remotely, for example if
one wants to use a windows machine and connect to an interface defined
there.

Doing this requires setting up an RPC connection, as described in
\url{http://www.franz.com/support/documentation/6.2/doc/rpc.htm}.

\subsection{PVS as a Client}


\chapter{The Middle: Internal Structures and Functions}

As described in the PVS prover guide~\cite{PVS:prover}, strategies are
defined using the Lisp macro \texttt{defstep}.  Simple strategies are
quite easy to write, for instance a strategy that repeatedly tries to
\texttt{grind} and \texttt{apply-extensionality} may be written as
\begin{alltt}
  (repeat (then (grind) (apply-extensionality)))
\end{alltt}
More complex strategies need to analyze the formulas of the sequent,
create new terms, and build proof commands for subsequent prover
invocation.  The \texttt{let} and \texttt{if} strategies provide the basic
support for this, but the key parts of these strategies are arbitrary Lisp
functions.  One of the purposes of this document is to describe the
functions that are most useful for writing complex, domain-specific
strategies.

In addition, we will describe techniques for writing robust strategies,
providing useful error messages, and debugging.

A familiarity with Lisp is assumed, including the Common Lisp Object
System (CLOS)~\cite{Steele:commonlisp}, on which most of the PVS data
structures are build, including terms, types, formulas, theories,
sequents, and proofstates.

\section{PVS Classes}

In CLOS, there are classes and generic functions.  Classes form a
hierarchy and define slots.  Generic functions may be applied to arguments
of specific classes.  Thus the type of an expression my be obtained by
applying the generic function \texttt{type} to the expression.  If
\texttt{type} is applied to a type expression or a theory, it results in a
Lisp error, as it is not defined on instances of those classes.  Note that
this approach to objects differs from the usual, in that methods are not
viewed as belonging to a class.  This has the advantage that binary
methods can be easily defined.

\begin{macro}{defcl}{name classes \amprest args}
In PVS, classes are defined using the \texttt{defcl} macro, which in
addition to defining the class, creates a recognizer for the class,
updates the \globalhln{*slot-info*} global variable, and defines
\functionnm{untc*} methods.  Thus
\begin{alltt}
  (defcl number-expr (expr)
    number)
\end{alltt}
creates the \texttt{number-expr} class as a subclass of the \texttt{expr}
class, with the slot \texttt{number} (and whatever slots are defined by
\texttt{expr} and its superclasses).  Slots defined with \texttt{defcl}
also have accessor, initarg, and initform values defined.  In addition,
the recognizer \texttt{number-expr?} is defined.  It returns \texttt{t}
when applied to an object of class \texttt{number-expr} and \texttt{nil}
otherwise.
\end{macro}

\begin{globalvar}{*slot-info*}
\end{globalvar}

The descriptions of the classes given below are intensionally incomplete,
as it is complex enough without giving all the details.  

Similarly, many of the slots used for secondary purposes such as caching
information are not described, though they will be seen if the
Lisp \texttt{describe} function is used.

A \emph{mixin} class\index{mixin class} is one that is intended to serve
as a common superclass for more specialized classes, and not intended to
have instances created for it.  A mixin serves several purposes:
\begin{itemize}
\item it collects common slots into a single class, as with the
\classnm{declaration} class,
\item it provides a general type for the class, for example, the
\texttt{declaration?} test is often used,
\item it allows methods to be no more specialized than they need be, and
\item even when methods need to be specialized, it often is the case that
a method may be defined for the mixin, and \texttt{call-next-method} used
for uniform processing of the common aspects of the specialized classes.
\end{itemize}

Similarly, many subclasses primarily exist for the purpose of
prettyprinting---for example, the difference between \texttt{x+1} and
\texttt{+(x,1)} is in the classes each instance is associated with.  Both
are \classnm{application} instances, though the former is actually an
instance of the subclass \classnm{infix-application}.  This makes no
difference to the typechecker or the prover, only to the various display
tools (e.g., the prettyprinter and \latex printer).  A \emph{display}
class\index{display class} is thus one that instances may be created for,
but rarely should methods be specialized on these classes, unless, of
course, they are concerned with prettyprinting or other forms of display.

In the following sections we list all classes, their supertypes, and their
slots.  For each class, we indicate whether it is a mixin or display
class.  Slots may be marked with an asterisk (*), indicating they are set
during parsing.

\subsection{Syntax Class}

\begin{class}{syntax}{mixin}{}{\slotidx{pvs-sxhash-value} & a fixnum}
This is a mixin class, for objects associated with the abstract syntax.
The \textit{pvs-sxhash-value} is the value of calls to
\texttt{pvs-sxhash}, unless free variables occur in the term.
\end{class}

\subsection{Specification Classes}

\input{bnf-theory}

\begin{class}{datatype-or-module}{mixin}{\classhln{syntax}}
{\slotidx{id}$^*$ & a symbol, the identifier of the top-level recursive
        type or theory \\
 \slotidx{formals}$^*$ & a list of \classnm{formal-decl}s and/or
        \classnm{importing}s \\ 
 \slotidx{formals-sans-usings} & a list of \classnm{formal-decl}s \\
 \slotidx{assuming}$^*$ & a list of \classnm{declaration}s and/or
        \classnm{importing}s \\ 
 \slotidx{filename} & a string, the base name of the file (without
        directory or extension) \\
 \slotidx{status} & a list of symbols, \texttt{'parsed} and/or
        \texttt{'typechecked} \\
 \slotidx{generated-by} & an identifier if this was generated by a theory
        or recursive type, nil otherwise \\
 \slotidx{tcc-comments} & an association list declarations to TCC strings
        representing trivial or subsumed TCCs \\
 \slotidx{info} & a list of strings \\
 \slotidx{warnings} & a list of strings \\
 \slotidx{conversion-messages} & a list of strings \\
 \slotidx{all-declarations} & the list of declarations (no importings)
        from the formals, assumings, and theory part of the module \\
 \slotidx{all-imported-theories} & a list of all the imported theories \\
 \slotidx{all-imported-names} & a list of modnames corresponding to the
        \slotnm{all-imported-theories} \\
 \slotidx{places} & an \texttt{eq} hash-table providing the place for each
        subterm of this module }

This class is a superclass of \classnm{module} and
\classnm{recursive-type}.  These are the top level entities contained in a
PVS file.
\end{class}

\subsubsection{Recursive Types}

This section describes the recursive types.  In PVS 3.0 an implementation
of an experimental version of codatatypes (final coalgebras) was
introduced, though they were not really announced, since they are going to
change.  The syntax is currently the same as for datatypes, but using the
keyword \texttt{CODATATYPE}.  This is definitely going to change in the
future, though the underlying data structures may be retained.

\input{bnf-adts}

\begin{class}{recursive-type}{mixin}{\classhln{datatype-or-module}}
{\slotidx{importings}$^*$ & a list of importings \\
 \slotidx{constructors}$^*$ & a list of \texttt{adt-constructor}s \\
 \slotidx{adt-type-name} & a type name constructed for the recursive type \\
 \slotidx{adt-theory} & the generated (co-)datatype theory \\
 \slotidx{adt-map-theory} & the generated map theory (nil if not generated) \\
 \slotidx{adt-reduce-theory} & the generated reduce theory \\
 \slotidx{generated-file-date} & a date in universal time \\
 \slotidx{positive-types} & a list of \classnm{type-name}s corresponding
        to the positive type parameters of the generated \slotnm{adt-theory} \\
 \slotidx{semi}$^*$ & flag indicating whether the recursive type was followed
        by a semi-colon }

The \classnm{recursive-type} is the mixin for datatypes and co-datatypes.  
\end{class}

\begin{class}{recursive-type-with-subtypes}{mixin}{\classhln{recursive-type}}
{\slotidx{subtypes} & a list of identifiers}

This is the mixin for \classnm{recursive-type}s that are declared
\texttt{WITH} \texttt{SUBTYPES}. 
\end{class}

\begin{class}{inline-recursive-type}{mixin}{\classhln{recursive-type}}
{\slotidx{generated} & the list of declarations generated during
        typechecking.  These are the declarations that go in the generated
        adt-theory of a top level recursive type \\
 \slotidx{typechecked?} & a flag indicating whether the recursive type has
        been typchecked }

This is the mixin for recursive types declared inside a theory.  In many
respects they are like a declaration.
\end{class}

\paragraph{Datatypes}{\ }

\begin{class}{datatype}{}{\classhln{recursive-type}}{}
This is the datatype subclass of recursive types.
\end{class}

\begin{class}{inline-datatype}{}
  {\classhln{inline-recursive-type} \classhln{datatype}}{}
The inline version of datatypes.
\end{class}

\begin{class}{datatype-with-subtypes}{}
  {\classhln{recursive-type-with-subtypes} \classhln{datatype}}{}
The datatype with subtypes
\end{class}

\begin{class}{inline-datatype-with-subtypes}{}{\classhln{inline-datatype} \classhln{datatype-with-subtypes}}{}
\end{class}

\begin{class}{enumtype}{}{\classhln{inline-datatype}}{}
\end{class}

\paragraph{Codatatypes}{\ }

\begin{class}{codatatype}{}{\classhln{recursive-type}}{}
\end{class}

\begin{class}{inline-codatatype}{}{\classhln{inline-recursive-type} \classhln{codatatype}}{}
\end{class}

\begin{class}{codatatype-with-subtypes}{}{\classhln{codatatype} \classhln{recursive-type-with-subtypes}}{}
\end{class}

\begin{class}{inline-codatatype-with-subtypes}{}{\classhln{inline-codatatype} \classhln{codatatype-with-subtypes}}{}
\end{class}

\paragraph{Recursive Type Constructors}{\ }

\begin{class}{adt-constructor}{}{\classhln{syntax}}
{\slotidx{recognizer} & a symbol \\
 \slotidx{ordnum} & a number}
\end{class}

\begin{class}{constructor-with-subtype}{}{\classhln{simple-constructor}}
{\slotidx{subtype} & \\}
\end{class}

\begin{class}{simple-constructor}{}{\classhln{adt-constructor}}
{\slotidx{id} & a symbol \\
 \slotidx{arguments} & a list of \\
 \slotidx{con-decl} & the generated constructor const-decl \\
 \slotidx{rec-decl} & the generated recognizer const-decl \\
 \slotidx{acc-decls} & the list of generated accessor const-decls}
\end{class}

\subsubsection{Theories}

\begin{class}{module}{}{\classhln{datatype-or-module}}
{\slotidx{theory} & the declarations of the theory part \\
 \slotidx{exporting} & an exporting \\
 \slotidx{nonempty-types} & a list of type expressions \\
 \slotidx{all-usings} & a list of modnames \\
 \slotidx{immediate-usings} & a list of modnames \\
 \slotidx{instances-used} & a list of modnames \\
 \slotidx{assuming-instances} & a list of modnames \\
 \slotidx{used-by} & a list of symbols \\
 \slotidx{saved-context} & a context \\
 \slotidx{dependent-known-subtypes} & a list of type expressions \\
 \slotidx{macro-expressions} & a list of expressions \\
 \slotidx{tccs-tried?} & a flag \\
 \slotidx{modified-proof?} & a flag \\
 \slotidx{tcc-info} & a list of four integers \\
 \slotidx{ppe-form} & a string \\
 \slotidx{tcc-form} & a string \\
 \slotidx{typecheck-time} & an integer}
\end{class}

\subsubsection{Library Theories and Recursive Types}

\begin{class}{library-datatype-or-theory}{}{\classhln{datatype-or-module}}
{\slotidx{lib-ref} & a string}
\end{class}

\begin{class}{library-datatype}{}{\classhln{datatype} \classhln{library-datatype-or-theory}}{}
\end{class}

\begin{class}{library-codatatype}{}{\classhln{codatatype} \classhln{library-datatype-or-theory}}{}
\end{class}

\begin{class}{library-theory}{}{\classhln{module} \classhln{library-datatype-or-theory}}{}
\end{class}

\subsubsection{Interpreted Theories}

\begin{class}{theory-interpretation}{}{\classhln{module}}
{\slotidx{from-theory} & a theory \\
 \slotidx{mapping} & a mapping}
\end{class}

\subsubsection{Importings and Exportings}

\input{bnf-exporting}

\begin{class}{exporting}{}{\classhln{syntax}}
{\slotidx{names} & a list of modnames \\
 \slotidx{but-names} & a list of modnames \\
 \slotidx{kind} & a symbol: nil, all, closure, or default \\
 \slotidx{modules} & a list of modnames \\
 \slotidx{closure} & a list of modnames}
\end{class}

\begin{class}{expname}{}{\classhln{syntax}}
{\slotidx{id} & a symbol \\
 \slotidx{kind} & a symbol \\
 \slotidx{type} & a type expression}
\end{class}

\begin{class}{importing}{}{\classhln{syntax}}
{theory-name
 semi
 chain?
 refers-to
 generated
 tcc-form
 saved-context}
\end{class}

\subsection{Declaration Classes}

\input{bnf-theory-part}

\input{bnf-decls}

\begin{class}{declaration}{}{\classhln{syntax}}
{\slotidx{newline-comment} & \\
 \slotidx{id} & \\
 \slotidx{formals} & \\
 \slotidx{module} & \\
 \slotidx{refers-to} & \\
 \slotidx{referred-by} & \\
 \slotidx{chain?} & \\
 \slotidx{typechecked?} & \\
 \slotidx{visible?} & \\
 \slotidx{generated} & \\
 \slotidx{generated-by} & \\
 \slotidx{semi} & \\
 \slotidx{tcc-form} & \\
 \slotidx{typecheck-time} & }
\end{class}

\begin{class}{typed-declaration}{}{\classhln{declaration}}
{\slotidx{declared-type} & \\
 \slotidx{declared-type-string} & \\
 \slotidx{type} & }
\end{class}

\subsubsection{Type Declarations}

\begin{class}{type-decl}{}{\classhln{declaration}}
{\slotidx{type-value} & }
\end{class}

\begin{class}{nonempty-type-decl}{}{\classhln{type-decl}}
{\slotidx{keyword} & }
\end{class}

\begin{class}{type-def-decl}{}{\classhln{type-decl}}
{\slotidx{type-expr} & \\
 \slotidx{contains} & }
\end{class}

\begin{class}{nonempty-type-def-decl}{}{\classhln{type-def-decl} \classhln{nonempty-type-decl}}{}
\end{class}

\begin{class}{type-eq-decl}{}{\classhln{type-def-decl}}{}
\end{class}

\begin{class}{nonempty-type-eq-decl}{}{\classhln{type-eq-decl} \classhln{nonempty-type-def-decl}}{}
\end{class}

\begin{class}{type-from-decl}{}{\classhln{type-def-decl}}{}
\end{class}

\begin{class}{nonempty-type-from-decl}{}{\classhln{type-from-decl} \classhln{nonempty-type-def-decl}}{}
\end{class}

\subsubsection{Formal Parameter Declarations}

\begin{class}{formal-decl}{}{\classhln{declaration}}
{\slotidx{dependent?} & }
\end{class}

\begin{class}{formal-type-decl}{}{\classhln{formal-decl} \classhln{type-decl} \classhln{typed-declaration}}{}
\end{class}

\begin{class}{formal-nonempty-type-decl}{}{\classhln{formal-type-decl} \classhln{nonempty-type-decl}}{}
\end{class}

\begin{class}{formal-subtype-decl}{}{\classhln{formal-type-decl} \classhln{type-from-decl}}{}
\end{class}

\begin{class}{formal-nonempty-subtype-decl}{}{\classhln{formal-subtype-decl} \classhln{nonempty-type-decl}}{}
\end{class}

\begin{class}{formal-const-decl}{}{\classhln{formal-decl} \classhln{typed-declaration}}
{\slotidx{possibly-empty-type?} & }
\end{class}

\begin{class}{formal-theory-decl}{}{\classhln{formal-decl}}
{\slotidx{theory-name} & \\
 \slotidx{generated-theory} & \\
 \slotidx{saved-context} & }
\end{class}

\subsubsection{Library Declarations}

\begin{class}{lib-decl}{}{\classhln{declaration}}
{\slotidx{lib-string} & \\
 \slotidx{lib-ref} & }
\end{class}

\subsubsection{Theory Declarations and Abbreviations}

\begin{class}{mod-decl}{}{\classhln{declaration}}
{\slotidx{modname} & \\
 \slotidx{generated-theory} & \\
 \slotidx{saved-context} & }
\end{class}

\begin{class}{theory-abbreviation-decl}{}{\classhln{declaration}}
{\slotidx{theory-name} & \\
 \slotidx{generated-theory} & \\
 \slotidx{saved-context} & }
\end{class}

\subsubsection{Variable Declarations}

\begin{class}{var-decl}{}{typed-\classhln{declaration}}{}
\end{class}

\subsubsection{Constant Declarations}

\begin{class}{const-decl}{}{\classhln{typed-declaration}}
{\slotidx{definition} & \\
 \slotidx{def-axiom} & \\
 \slotidx{eval-info} & }
\end{class}

\begin{class}{macro-decl}{}{\classhln{const-decl}}{}
\end{class}

\begin{class}{def-decl}{}{\classhln{const-decl}}
{\slotidx{declared-measure} & \\
 \slotidx{ordering} & \\
 \slotidx{measure} & \\
 \slotidx{measure-depth} & \\
 \slotidx{recursive-signature} & }
\end{class}

\subsubsection{(Co-)Inductive Definitions}

\begin{class}{fixpoint-decl}{}{\classhln{const-decl}}{}
\end{class}

\begin{class}{inductive-decl}{}{\classhln{fixpoint-decl}}{}
\end{class}

\begin{class}{corecursive-decl}{}{\classhln{const-decl}}{}
\end{class}

\begin{class}{coinductive-decl}{}{\classhln{fixpoint-decl}}{}
\end{class}

\subsubsection{Formula Declarations}

\input{bnf-assuming}

\begin{class}{formula-decl}{}{\classhln{declaration}}
{\slotidx{spelling} & \\
 \slotidx{definition} & \\
 \slotidx{closed-definition} & \\
 \slotidx{kind} & \\
 \slotidx{default-proof} & \\
 \slotidx{proofs} & }
\end{class}

\begin{class}{assuming-decl}{}{\classhln{formula-decl}}
{\slotidx{original-definition} & \\}
\end{class}

\paragraph{TCC Declarations}{\ }

\begin{class}{tcc-decl}{}{\classhln{formula-decl}}
{\slotidx{tcc-disjuncts} & \\
 \slotidx{importing-instance} & }
\end{class}

\begin{class}{subtype-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{termination-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{judgement-tcc}{}{\classhln{subtype-tcc}}{}
\end{class}

\begin{class}{existence-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{assuming-tcc}{}{\classhln{tcc-decl}}
{\slotidx{theory-instance} & \\
 \slotidx{generating-assumption} & }
\end{class}

\begin{class}{mapped-axiom-tcc}{}{\classhln{tcc-decl}}
{\slotidx{theory-instance} & \\
 \slotidx{generating-axiom} & }
\end{class}

\begin{class}{cases-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{well-founded-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{same-name-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{cond-disjoint-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{cond-coverage-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\begin{class}{monotonicity-tcc}{}{\classhln{tcc-decl}}{}
\end{class}

\subsubsection{Judgement Declarations}

\begin{class}{judgement}{}{\classhln{typed-declaration}}
{\slotidx{free-parameters} & \\
 \slotidx{free-parameter-theories} & }
\end{class}

\begin{class}{subtype-judgement}{}{\classhln{judgement}}
{\slotidx{declared-subtype} & \\
 \slotidx{subtype} & }
\end{class}

\begin{class}{number-judgement}{}{\classhln{judgement}}
{\slotidx{number-expr} & }
\end{class}

\begin{class}{name-judgement}{}{\classhln{judgement}}
{\slotidx{name} & }
\end{class}

\begin{class}{application-judgement}{}{\classhln{judgement}}
{\slotidx{name} & \\
 \slotidx{formals} & \\
 \slotidx{judgement-type} & }
\end{class}

\subsubsection{Conversion Declarations}

\begin{class}{conversion-decl}{}{\classhln{declaration}}
{\slotidx{k-combinator?} & \\
 \slotidx{expr} & \\
 \slotidx{free-parameters} & \\
 \slotidx{free-parameter-theories} & }
\end{class}

\begin{class}{conversionplus-decl}{}{\classhln{conversion-decl}}{}
\end{class}

\begin{class}{conversionminus-decl}{}{\classhln{conversion-decl}}{}
\end{class}

\subsubsection{Auto-rewrite Declarations}

\begin{class}{auto-rewrite-decl}{}{\classhln{declaration}}
{\slotidx{rewrite-names} & }
\end{class}

\begin{class}{auto-rewrite-plus-decl}{}{\classhln{auto-rewrite-decl}}{}
\end{class}

\begin{class}{auto-rewrite-minus-decl}{}{\classhln{auto-rewrite-decl}}{}
\end{class}

\paragraph{Rewrite Names}

Rewrite names are used for auto rewrite declarations, as well as many
prover commands.  The prover allows for distinction between definitions,
formula names, and formula sequent numbers, and between lazy, eager, and
macro rewrites.

\begin{class}{rewrite-elt}{mixin}{\classhln{syntax}}{}
\end{class}

\begin{class}{rewrite-name}{mixin}{\classhln{rewrite-elt} \classhln{name}}{}
\end{class}

\begin{class}{lazy-rewrite}{mixin}{\classhln{rewrite-elt}}{}
\end{class}

\begin{class}{eager-rewrite}{mixin}{\classhln{rewrite-elt}}{}
\end{class}

\begin{class}{macro-rewrite}{mixin}{\classhln{rewrite-elt}}{}
\end{class}

\begin{class}{constant-rewrite-name}{mixin}{\classhln{rewrite-name}}
{\slotidx{declared-type} & \\
 \slotidx{type} & }
\end{class}

\begin{class}{formula-rewrite-name}{mixin}{\classhln{rewrite-name}}
{\slotidx{spelling} & }
\end{class}

\begin{class}{lazy-rewrite-name}{}{\classhln{rewrite-name} \classhln{lazy-rewrite}}{}
\end{class}

\begin{class}{eager-rewrite-name}{}{\classhln{rewrite-name} \classhln{eager-rewrite}}{}
\end{class}

\begin{class}{macro-rewrite-name}{}{\classhln{rewrite-name} \classhln{macro-rewrite}}{}
\end{class}

\begin{class}{lazy-constant-rewrite-name}{}{\classhln{constant-rewrite-name} \classhln{lazy-rewrite-name}}{}
\end{class}

\begin{class}{lazy-formula-rewrite-name}{}{\classhln{formula-rewrite-name} \classhln{lazy-rewrite-name}}{}
\end{class}

\begin{class}{eager-constant-rewrite-name}{}{\classhln{constant-rewrite-name} \classhln{eager-rewrite-name}}{}
\end{class}

\begin{class}{eager-formula-rewrite-name}{}{\classhln{formula-rewrite-name} \classhln{eager-rewrite-name}}{}
\end{class}

\begin{class}{macro-constant-rewrite-name}{}{\classhln{constant-rewrite-name} \classhln{macro-rewrite-name}}{}
\end{class}

\begin{class}{macro-formula-rewrite-name}{}{\classhln{formula-rewrite-name} \classhln{macro-rewrite-name}}{}
\end{class}

\begin{class}{fnum-rewrite}{mixin}{\classhln{rewrite-elt}}
{\slotidx{fnum} & }
\end{class}

\begin{class}{lazy-fnum-rewrite}{}{\classhln{fnum-rewrite} \classhln{lazy-rewrite}}{}
\end{class}

\begin{class}{eager-fnum-rewrite}{}{\classhln{fnum-rewrite} \classhln{eager-rewrite}}{}
\end{class}

\begin{class}{macro-fnum-rewrite}{}{\classhln{fnum-rewrite} \classhln{macro-rewrite}}{}
\end{class}

\subsection{Type Expression Classes}

\input{bnf-type-expr}

\begin{class}{type-expr}{mixin}{\classhln{syntax}}
{\slotidx{parens} & \\
 \slotidx{print-type} & \\
 \slotidx{from-conversion} & \\
 \slotidx{free-variables} & \\
 \slotidx{free-parameters} & \\
 \slotidx{nonempty?} & }
\end{class}

\begin{class}{type-name}{}{\classhln{type-expr} \classhln{name}}
{\slotidx{adt} & }
\end{class}

\begin{class}{adt-type-name}{}{\classhln{type-name}}
{\slotidx{adt} & \\
 \slotidx{recognizer-names} & \\
 \slotidx{struct-name} & }
\end{class}

\begin{class}{subtype}{}{\classhln{type-expr}}
{\slotidx{supertype} & \\
 \slotidx{top-type} & \\
 \slotidx{predicate} & }
\end{class}

\begin{class}{funtype}{}{\classhln{type-expr}}
{\slotidx{domain} & \\
 \slotidx{range} & }
\end{class}

\begin{class}{tupletype}{}{\classhln{type-expr}}
{\slotidx{types} & \\
 \slotidx{generated?} & }
\end{class}

\begin{class}{cotupletype}{}{\classhln{type-expr}}
{\slotidx{types} & \\
 \slotidx{generated?} & }
\end{class}

\begin{class}{recordtype}{}{\classhln{type-expr}}
{\slotidx{fields} & \\
 \slotidx{dependent?} & }
\end{class}

\begin{class}{field-decl}{}{\classhln{binding} \classhln{name}}
{\slotidx{chain?} & a boolean (\texttt{t} or \texttt{nil})}
\end{class}

\subsection{Expression Classes}

Expressions are all of class \texttt{expr}.  The recognizer for this class
is \texttt{expr?}.  In general, expressions may be created using
\texttt{pc-parse} as described above.  All expressions have a
\texttt{type} slot and a \texttt{types} slot.  The \texttt{types} slot
contains the possible types of the expression during typechecking, and
when typechecking is completed, it contains the ``best'' judgement type.
The \texttt{type} slot contains the actual type.  Thus if the number
expression \texttt{2} is typechecked, its \texttt{type} is
\texttt{number}, but its \texttt{types} is the list containing
\texttt{posint}.\footnote{This will change in the near future, as
judgement types are going to be handled differently.}

\input{bnf-expr}
\input{bnf-expr-aux}

\begin{class}{expr}{mixin}{\classhln{syntax}}
{\slotidx{type} & the type of the expression}
This is a mixin for expressions, as opposed to type expressions.
\end{class}

\begin{class}{name}{mixin}{\classhln{syntax}}
{\slotidx{id} & the identifier \\
 \slotidx{mod-id} & a theory identifier \\
 \slotidx{library} & a library identifier \\
 \slotidx{actuals} & a list of actual parameters \\
 \slotidx{mappings} & a list of mappings \\
 \slotidx{resolutions} & a list of resolutions, singleton if typechecked}
This is a mixin for names, i.e., \texttt{name-expr}s, \texttt{type-name}s,
\texttt{modname}s.  The \slotnm{id} is always given, and if typechecked,
the \texttt{resolutions} is set to a single resolution; during
typechecking, or in a call to \texttt{resolve} \texttt{resolutions} may
contain many resolutions.  All other slots are optional, and will not be
filled in by the typechecker.  So given the names
\begin{alltt}
  foo
  foo[x]
  th!foo
  lib@th[x]\{\{y := 3\}\}!foo
\end{alltt}  
In each case, the associated \texttt{name} will have an \textit{id} of
\texttt{foo}, the second and last one will have \textit{actuals}
They are used by the typechecker to
help determine a unique resolution.

The \texttt{id} slot is the identifier for the name.  A resolution
consists of a declaration and a theory instance, as well as caching the
type.  A typechecked name expression has only a single resolution, while a
partially typechecked one may have many.  Note that the \texttt{type} slot
is redundant in this case, as the type of the resolution is identical to
the \texttt{type} of the name expression.
\end{class}

\begin{class}{name-expr}{}{\classhln{name} \classhln{expr}}{}
Name expressions.
\end{class}
\begin{class}{field-application}{}{\classhln{expr}}%
{\slotidx{id} & identifier \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
A field application is the internal representation for record extraction,
e.g., \texttt{r`a} or \texttt{a(r)}.  In this case, \texttt{a} is the
\texttt{id}, \texttt{r} is the \texttt{argument}, and the actuals is
\texttt{nil}.
\end{class}

\begin{class}{projection-expr}{}{\classhln{name-expr}}%
{\slotidx{index} & the index number, an integer}
A \texttt{projection-expr} is of the form \texttt{PROJ\_$n$}, where $n$ is an
integer greater than $0$.  The \texttt{id} in this case is
\texttt{PROJ\_$n$}, and the \texttt{index} is $n$.  Projection-exprs also
allow actuals, e.g., \texttt{PROJ\_2[[int, boo, int]]} has an
\texttt{actual} consisting of a list with a tuple type element.
\end{class}

\begin{class}{projection-application}{}{\classhln{expr}}%
{\slotidx{id} & identifier \\
 \slotidx{index} & the index number, an integer \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
This is the class for projections of the form \texttt{t`2} or
\texttt{PROJ\_2(t)}.  These are not applications, because there is no
declaration associated with, e.g., \texttt{PROJ\_2}.  The form
\texttt{t`2} is actually of the subclass \texttt{projappl}, but this
subclass should only matter for prettyprinting and related purposes.
\end{class}

\begin{class}{adt-name-expr}{}{\classhln{name-expr}}{\slotidx{adt-type} & a type name}
A mixin for the \texttt{constructor-name-expr},
\texttt{recognizer-name-expr}, and \texttt{accessor-name-expr} classes.
During typechecking, if a \texttt{name-expr} is determined to be a
constructor, recognizer, or accessor of a datatype, it is changed to the
corresponding class (using \texttt{change-class}).  The \texttt{adt-type}
slot is the corresponding type-name, and is fully instantiated.  However,
it is computed lazily, so do not access it directly, instead use the
\texttt{adt} generic function.
\end{class}

\begin{class}{constructor-name-expr}{}{\classhln{adt-name-expr}}%
{\slotidx{recognizer-name} & associated recognizer \\
 \slotidx{accessor-names} & associated accessors}
This is an \texttt{adt-name-expr} (see above).  The
\texttt{recognizer-name} is the associated recognizer, fully instantiated,
and the \texttt{accessor-names} are similarly the associated accessors.
Both these slots are computed lazily, use the \texttt{recognizer} and
\texttt{accessors} functions instead of directly referencing these slots.
\end{class}

\begin{class}{recognizer-name-expr}{}{\classhln{adt-name-expr}}%
{\slotidx{constructor-name} & associated constructor \\
 \slotidx{unit?} & a unit recognizer flag}
This is an \texttt{adt-name-expr} (see above).  The
\texttt{constructor-name} is lazy, as described above, and should be
gotten using the \texttt{constructor} function, not directly.  The
\texttt{unit?} slot indicates whether this is a unit, i.e., whether the
associated constructor has arguments.  This is used by the prover to
handle enumeration types.
\end{class}

\begin{class}{accessor-name-expr}{}{\classhln{adt-name-expr}}{}
This is an \texttt{adt-name-expr} (see above).  It is important to note
that there is no associated constructor.  This is because a given accessor
may be ``shared'' with many constructors.  For example, given the datatype
\begin{alltt}
  prop: DATATYPE
   BEGIN
    p: p?
    and(x1, x2: prop): and?
    or(x1, x2: prop): or?
    not(x1: prop): not?
   END prop
\end{alltt}
There is only one declaration generated for \texttt{x1}:
\begin{alltt}
  x1: [\{x: prop | and?(x) OR or?(x) OR not?(x)\} -> prop]
\end{alltt}
and this clearly is not associated with any particular constructor.
\end{class}

\begin{class}{injection-expr}{}{\classhln{constructor-name-expr}}%
{\slotidx{index} & the index number, an integer}
This is similar to the projection-expr class, but for cotuples,
where it acts more like a constructor (hence is a subclass of
\texttt{constructor-name-expr}).
\end{class}

\begin{class}{injection?-expr}{}{\classhln{recognizer-name-expr}}%
{\slotidx{index} & the index number, an integer}
This is similar to the projection-expr class, but for cotuples,
where it acts more like a recognizer (hence is a subclass of
\texttt{recognizer-name-expr}).
\end{class}

\begin{class}{extraction-expr}{}{\classhln{accessor-name-expr}}%
{\slotidx{index} & the index number, an integer}
This is similar to the projection-expr class, but for cotuples,
where it acts more like an accessor (hence is a subclass of
\texttt{accessor-name-expr}).
\end{class}

\begin{class}{injection-application}{}{\classhln{expr}}%
{\slotidx{id} & identifier \\
 \slotidx{index} & the index number, an integer \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
This is similar to the \texttt{projection-applcation} class, but for
cotuple injections.  It does not really correspond to an application,
because like projections, there is no declaration associated with an
injection.
\end{class}

\begin{class}{injection?-expr}{}{\classhln{recognizer-name-expr}}%
{\slotidx{id} & identifier \\
 \slotidx{index} & the index number, an integer \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
This is similar to the \texttt{projection-applcation} class, but for
cotuple injection recognizers.  It does not really correspond to an
application, because like projections, there is no declaration associated
with an injection recognizer.
\end{class}

\begin{class}{extraction-expr}{}{\classhln{accessor-name-expr}}%
{\slotidx{id} & identifier \\
 \slotidx{index} & the index number, an integer \\
 \slotidx{actuals} & a list of actuals \\
 \slotidx{argument} & the argument}
This is similar to the \texttt{projection-applcation} class, but for
cotuple extractions.  It does not really correspond to an application,
because like projections, there is no declaration associated with an
extraction.
\end{class}

\begin{class}{number-expr}{}{\classhln{expr}}{\slotidx{number} & a nonnegative integer}
This is the class for numbers.  Negative numbers are represented as
applications, with a \texttt{-} operator, so the \texttt{number} is always
positive.  Note that during typechecking, a \texttt{number-expr} instance
may be changed to a \texttt{name-expr}, if it turns out the number has an
associated declaration.  This is because numbers may be overloaded the
same as names, and any number which is overloaded in this way must be
treated as a \texttt{name-expr}.  Typechecking a \texttt{number-expr}
always either sets the type to \texttt{real}, or changes it to a
\texttt{name-expr}.

Lisp uses a bignum representation for integers they get beyond the word
size, so this is accurate even for large integers.
\end{class}

\begin{class}{tuple-expr}{}{\classhln{expr}}{\slotidx{exprs} & a list of expressions}
This is the class for tuple expressions, and the elements are in the
\texttt{expr} list.  In PVS, tuple expressions always have at least two
elements; 0-tuples are not allowed, and 1-tuples are really just
parenthesized expressions.  Thus the type of a \texttt{tuple-expr}
instance is always a \texttt{tuptype}, or a subtype of one.
\end{class}

\begin{class}{record-expr}{}{\classhln{expr}}{\slotidx{assignments} & a list of assignments}
This corresponds to a record expression of the form \texttt{(\#
a$_1$:T$_1$, \ldots, a$_n$:T$_n$ \#)}.  
\end{class}

\begin{class}{cases-expr}{}{\classhln{expr}}{expression selections else-part}
\end{class}

\begin{class}{selection}{}{\classhln{syntax}}{constructor args expression}
\end{class}

\begin{class}{unpack-expr}{}{\classhln{cases-expr}}{}
\end{class}

\begin{class}{in-selection}{}{\classhln{selection}}{index}
\end{class}

\begin{class}{application}{}{\classhln{expr}}%
{\slotidx{operator} & an expr \\
 \slotidx{argument} & an expr}
\end{class}

\begin{class}{string-expr}{}{\classhln{application}}{\slotidx{string-value} & a Lisp string}
A string-expr in PVS is really an application of \texttt{list2finseq} to a
list of characters.  But it is often much more efficient to define methods
on this class directly.
\end{class}

\begin{class}{propositional-application}{}{\classhln{application}}{}
A mixin.
\end{class}

\begin{class}{negation}{}{\classhln{propositional-application}}{}
When an application has an operator that resolves to the booleans
\texttt{NOT}, it is changed to this class.  This is useful for defining
methods.  There is a \classhln{unary-negation} subclass that is there
for prettyprinting and related purposes.  Thus \texttt{NOT A} is a unary
negation, while \texttt{NOT(A)} is a negation (assuming \texttt{NOT} is
from the booleans theory).
\end{class}

\begin{class}{conjunction}{}{\classhln{propositional-application}}{}
When an application has an operator that resolves to the booleans
\texttt{AND}, it is changed to this class.  This is useful for defining
methods.  There is a \texttt{infix-conjunction} subclass that is there
for prettyprinting and related purposes.  Thus \texttt{A AND B} is a unary
negation, while \texttt{AND(A, B)} is a conjunction (assuming \texttt{AND} is
from the booleans theory).  Note that \texttt{\&} is an alias for
\texttt{AND} when it resolves to the boolean \texttt{\&}, and also leads
to a conjunction.

Note that technically if \texttt{BB} has type \texttt{[bool, bool]}, then
\texttt{AND(BB)} is a perfectly valid conjunction.  In practice, though,
everyone writing methods specializing on this class assumed there were two
arguments, and getting occasional Lisp errors as a result.  Thus when
converting to a conjunction class, the typechecker also ensures there are
two arguments, by converting this to \texttt{AND(BB`1, BB`2)}.
\end{class}

\begin{class}{disjunction}{}{\classhln{propositional-application}}{}
Exactly as for \texttt{conjunction}s, but with \texttt{OR} instead of
\texttt{AND}, and \texttt{infix-disjunction} as the corresponding subclass.
\end{class}

\begin{class}{implication}{}{\classhln{propositional-application}}{}
Exactly as for \texttt{conjunction}s, but with \texttt{IMPLIES} and
\texttt{=>} instead of \texttt{AND} and \texttt{\&}, and
\texttt{infix-implication} as the corresponding subclass.
\end{class}

\begin{class}{iff-or-boolean-equation}{}{\classhln{application}}{}
This class is a mixin.  If \texttt{A} and \texttt{B} are booleans, then
\texttt{A IFF B} and \texttt{A = B} are logically equivalent, and it is
sometimes useful to have methods that don't make a distinction.  As
described below, these do belong to distinct subclasses, so distinctions
can be made if it is desirable.  For example, the prover \texttt{prop}
command will case-split on \texttt{IFF}, but not on \texttt{=}.

Note that this is not a subclass of \texttt{propositional-application}.
\end{class}

\begin{class}{iff}{}{\classhln{iff-or-boolean-equation}}{}
Exactly as for \texttt{conjunction}s, but with \texttt{IFF} instead of
\texttt{AND}, and \texttt{infix-iff} as the corresponding subclass.
\end{class}

\begin{class}{equation}{}{\classhln{application}}{}
When an application has an operator that resolves to the
\texttt{equalities} theory declaration \texttt{=}, it is changed to this
class.  There is an \texttt{infix-equation} subclass that is there for
prettyprinting and related purposes.
\end{class}

\begin{class}{boolean-equation}{}{\classhln{iff-or-boolean-equation} \classhln{equation}}{}
This class is for the special case where the application is an
\texttt{equation} as above, and the arguments are boolean.  The infix
subclass is \texttt{infix-boolean-equation}.
\end{class}

\begin{class}{disequation}{}{\classhln{application}}{}
When an application has an operator that resolves to the \texttt{notequal}
theory declaration \texttt{/=}, it is changed to this class.  There is an
\texttt{infix-disequation} subclass that is there for prettyprinting and
related purposes.
\end{class}

The following classes relate to IF expressions.  The following table
should explain the differences. Given a declaration \texttt{IF:\ [int,
int, int -> int]}, in addition to the usual \texttt{IF} declared in the
prelude, the following shows which class each kind of expression belongs
to.  The \texttt{if-expr} and \texttt{mixfix-branch} classes are useful
only for prettyprinting and related methods.

\begin{tabular}{>{\tt}r>{\tt}l}
\textrm{Expression} & \textrm{Class} \\ \hline
IF(1, 3, 7)                 & application \\
IF 1 THEN 3 ELSE 7 ENDIF    & if-expr \\
IF(TRUE, 3, 7)              & branch \\
IF TRUE THEN 3 ELSE 7 ENDIF & mixfix-branch \\
\end{tabular}

\begin{class}{branch}{}{\classhln{application}}{}
When an application has an operator that resolves to the \texttt{if\_def}
theory declaration \texttt{IF}, it is changed to this class.  There are
\texttt{mixfix-branch} and \texttt{chained-branch} subclasses associated
with this.  The \texttt{mixfix-branch} class simply means it had the
\texttt{IF-THEN-ELSE-ENDIF} form, and the \texttt{chained-branch} is
exactly like the \texttt{chained-if-expr}.  Both these subclasses are
there primarily for prettyprinting and related purposes.
\end{class}

\begin{class}{let-expr}{}{\classhln{application}}{}
When a LET expression is parsed, it is converted to an application.  This
is because \texttt{LET x$_1$ = $e_1$, ..., x$_n$ = $e_n$ IN
$e$(x$_1,\ldots,$x$_n$)} is equivalent to \texttt{(LAMBDA
(x$_1$,\ldots,x$_n$):\ $e$(x$_1,\ldots,$x$_n$))($e_1$,\ldots,$e_n$)}.
Ocassionally it is useful to have methods on this class, the
\texttt{let-reduce?} flag argument to many of the prover commands makes
the distinction when beta-reducing terms.  In addition, the typechecker
treats \texttt{let-expr}s specially, because the variables on the
left-hand side do not have to have a type declared for them, it will be
determined from the right-hand side.

Remember that the LET expression with multiple bindings is treated as a
sequential LET, i.e., \texttt{LET a = b, c = d IN e} is equivalent to
\texttt{LET a = b IN LET c = d IN e}.  In the former case, the
transformation is done, and the inner \texttt{let-expr}(s) are converted
to the \texttt{chained-let-expr} subclass.
\end{class}

\begin{class}{binding-expr}{}{\classhln{expr}}%
{\slotidx{bindings} & a list of bind-decls \\
 \slotidx{expression} & an expr \\
 \slotidx{commas?} & whether the bindings have commas \\
 \slotidx{chain?} & whether the binding-expr was chained \\
}
This is a mixin for quantified-exprs and lambda-exprs.  Note that binding
expressions of the form \texttt{F ! (x:\ T):\ p(x)} are transformed by the
parser to \texttt{binding-application} instances, which are actually a
subclass of \texttt{application}.

The \texttt{commas?} flag indicate the difference between \texttt{LAMBDA
(x:\ int), (y:\ int):\ x + y} and \texttt{LAMBDA (x:\ int)(y:\ int): x +
y}.  The former is the uncurried form, and has a \texttt{bindings} list
with two elements \texttt{commas?}  set to \texttt{t}, whereas the latter
curried form yields a nested lambda expression and \texttt{commas?} is set
to \texttt{nil}.  The \texttt{chain?} flag of the inner lambda
expression(s) are set to \texttt{t} in this case.
\end{class}

\begin{class}{lambda-expr}{}{\classhln{binding-expr}}{}
This is the subclass of \texttt{binding-expr} used for LAMBDA expressions.
\end{class}

\begin{class}{quant-expr}{}{\classhln{binding-expr}}{}
This mixin is the subclass of \texttt{binding-expr} used for quantified
expressions.
\end{class}

\begin{class}{forall-expr}{}{\classhln{quant-expr}}{}
This is the subclass of \texttt{quant-expr} used for FORALL expressions.
\end{class}

\begin{class}{exists-expr}{}{\classhln{quant-expr}}{}
This is the subclass of \texttt{quant-expr} used for EXISTS expressions.
\end{class}


\begin{class}{update-expr}{}{\classhln{expr}}
{\slotidx{expression} & an expr \\
 \slotidx{assignments} & a list of assignments}
An update expression of the form \texttt{e WITH [x := 1, y := 2]}, maps to
an \texttt{update-expr} instance, where the \texttt{expression} is
\texttt{e}, and the \texttt{assignments} slot is set to the list of
generated \texttt{assigment} instances.  Note that these are very
succinct representations, but correspondingly difficult to typecheck or to
translate to other systems (e.g., decision procedures).  See the
description of the function \functionhln{translate-update-to-if!} for more
 details.
\end{class}

\subsubsection{Assignment Classes}

\begin{class}{assignment}{}{\classhln{syntax}}
{\slotidx{arguments} & the list of arguments \\
 \slotidx{expression} & the value expression}
Assignments occur in both record-exprs and update-exprs.  The
\texttt{arguments} form is a list of lists.  For example, given the
assignment \texttt{`a(x, y)`1 := 0}, the \texttt{arguments} are
\texttt{((a) (x y) (1))} and the \texttt{expression} is \texttt{0}.
\end{class}

\begin{class}{maplet}{}{\classhln{assignment}}{}
A \texttt{maplet} is an assignment that may extend the update (it is
illeagal in record expressions).  When an assignment of the form
\texttt{(x) |-> y} is parsed, it becomes a maplet.  Most likely only
the typechecker needs methods for this.
\end{class}

\begin{class}{field-assignment-arg}{}{\classhln{field-name-expr}}{}
A field assignment argument has three possible forms, e.g., \texttt{x :=
3}, \texttt{(x) := 3}, and \texttt{`x := 3}.  The first two forms are
ambiguous, and the typechecker must determine whether \texttt{x} is a
field name of a record assignment, or an argument to a function.
Initially \texttt{x} will be a \texttt{name-expr}.  If it is determined to
be a record assignment, then its class is changed to
\texttt{field-assignment-arg}.  Only useful for prettyprinting.
\end{class}

\subsection{Names}

\input{bnf-names}

\input{bnf-lexical}

\subsection{Binding Declarations}

\begin{class}{simple-decl}{mixin}{\classhln{syntax}}
{\slotidx{id} & a symbol \\
 \slotidx{declared-type} & a type expr \\
 \slotidx{type} & a type expr}
\end{class}

\begin{class}{binding}{mixin}{\classhln{simple-decl}}{}
\end{class}

\begin{class}{dep-binding}{}{\classhln{binding} \classhln{name}}
{\slotidx{parens} & a nonnegative integer}
\end{class}

\begin{class}{bind-decl}{}{\classhln{binding} \classhln{name-expr}}
{\slotidx{chain?} & a boolean (\texttt{t} or \texttt{nil})}
\end{class}

\subsection{Theory Names}

\begin{class}{modname}{}{\classhln{name}}{}
\end{class}

\subsubsection{Actuals and Mappings}

\begin{class}{actual}{}{\classhln{syntax}}
{\slotidx{expr} & a type expression or expression \\
 \slotidx{type-value} & a type expression or \texttt{nil}}
\end{class}

\begin{class}{mapping}{}{\classhln{syntax}}
{\slotidx{lhs} & an expression \\
 \slotidx{rhs} & a \texttt{mapping-rhs} instance \\
 \slotidx{kind} & a symbol \\
 \slotidx{declared-type} & a type expression \\
 \slotidx{type} & a type expression}
\end{class}

\begin{class}{mapping-def}{}{\classhln{mapping}}
{\slotidx{mapped-decl} & a declaration}
\end{class}

\begin{class}{mapping-subst}{}{\classhln{mapping}}{}
\end{class}

\begin{class}{mapping-rename}{}{\classhln{mapping}}
{\slotidx{mapped-decl} & a declaration}
\end{class}

\begin{class}{mapping-with-formals}{}{\classhln{mapping}}
{\slotidx{formals} & a list of bind-decls}
\end{class}

\begin{class}{mapping-def-with-formals}{}{\classhln{mapping-with-formals} \classhln{mapping-def}}{}
\end{class}

\begin{class}{mapping-subst-with-formals}{}{\classhln{mapping-with-formals} \classhln{mapping-subst}}{}
\end{class}

\begin{class}{mapping-rename-with-formals}{}{\classhln{mapping-with-formals} \classhln{mapping-rename}}{}
\end{class}

\begin{class}{mapping-rhs}{}{\classhln{actual}}{}
\end{class}

\subsection{Resolutions}

\begin{class}{resolution}{}{}
{\slotidx{declaration} & a declaration \\
 \slotidx{module-instance} & a modname \\
 \slotidx{type} & a type expression}
\end{class}

\subsection{The Context}

The context is the set of declarations available while typechecking or
proving.  In simple type theory, this is usually denoted as $\Gamma$, and
is simply a sequence of type, constant, and variable declarations.  PVS
contexts are more complex, and include the notion of a \emph{current theory}, a
\emph{current declaration}, a symbol table 

\begin{class}{context}{}{}
{\slotidx{theory} & a theory \\
 \slotidx{theory-name} & a modname \\
 \slotidx{declaration} & a declaration \\
 \slotidx{declarations-hash} & a hash table \\
 \slotidx{using-hash} & a hash table \\
 \slotidx{named-theories} & a list of modnames \\
 \slotidx{library-alist} & an association list \\
 \slotidx{judgements} & a \texttt{judgements} instance \\
 \slotidx{known-subtypes} & an association list \\
 \slotidx{conversions} & a list of conversion declarations \\
 \slotidx{disabled-conversions} & a list of conversion declarations \\
 \slotidx{auto-rewrites} & a list of auto-rewrite-names \\
 \slotidx{disabled-auto-rewrites} & a list of auto-rewrite-names}
\end{class}

\begin{class}{judgements}{}{}
{\slotidx{judgement-types-hash} & a hash table \\
 \slotidx{number-judgements-alist} & an association list \\
 \slotidx{name-judgements-alist} & an association list \\
 \slotidx{application-judgements-alist} & an association list}
\end{class}

\begin{class}{name-judgements}{}{}
{\slotidx{minimal-judgements} & a list of judgements \\
 \slotidx{generic-judgements} & a list of judgements}
\end{class}

\begin{class}{application-judgements}{}{}
{\slotidx{generic-judgements} & a list of judgements \\
 \slotidx{judgements-graph} & a list of lists of justments}
\end{class}



\begin{class}{proof-info}{}{}
{\slotidx{id} & \\
 \slotidx{description} & \\
 \slotidx{create-date} & \\
 \slotidx{run-date} & \\
 \slotidx{script} & \\
 \slotidx{status} & \\
 \slotidx{refers-to} & \\
 \slotidx{real-time} & \\
 \slotidx{run-time} & \\
 \slotidx{interactive?} & \\
 \slotidx{decision-procedure-used} & }
\end{class}

\begin{class}{decl-reference}{}{}
{\slotidx{id} & \\
 \slotidx{class} & \\
 \slotidx{type} & \\
 \slotidx{theory-id} & \\
 \slotidx{library} & }
\end{class}

\subsection{Prover Classes}

\begin{class}{s-formula}{}{}
{\slotidx{formula} & \\
 \slotidx{label} & \\
 \slotidx{new?} & \\
 \slotidx{asserted?} & }
\end{class}

\begin{class}{sequent}{}{}
{\slotidx{s-forms} & \\
 \slotidx{p-sforms} & \\
 \slotidx{n-sforms} & \\
 \slotidx{hidden-s-forms} & \\
 \slotidx{info} & }
\end{class}

\begin{class}{dpinfo}{}{}
{\slotidx{dpinfo-sigalist} & \\
 \slotidx{dpinfo-findalist} & \\
 \slotidx{dpinfo-usealist} & }
\end{class}

\begin{class}{proofstate}{}{}
{\slotidx{label} & The string representing the branch of the proofstate; a
 formula id followed by integers separated by periods, e.g.,
 \texttt{"fml.1.2.1"} \\
 \slotidx{current-goal} & the sequent associated with this proofstate. \\
 \slotidx{parent-proofstate} & the parent of this proofstate. \\
 \slotidx{current-subgoal} & see Control section below. \\
 \slotidx{pending-subgoals} & see Control section below. \\
 \slotidx{remaining-subgoals} & see Control section below. \\
 \slotidx{done-subgoals} & see Control section below. \\
 \slotidx{current-rule} & \\
 \slotidx{dp-state} & \\
 \slotidx{status-flag} & \\
 \slotidx{subgoalnum} & \\
 \slotidx{justification} & In top-proofstate, set to justification of
 declaration.  Set in proofstepper for propax.  Set in success-step from
 current-rule, current-xrule, label, comment, and done-subgoals.  Set in
 make-update when there is a justification field.  Set in rule-apply for a
 successful goal.  Set in undo-proof. \\
 \slotidx{current-input} & Set by query*, used to control display and find
 proofstates associated with undo forms \\
 \slotidx{parsed-input} & \\
 \slotidx{printout} & \\
 \slotidx{comment} & \\
 \slotidx{strategy} & \\
 \slotidx{context} & \\
 \slotidx{proof-dependent-decls} & \\
 \slotidx{dependent-decls} & \\
 \slotidx{current-auto-rewrites} & \\
 \slotidx{tcc-hash} & \\
 \slotidx{subtype-hash} & \\
 \slotidx{rewrite-hash} & \\
 \slotidx{current-xrule} & }
This is a node of the proof tree with label \texttt{label} and sequent
\texttt{current-goal}.  It is a child of \texttt{parent-proofstate}, and
has children \texttt{current-subgoal}, \texttt{pending-subgoals},
\texttt{remaining-subgoals}, and \texttt{done-subgoals}.

\subsubsection{Control}

The proof starts in the top proofstate, with a \texttt{current-goal} sequent
consisting solely of the formula to be proved.  The
\texttt{parent-proofstate}, \texttt{current-subgoal},
\texttt{pending-subgoals}, \texttt{remaining-subgoals}, and
\texttt{done-subgoals} are all initially \texttt{nil}.  


, a \texttt{label} string
consisting of the formula identifier, a strategy which is either provided
or \texttt{(query*-step)}.

\end{class}

\begin{class}{tcc-sequent}{}{\classhln{sequent}}
{\slotidx{tcc} & \\
 \slotidx{expr} & \\
 \slotidx{type} & \\
 \slotidx{reason} & \\
 \slotidx{kind} & }
\end{class}

\begin{class}{tcc-proofstate}{}{\classhln{proofstate}}{}
\end{class}

\begin{class}{rewrite}{}{}
{\slotidx{lhs} & \\
 \slotidx{rhs} & \\
 \slotidx{hyp} & \\
 \slotidx{res} & }
\end{class}

\begin{class}{auto-rewrites-info}{}{}
{\slotidx{rewrites} & \\
 \slotidx{all-rewrites-names} & \\
 \slotidx{auto-rewrites-names} & \\
 \slotidxi{auto-rewrites!-names}{auto-rewrites"!-names} & \\
 \slotidx{macro-names} & }
\end{class}

\begin{class}{top-proofstate}{}{\classhln{proofstate}}
{\slotidx{in-justification} & \\
 \slotidx{declaration} & }
\end{class}

\begin{class}{strat-proofstate}{}{\classhln{proofstate}}{}
\end{class}

\begin{class}{strategy}{}{}
{\slotidx{topstep} & \\
 \slotidx{subgoal-strategy} & \\
 \slotidx{failure-strategy} & }
\end{class}

\begin{class}{rulemacro}{}{}
{\slotidx{rule-list} & }
\end{class}

\subsubsection{Rule and Strategy Entries}

Note that rules and strategies may be introduced by the user as well as
the system.  The parts of the rules and strategies may be accessed through
the global lisp variables \globalnm{*rulebase*}, \globalnm{*rules*}, or
\globalnm{*steps*}, each of which is a hashtable indexed by the name of
the corresponding rule or strategy, and providing a rule-entry, defrule-entry,
defstep-entry, or defhelper-entry.

Thus, for example, all format strings may be obtained using the following
function
\begin{alltt}
(defun collect-format-strings ()
  (with-open-file (*standard-output* "/dev/null" :direction :output
                                     :if-exists :overwrite)
    (read-strategies-files))
  (let ((format-strings nil))
    (maphash #'(lambda (n s)
                 (unless (string= (format-string s) "")
                   (push (format-string s) format-strings)))
             *rulebase*)
    (maphash #'(lambda (n s)
                 (unless (string= (format-string s) "")
                   (push (format-string s) format-strings)))
             *rules*)
    (maphash #'(lambda (n s)
                 (unless (string= (format-string s) "")
                   (push (format-string s) format-strings)))
             *steps*)
    format-strings))
\end{alltt}


\begin{class}{entry}{}{}
{\slotidx{name} & \\
 \slotidx{required-args} & \\
 \slotidx{optional-args} & \\
 \slotidx{docstring} & }
\end{class}

\begin{class}{rule-entry}{}{\classhln{entry}}
{\slotidx{rule-function} & \\
 \slotidx{format-string} & }
Primitive rule entries in the \globalnm{*rulebase*} hash table.
\end{class}

\begin{class}{rule-instance}{}{}
{\slotidx{rule} & \\
 \slotidx{rule-input} & \\
 \slotidx{rule-format} & }
\end{class}

\begin{class}{defrule-entry}{}{}
{\slotidx{name} & the rule identifier \\
 \slotidx{formals} & the list of arguments \\
 \slotidx{defn} & the rule body \\
 \slotidx{docstring} & the helper documentation \\
 \slotidx{format-string} & the commentary string, a \texttt{format}
                           control string}
Derived rule entries in the \globalnm{*rules*} hash table.
\end{class}

\begin{class}{defstep-entry}{}{\classhln{defrule-entry}}{}
Strategy entries in the \globalnm{*steps*} hash table.
\end{class}

\begin{class}{defhelper-entry}{}{\classhln{defstep-entry}}{}
Helper strategy entries in the \globalnm{*steps*} hash table.
\end{class}

\begin{class}{strategy-instance}{}{}
{\slotidx{strategy-fun} & \\
 \slotidx{strategy-input} & }
\end{class}

\begin{class}{rulefun-entry}{}{\classhln{entry}}
{\slotidx{rulefun} & }
\end{class}

\begin{class}{strategy-entry}{}{\classhln{entry}}
{\slotidx{strategy-fun} & }
\end{class}

\begin{class}{justification}{}{}
{\slotidx{label} & \\
 \slotidx{rule} & \\
 \slotidx{subgoals} & \\
 \slotidx{xrule} & \\
 \slotidx{comment} & }
\end{class}

\begin{class}{skolem-const-decl}{}{\classhln{const-decl}}{}
\end{class}

\subsection{Ground Evaluator Classes}

\begin{class}{eval-defn-info}{}{}
{\slotidx{unary} & \\
 \slotidx{multiary} & \\
 \slotidx{destructive} & }
\end{class}

\begin{class}{eval-defn}{}{}
{\slotidx{name} & \\
 \slotidx{definition} & \\
 \slotidx{output-vars} & }
\end{class}

\begin{class}{eval-info}{}{}
{\slotidx{internal} & \\
 \slotidx{external} & }
\end{class}

\begin{class}{destructive-eval-defn}{}{\classhln{eval-defn}}
{\slotidx{side-effects} & }
\end{class}

\section{Defining Methods}

\subsection{A Template for Defining Methods}


\section{Global Variables}

Global variables are used extensively in PVS.  In some cases they simply
are a way to optimize, keeping functions from having large numbers of
arguments, and providing hash tables.  One of the advantages of CLOS is
that it is very easy to define a set of methods that produce a result,
then at a later date add an around method that uses a global hash table to
memoize the function.

\begin{globalvar}{*pvs-library-path*}
Set from the \texttt{PVS\_LIBRARY\_PATH} environment variable + *pvs-path*
\end{globalvar}

\begin{globalvar}{*pvs-emacs-interface*}
Set to \texttt{t} by Emacs in pvs-load - affects how pvs-emacs functions work
\end{globalvar}

\begin{globalvar}{*pvs-directories*}
This is set to a list of directories to search for using the \texttt{lf}
function.
\end{globalvar}

\begin{globalvar}{*pvs-version*}
The version number, currently the string \texttt{"3.2"}.
\end{globalvar}

\begin{globalvar}{*binfile-version*}
\end{globalvar}

\begin{globalvar}{*pvs-context*}
\end{globalvar}

\begin{globalvar}{*pvs-context-path*}
The current context path - this can change when loading libraries.
\end{globalvar}

\begin{globalvar}{*pvs-current-context-path*}
The current context path - this one only changes with change-context
\end{globalvar}

\begin{globalvar}{*pvs-files*}
\end{globalvar}

\begin{globalvar}{*pvs-verbose*}
Flag indicating level of messages to print when noninteractive
\end{globalvar}

\begin{globalvar}{*suppress-msg*}
Flag indicating whether to suppress messages output with pvs-message
\end{globalvar}

\begin{globalvar}{*show-conversions*}
Flag indicating whether conversions are to be displayed when unparsing.
\end{globalvar}

\begin{globalvar}{*untypecheck-hook*}
Functions (with no args) to be called whenever untypecheck is called
\end{globalvar}

\begin{globalvar}{*prelude-context*}
Provides the context associated with the prelude
\end{globalvar}

\begin{globalvar}{*prelude*}
The hash-table of prelude
\end{globalvar}

\begin{globalvar}{*prelude-theories*}
A list of the prelude theories; more useful than *prelude* when the
order is important
\end{globalvar}

\begin{globalvar}{*prelude-library-context*}
Provides the context associated with the current prelude libraries
\end{globalvar}

\begin{globalvar}{*prelude-libraries*}
The pathnames of the prelude libraries that have been loaded.
Given a pathname, returns a hash-table which can then be put into
*visible-libraries*
\end{globalvar}

\begin{globalvar}{*imported-libraries*}
\end{globalvar}

\begin{globalvar}{*pvs-modules*}
The hash-table of modules known to the system in this session
\end{globalvar}

\begin{globalvar}{*in-evaluator*}

\end{globalvar}

\begin{globalvar}{*noninteractive*}
\end{globalvar}

\begin{globalvar}{*disable-gc-printout*}
\end{globalvar}

\begin{globalvar}{*boolean*}
\end{globalvar}

\begin{globalvar}{*true*}
\end{globalvar}

\begin{globalvar}{*false*}
\end{globalvar}

\begin{globalvar}{*number*}
\end{globalvar}

\begin{globalvar}{*number\_field*}
\end{globalvar}

\begin{globalvar}{*real*}
\end{globalvar}

\begin{globalvar}{*rational*}
\end{globalvar}

\begin{globalvar}{*integer*}
\end{globalvar}

\begin{globalvar}{*naturalnumber*}
\end{globalvar}

\begin{globalvar}{*posint*}
\end{globalvar}

\begin{globalvar}{*even\_int*}
\end{globalvar}

\begin{globalvar}{*odd\_int*}
\end{globalvar}

\begin{globalvar}{*ordinal*}
\end{globalvar}

\begin{globalvar}{*tcdebug*}
\end{globalvar}

\begin{globalvar}{*generate-tccs*}
\end{globalvar}

\begin{globalvar}{*tccs*}
\end{globalvar}

\begin{globalvar}{*collecting-tccs*}
Controls whether TCCs are inserted in the current theory or simply
collected in *tccforms*.  Note that if *in-checker* is \texttt{t}, TCCs
will be added to *tccforms* regardless.

Used by the typechecker in order to generate proper TCCs for datatype
updates, which may be disjunctions.
\end{globalvar}

\begin{globalvar}{*tccforms*}
The TCCs generated while typechecking an expression when *in-checker*,
*in-evaluator*, or *collecting-tccs* is \texttt{t}.  Otherwise the TCCs
are added directly to the theory.


\end{globalvar}

\begin{globalvar}{*bound-variables*}
\end{globalvar}

\begin{globalvar}{*valid-id-check*}
\end{globalvar}

\begin{globalvar}{*subtype-of-hash*}
\end{globalvar}

\begin{globalvar}{*keep-unbound*}
\end{globalvar}

\begin{globalvar}{*last-proof*}
\end{globalvar}

\begin{globalvar}{*pvs-operators*}
\end{globalvar}

\begin{globalvar}{*default-char-width*}
\end{globalvar}


\subsection{Prover Globals}

\begin{globalvar}{*in-checker*}
\end{globalvar}

\begin{globalvar}{*rulebase*}
The hash table of primitive rules, i.e., rules defined using
\functionnm{addrule}.
\end{globalvar}

\begin{globalvar}{*rules*}
The hash table of derived rules, i.e., rules defined using
\functionnm{defrule}, \functionnm{defstep}, or \functionnm{defhelper}.
\end{globalvar}

\begin{globalvar}{*steps*}
The hash table of strategies defined using
\functionnm{defstep}, or \functionnm{defhelper}.
\end{globalvar}

\begin{globalvar}{*top-proofstate*}
\end{globalvar}

\begin{globalvar}{*new-fmla-nums*}
\end{globalvar}

\begin{globalvar}{*current-decision-procedure*}
\end{globalvar}

\begin{globalvar}{*default-decision-procedure*}
\end{globalvar}

\begin{globalvar}{*decision-procedures*}
\end{globalvar}

\begin{globalvar}{*decision-procedure-descriptions*}
\end{globalvar}

\begin{globalvar}{*subgoals*}
\end{globalvar}

\begin{globalvar}{*multiple-proof-default-behavior*}
\end{globalvar}

\begin{globalvar}{*dump-sequents-to-file*}
\end{globalvar}

\begin{globalvar}{*show-parens-in-proof*}
\end{globalvar}

\begin{globalvar}{*pvs-context-writable*}
\end{globalvar}

\begin{globalvar}{*save-proofs-pretty*}
\end{globalvar}

\begin{globalvar}{*number-of-proof-backups*}
\end{globalvar}

\begin{globalvar}{*debugging-print-object*}
\end{globalvar}

\begin{globalvar}{*current-theory*} is the theory instance that the formula
being proved belongs to.
\end{globalvar}

\begin{globalvar}{*current-context*} is the context of the current formula
\end{globalvar}

\begin{globalvar}{*top-proofstate*}
\end{globalvar}

\begin{globalvar}{*ps*}
\end{globalvar}

\begin{globalvar}{*number-of-proof-backups*}
\end{globalvar}

\begin{globalvar}{*save-proofs-pretty*}
\end{globalvar}

\section{Functions}

There are several way to create types and terms in PVS.  The most direct
way is to use the Common Lisp \texttt{make-instance} function, but it is
not the most convenient, as it is difficult to know how to set the slots
in a consistent manner.  For example, the \textit{type} and
\textit{declared-type} slots, should always be such that
\texttt{(pc-typecheck (declared-type \textit{instance}))} is 
\texttt{tc-eq} to \texttt{(type \textit{instance})}.  Still, it is often
convenient to use \texttt{make-instance}.

There are three usual alternatives for creating instances.  The safest,
albeit slowest, way is to build strings and to parse and typecheck them.
Creating terms that are just a minor difference from an existing term can
be done by copying them.  Finally, terms can be created bottom up using
the \textit{make} functions.

\subsection{Parsing and Typechecking}

Parsing and typechecking a PVS file can be done using \functionhln{parse-file}
and \texttt{typecheck-file}, as described in Sections~\ref{parse-file}
and~\ref{typecheck-file}.

\subsubsection{Parsing}
\label{parse-file}

Parsing a term can is usually done using \texttt{pc-parse}.  The
parser is built using the Ergo parser generator~\cite{ERGO}, similar to
YACC or bison, but for Lisp.  Parsing in PVS means invoking the Ergo
generated parser function \texttt{pvs-parse}, and converting the Ergo term
abstract syntax into PVS terms using functions with names of the form
\texttt{xt-\textit{nonterminal}}.  The \texttt{pc-parse} function calls
\functionhln{parse}, but with a simplified interface that makes it easier to
use.

parse-importchain (theories)

\begin{lispfunction}{pc-parse}{input nonterminal}
If the input is of type \classhln{syntax}, it is simply returned (without
checking that it satisfies the \textit{nonterminal}).  Otherwise if
\textit{input} is not a string, \texttt{pc-parse} is called on the string
generated by \texttt{(format nil "\tilde a" \textit{input})}.  Finally, if
it is a string, then it is parsed and the resulting PVS term is returned.
The \texttt{nonterminal} is one of the nonterminals defined in the grammar
input for the Ergo parser generator.  The most useful nonterminals are:
\begin{description}
\item[\texttt{expr}] - Expressions
\item[\texttt{name-expr}] - Name expressions
\item[\texttt{type-expr}] - Type expressions
\item[\texttt{modname}] - Theory names
\item[\texttt{name}] - Name
\end{description}

If the string is not parsable as a \textit{nonterminal},
\texttt{parse-error} is called.  See Section~\ref{error-handling}.

The \texttt{pc-parse} function can be called from anywhere, regardless of
the value of \globalhln{*current-context*}.

\end{lispfunction}

\begin{lispfunction}{parse}{\amprest keys}
\end{lispfunction}

\begin{lispfunction}{pvs-parse}
{\ampkey \textup{(}nt \textup{'adt-or-theories}\textup{)} error-threshold
   ask-about-bad-tokens return-errors stream string file exhaust-stream}

\end{lispfunction}

%% \begin{description}
%% \item[(pc-parse \emph{input} \emph{nonterminal})] takes a string input and
%% a nonterminal symbol and returns a parsed instance of the specified
%% nonterminal or an error if the string is not legitimate for the
%% nonterminal.  For example,
%% \begin{alltt}
%%   (pc-parse "x + 1" 'expr)
%% \end{alltt}
%% returns an instance of the \texttt{expr} class that represents the parse
%% tree for \texttt{x + 1}.  The allowable nonterminals are described below;
%% the most useful ones are: \texttt{expr}, \texttt{type-expr},
%% \texttt{name-expr}, and \texttt{modname}.  Note that if there is a parser
%% error while in the prover, \texttt{(restore)} is automatically invoked.

%% If the input has already been parsed, then pc-parse simply returns it.  If
%% it is not a string, then it is coerced into a string using \texttt{(format
%% nil "~a" \emph{input})}.

\subsection{Typecheck}
\label{typecheck-file}

\begin{lispfunction}{pc-typecheck}
{ex \ampkey expected \textup{(}fnums \textup{'*}\textup{)}
 \textup{(}uniquely? \textup{t}\textup{)}}
takes an expression or type-expression and typechecks it.  The result
depends on whether \emph{ex} is an expression or type expression.

Fo a type expression, \texttt{pc-typecheck} either returns an error
message or the canonical form of the type.  The canonical form is
essentially the type with all defined types expanded.  Thus \texttt{int}
becomes \texttt{\{x: \{x: \{x: number | real\_pred(x)\} |
rational\_pred(x)\} | integer\_pred(x)\}}.

For an expression, \texttt{pc-typecheck} either returns an error message
or decorates the given expression with type information.  If none of the
keyword arguments are given, then if the expression has a unique type, or
can be found in the current sequent, then that determines the type given
to the expression, otherwise an error is reported.  If the \emph{expected}
type is given, then the typechecker will use that as the type.

If \emph{expected} is \texttt{NIL}, \emph{uniquely?} is \texttt{NIL}, and
the expression cannot be found in the current sequent, then if there is no
type error the expression is not yet fully typechecked.  In this case, the
\texttt{types} slot is set to reflect the possible types of the
expression, and the \texttt{type} slot is not yet set.  This is useful
only in special cases, for example it may be desirable to partially
typecheck the expression and then look through the possible types for
record types, without knowing beforehand which recordtype is the expected
type.  Note that such partially typechecked expressions should not be
passed in to other functions without first fully typechecking them, which
may be accomplished by invoking \texttt{pc-typecheck} with an
\emph{expected} type.

There are a number of types that are used frequently enough that global
variables have been assigned their values: \texttt{*boolean*},
\texttt{*naturalnumber*}, \texttt{*integer*}, \texttt{*rational*},
\texttt{*real*}, and \texttt{*number*}.  These may be used as the
\emph{expected} types.
\end{lispfunction}
%\memo{What about tccs?}

Here is an example of the use of pc-parse and pc-typecheck:
\begin{alltt}
  (pc-typecheck (pc-parse "LAMBDA (x:int): x + 2" 'expr)
                :expected (pc-typecheck (pc-parse "[int -> int]" 'type-expr)))
\end{alltt}

\begin{lispfunction}{resolve}{name kind args}

returns a list of the possible resolutions for the \emph{name}.  A
resolution consists of a declaration and a theory instance, and (for name
expressions) a type.  The \emph{kind} is a symbol representing the kind of
name to expect: \texttt{expr}, \texttt{type}, \texttt{module}, or
\texttt{formula}.  The \emph{args} are the arguments provided if it is an
operator; this can help to filter the possible resolutions and provide the
theory instance.  For example, \texttt{car} normally has only one
declaration in the \texttt{list} datatype, but without more information
the instance cannot be determined.  If \texttt{l} is a name expression of
type \texttt{list[int]}, then \texttt{(resolve '|cons| 'expr (list l))}
will return a fully instantiated resolution.

\end{lispfunction}

\begin{lispfunction}{typecheck}{obj \ampkey expected context tccs}
\end{lispfunction}

\begin{lispfunction}{typecheck*}{obj expected kind arguments}
\end{lispfunction}

\begin{lispfunction}{resolve}
  {name kind args \ampoptional \textup{(}context \globalhln{*current-context*}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{formula-or-definition-resolutions}{name}
\end{lispfunction}

\begin{lispfunction}{definition-resolutions}{name}
\end{lispfunction}

\begin{lispfunction}{formula-resolutions}{name}
\end{lispfunction}

\begin{lispfunction}{resolve-theory-name}{modname}
\end{lispfunction}

\begin{lispfunction}{resolve-theory-name}{modname}
\end{lispfunction}

\begin{lispfunction}{make-new-variable-name-expr}{id type}
\end{lispfunction}

\begin{lispfunction}{make-new-variable}{base expr \ampoptional num}
\end{lispfunction}

\subsection{Constructing Types and Expressions}

\subsubsection{Constructing Names and Resolutions}

The most common names to construct are \texttt{name-expr}s,
\texttt{type-name}s, and \texttt{modname}s.  To construct a typechecked
\texttt{name-expr} or \texttt{type-name}, a \texttt{resolution} must be
provided.   

%% \begin{lispfunction}{mk-name}{id \ampoptional actuals mod resolution}
%% \end{lispfunction}

\begin{macro}{def-pvs-term}{name term theory \ampkey (nt \texttt{'expr}) expected}
This macro is used to create a function that returns a specific term
from a specific theory instance.  This is an optimization, for example
\begin{alltt}
  (def-pvs-term not-operator "NOT" "booleans")
\end{alltt}
creates the function \functionnm{not-operator}, which returns a
\classhln{name-expr} that resolves to the the \texttt{NOT} declared in the
\texttt{booleans} theory of the prelude.  This may then be used to check
if a given term is \functionhln{tc-eq} to it, or used to build up a
negation.  

The \functionarg{name} is used to create a function.  The first time this
function is called, it builds the given \functionarg{term} and typechecks
it.  For each call after that the computed term is returned.

If the term is not an expression, the \functionarg{nt} may be used to
specify a diffferent nonterminal, e.g., \texttt{type-expr}.

The \functionarg{expected} not often needed, but it is useful when the
term may otherwise be ambiguous, for example, the minus and difference
operators.
\begin{alltt}
(def-pvs-term difference-operator "-" "number_fields" :expected "[number_field, number_field -> number_field]")
(def-pvs-term minus-operator "-" "number_fields" :expected "[number_field -> number_field]")
\end{alltt}

Note that the given theory instance should not be from a theory that has
theory parameters
\end{macro}

\begin{lispfunction}{mk-formula-decl}
{id expr \ampoptional (spelling \texttt{'formula}) kind}
\end{lispfunction}

\begin{lispfunction}{mk-name-expr}{id \ampoptional actuals mod resolution}
Creates a \classhln{name-expr} instance
\end{lispfunction}

\begin{lispfunction}{make-bind-decl}{}
\end{lispfunction}

\begin{lispfunction}{make-variable-expr}{}
\end{lispfunction}

\begin{lispfunction}{mk-resolution}{decl modinst type}
\end{lispfunction}

\begin{lispfunction}{make-resolution}{decl modinst \ampoptional type}
\end{lispfunction}


\subsubsection{Constructing Types}

\begin{lispfunction}{mk-type-name}{id \ampoptional actuals mod-id resolution}
\end{lispfunction}

\begin{lispfunction}{mk-dep-binding}{id \ampoptional type dtype}
\end{lispfunction}

\begin{lispfunction}{mk-subtype}{supertype predicate}
\end{lispfunction}

\begin{lispfunction}{mk-setsubtype}{supertype predicate}
\end{lispfunction}

\begin{lispfunction}{mk-expr-as-type}{expr}
\end{lispfunction}

\begin{lispfunction}{mk-funtype}{domain range \ampoptional \textup{(}class \textup{'funtype}\textup{)}}
\end{lispfunction}
  
\begin{lispfunction}{mk-predtype}{type}
\end{lispfunction}

\begin{lispfunction}{mk-tupletype}{types}
\end{lispfunction}

\begin{lispfunction}{mk-cotupletype}{types}
\end{lispfunction}

\begin{lispfunction}{mk-recordtype}{field-decls dependent?}
\end{lispfunction}

\begin{lispfunction}{mk-field-decl}{id dtype \ampoptional type}
\end{lispfunction}

\begin{lispfunction}{make-recordtype}{fields}
\end{lispfunction}

\begin{lispfunction}{make-tupletype}{types}
\end{lispfunction}

\begin{lispfunction}{make-cotupletype}{types}
\end{lispfunction}

\begin{lispfunction}{make-domain-type-from-bindings}{vars}
\end{lispfunction}

\begin{lispfunction}{make-tupletype-from-bindings}{vars \ampoptional result}
\end{lispfunction}

\begin{lispfunction}{make-funtype}{domain range}
\end{lispfunction}

\begin{lispfunction}{make-predtype}{type}
\end{lispfunction}

\begin{lispfunction}{make-declared-type}{te}
\end{lispfunction}


\subsubsection{Constructing Expressions}

Aside from parsing and \functionnm{make-instance}, there are three basic
ways to construct expressions.  These are characterized by the function
prefix, as follows.
\begin{description}
\item[\functionnm{mk-}] These functions generally just invoke
\functionnm{make-instance}, but are easier to use.  The result is generally
not typechecked.

\item[\functionnm{make-}] These functions generally include an expected type
argument, and typecheck the resulting term.

\item[\functionnm{make!-}] These functions require the subterms to be
typechecked, and create a new typechecked term.
\end{description}

Deciding which of these to use depends on what is needed.  The
\functionnm{make!-} forms are the fastest, but TCCs will not be generated,
so it is best to use these only in circumstances in which any potential
TCCs have already been dealt with.  For example, it is safe to take the
two arguments of a sum, and create a product using
\functionnm{make!-times}.  But unless it is already known that the second
argument is nonzero, or that TCC checks will be made later, it is not safe
to use \functionnm{make!-divides}.

One technique often used is to build up the subterms using
\functionnm{mk-} functions, then use a \functionnm{make-} function at the
top level to get the typechecked form.  The same thing can be accomplished
using \functionnm{mk-} forms throughout, then calling
\functionhln{typecheck} on the result.

For the most part, a function of the form \functionnm{mk-foo} (or
\functionnm{make-foo} or \functionnm{make!-foo}) creates an instance of (a
subclass of) \texttt{\textit{foo}}.

\subsubsection*{\functionnm{mk-} Functions}

\begin{lispfunction}{mk-number-expr}{num}
Simply creates a \classhln{number-expr} from \functionarg{num}, which must
be a nonnegative integer.
\end{lispfunction}

\begin{lispfunction}{mk-record-expr}{assignments}
Creates a \classhln{record-expr} instance from the list of
\functionarg{assignments}.  See \functionhln{mk-assignment} for
creating assignment instances.
\end{lispfunction}

\begin{lispfunction}{mk-tuple-expr}{exprs}
Creates a \classhln{tuple-expr} instance from \functionarg{exprs}, which
is a list of expressions.
\end{lispfunction}

\begin{lispfunction}{mk-cases-expr}{expr selections else}
Creates a \classhln{cases-expr} instance of the form
\begin{alltt}
  CASES \functionarg{expr} OF
    \functionarg{selections}
    ELSE \functionarg{else}
  ENDCASES
\end{alltt}
\end{lispfunction}

\begin{lispfunction}{mk-selection}{name-expr args expr}
\end{lispfunction}

\begin{lispfunction}{mk-application*}{op arguments}
\end{lispfunction}
                 
\begin{lispfunction}{mk-application}{op \amprest args}
\end{lispfunction}

\begin{lispfunction}{mk-if-expr}{cond then else}
\end{lispfunction}

\begin{lispfunction}{mk-chained-if-expr}{cond then else}
\end{lispfunction}

\begin{lispfunction}{mk-if-expr*}{class cond then else}
\end{lispfunction}

\begin{lispfunction}{mk-implication}{ante succ}
\end{lispfunction}

\begin{lispfunction}{mk-iff}{ante succ}
\end{lispfunction}

\begin{lispfunction}{mk-conjunction}{args}
\end{lispfunction}

\begin{lispfunction}{mk-disjunction}{args}
\end{lispfunction}

\begin{lispfunction}{mk-negation}{arg}
\end{lispfunction}

\begin{lispfunction}{mk-rec-application}{op base args}
\end{lispfunction}

\begin{lispfunction}{mk-rec-application-left}{op base args}
\end{lispfunction}

\begin{lispfunction}{mk-lambda-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{mk-let-expr}{bindings expr}
\end{lispfunction}

\begin{lispfunction}{mk-coercion}{expr type}
\end{lispfunction}

\begin{lispfunction}{mk-forall-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{mk-exists-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{mk-equation}{lhs rhs}
\end{lispfunction}

\begin{lispfunction}{mk-update-expr}{expr assignments}
\end{lispfunction}

\begin{lispfunction}{mk-update-expr-1}{expr index value}
\end{lispfunction}

\begin{lispfunction}{mk-greatereq}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-greater}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-lesseq}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-less}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-floor}{a1}
\end{lispfunction}

\begin{lispfunction}{mk-null-expr}{}
\end{lispfunction}

\begin{lispfunction}{mk-list-expr}{exprs}
\end{lispfunction}

\begin{lispfunction}{mk-list-expr*}{exprs result}
\end{lispfunction}

\begin{lispfunction}{mk-bindings}{vars}
\end{lispfunction}

\begin{lispfunction}{mk-bindings*}{vars \ampoptional result}
\end{lispfunction}

\begin{lispfunction}{mk-chained-bindings}{bindings}
\end{lispfunction}

\begin{lispfunction}{mk-bind-decl}{id dtype \ampoptional type}
\end{lispfunction}

\begin{lispfunction}{mk-arg-bind-decl}{id dtype \ampoptional type}
\end{lispfunction}

\begin{lispfunction}{mk-assignment}{flag arguments expression}
\end{lispfunction}

\begin{lispfunction}{mk-maplet}{flag arguments expression}
\end{lispfunction}

\begin{lispfunction}{mk-actual}{arg}
\end{lispfunction}

\begin{lispfunction}{mk-mapping}{lhs rhs}
\end{lispfunction}

\begin{lispfunction}{mk-mapping-rhs}{ex}
\end{lispfunction}

\begin{lispfunction}{mk-field-name-expr}{id res}
\end{lispfunction}

\begin{lispfunction}{mk-arg-tuple-expr*}{args}
\end{lispfunction}

\begin{lispfunction}{mk-arg-tuple-expr}{\amprest args}
\end{lispfunction}

\begin{lispfunction}{mk-sum}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-difference}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-product}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-division}{a1 a2}
\end{lispfunction}

\begin{lispfunction}{mk-implies-operator}{}
\end{lispfunction}


\subsubsection*{\functionnm{make-} Functions}

\begin{lispfunction}{make-tuple-expr}{exprs \ampoptional expected}
\end{lispfunction}

\begin{lispfunction}{make-record-expr}{assignments expected}
\end{lispfunction}

\begin{lispfunction}{make-cases-expr}{expr selections else}
\end{lispfunction}

\begin{lispfunction}{make-arg-tuple-expr}{args}
\end{lispfunction}

\begin{lispfunction}{make-application*}{op arguments}
\end{lispfunction}
                 
\begin{lispfunction}{make-application}{op \amprest arguments}
\end{lispfunction}

\begin{lispfunction}{make-projection-application}{index arg}
\end{lispfunction}

\begin{lispfunction}{make-field-application}{field-name arg}
\end{lispfunction}

\begin{lispfunction}{make-projections}{expr \ampoptional type}
\end{lispfunction}

\begin{lispfunction}{projection-application-type}{projapp type}
\end{lispfunction}

\begin{lispfunction}{field-application-types}{types expr}
\end{lispfunction}

\begin{lispfunction}{field-application-type}{field type arg}
\end{lispfunction}

\begin{lispfunction}{make-if-expr}{cond then else}
\end{lispfunction}

\begin{lispfunction}{make-chained-if-expr}{cond then else}
\end{lispfunction}

\begin{lispfunction}{make-equation}{lhs rhs}
\end{lispfunction}

\begin{lispfunction}{make-implication}{ante succ}
\end{lispfunction}

\begin{lispfunction}{make-iff}{ante succ}
\end{lispfunction}

\begin{lispfunction}{make-conjunction}{args}
\end{lispfunction}

\begin{lispfunction}{make-disjunction}{args}
\end{lispfunction}

\begin{lispfunction}{make-negation}{arg}
\end{lispfunction}

\begin{lispfunction}{make-lambda-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{make-forall-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{make-exists-expr}{vars expr}
\end{lispfunction}

\begin{lispfunction}{make-null-expr}{type}
\end{lispfunction}

\begin{lispfunction}{make-list-expr}{exprs \ampoptional type}
\end{lispfunction}

\begin{lispfunction}{make-number-expr}{number}
\end{lispfunction}

\begin{lispfunction}{make-difference}{a1 a2 type}
\end{lispfunction}

\begin{lispfunction}{make-assignment}{arg expression}
\end{lispfunction}

\begin{lispfunction}{make-update-expr}{expression assignments \ampoptional
expected}
\end{lispfunction}

\begin{lispfunction}{make-greatereq}{x y}
\end{lispfunction}

\begin{lispfunction}{make-greater}{x y}
\end{lispfunction}

\begin{lispfunction}{make-lesseq}{x y}
\end{lispfunction}

\begin{lispfunction}{make-less}{x y}
\end{lispfunction}

\begin{lispfunction}{make-floor}{x}
\end{lispfunction}

\begin{lispfunction}{make-implication}{}
\end{lispfunction}

\begin{lispfunction}{make-conjunction}{}
\end{lispfunction}

\begin{lispfunction}{make-disjunction}{}
\end{lispfunction}

\begin{lispfunction}{make-lambda-expr}{}
\end{lispfunction}

\begin{lispfunction}{make-equality}{}
\end{lispfunction}

\begin{lispfunction}{negate}{}
\end{lispfunction}

\begin{lispfunction}{universal-closure}{form}
\end{lispfunction}

\begin{lispfunction}{existential-closure}{form}
\end{lispfunction}

\begin{lispfunction}{mk-everywhere-true-function}{type}
\end{lispfunction}

\begin{lispfunction}{mk-everywhere-false-function}{type}
\end{lispfunction}

\begin{lispfunction}{mk-identity-fun}{te}
\end{lispfunction}

\subsubsection*{\functionnm{make!-} Functions}

\begin{functioni}{make!-applications}{make"!-applications}{op args-list}
\end{functioni}

\begin{functioni}{make!-application*}{make"!-application*}{op arguments}
\end{functioni}

\begin{functioni}{make!-application}{make"!-application}{op \amprest args}
\end{functioni}

\begin{functioni}{make!-reduced-application}{make"!-reduced-application}{op arg}
\end{functioni}

\begin{functioni}{make!-number-expr}{make"!-number-expr}{number}
\end{functioni}

\begin{functioni}{make!-name-expr}{make"!-name-expr}{id actuals mod-id res}
\end{functioni}
    
\begin{functioni}{make!-equation}{make"!-equation}{lhs rhs}
\end{functioni}

\begin{functioni}{make!-disequation}{make"!-disequation}{lhs rhs}
\end{functioni}

\begin{functioni}{make!-if-expr}{make"!-if-expr}{cond then else}
\end{functioni}

\begin{functioni}{make!-chained-if-expr}{make"!-chained-if-expr}{cond then else}
\end{functioni}

\begin{functioni}{make!-if-expr*}{make"!-if-expr*}{cond then else chained?}
\end{functioni}

\begin{functioni}{make!-arg-tuple-expr}{make"!-arg-tuple-expr}{\amprest args}
\end{functioni}

\begin{functioni}{make!-arg-tuple-expr*}{make"!-arg-tuple-expr*}{args}
\end{functioni}

\begin{functioni}{make!-projected-arg-tuple-expr}{make"!-projected-arg-tuple-expr}{\amprest args}
\end{functioni}

\begin{functioni}{make!-projected-arg-tuple-expr*}{make"!-projected-arg-tuple-expr*}{args}
\end{functioni}

\begin{functioni}{make!-tuple-expr}{make"!-tuple-expr}{\amprest exprs}
\end{functioni}

\begin{functioni}{make!-tuple-expr*}{make"!-tuple-expr*}{exprs}
\end{functioni}

\begin{functioni}{make!-projections}{make"!-projections}{expr}
\end{functioni}

\begin{functioni}{make!-projections*}{make"!-projections*}{types arg index projapps}
\end{functioni}

\begin{functioni}{make!-projection-application}{make"!-projection-application}{index arg}
\end{functioni}

\begin{functioni}{make!-projection-type*}{make"!-projection-type*}{types index ctr arg}
\end{functioni}

\begin{functioni}{make!-injection-application}{make"!-injection-application}{index arg type}
\end{functioni}

\begin{functioni}{make!-injection?-application}{make"!-injection?-application}{index arg}
\end{functioni}

\begin{functioni}{make!-extraction-application}{make"!-extraction-application}{index arg}
\end{functioni}

\begin{functioni}{make!-field-application}{make"!-field-application}{field-name arg}
\end{functioni}

\begin{functioni}{make!-field-application-type}{make"!-field-application-type}{field-id type arg}
\end{functioni}

\begin{functioni}{make!-field-application-type*}{make"!-field-application-type*}{fields field-id arg}
\end{functioni}

\begin{functioni}{make!-update-expr}{make"!-update-expr}{expression assignments}
\end{functioni}

\begin{functioni}{make!-negation}{make"!-negation}{ex}
\end{functioni}

\begin{functioni}{make!-conjunction}{make"!-conjunction}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-conjunction*}{make"!-conjunction*}{exprs}
\end{functioni}

\begin{functioni}{make!-conjunction**}{make"!-conjunction**}{exprs conj}
\end{functioni}

\begin{functioni}{make!-disjunction}{make"!-disjunction}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-disjunction*}{make"!-disjunction*}{exprs}
\end{functioni}

\begin{functioni}{make!-disjunction**}{make"!-disjunction**}{exprs disj}
\end{functioni}

\begin{functioni}{make!-implication}{make"!-implication}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-iff}{make"!-iff}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-plus}{make"!-plus}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-difference}{make"!-difference}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-minus}{make"!-minus}{ex}
\end{functioni}

\begin{functioni}{make!-times}{make"!-times}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-divides}{make"!-divides}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-forall-expr}{make"!-forall-expr}{bindings expr}
\end{functioni}

\begin{functioni}{make!-exists-expr}{make"!-exists-expr}{bindings expr}
\end{functioni}

\begin{functioni}{make!-lambda-expr}{make"!-lambda-expr}{bindings expr}
\end{functioni}

\begin{functioni}{make!-set-expr}{make"!-set-expr}{bindings expr}
\end{functioni}

\begin{functioni}{make!-bind-decl}{make"!-bind-decl}{id type-expr}
\end{functioni}

\begin{functioni}{make!-floor}{make"!-floor}{ex}
\end{functioni}

\begin{functioni}{make!-succ}{make"!-succ}{ex}
\end{functioni}

\begin{functioni}{make!-pred}{make"!-pred}{ex}
\end{functioni}

\begin{functioni}{make!-expr-as-type}{make"!-expr-as-type}{pred}
\end{functioni}

\begin{functioni}{make!-unpack-expr}{make"!-unpack-expr}{expr selections \ampoptional else-part}
\end{functioni}

\begin{functioni}{make!-unary-minus}{make"!-unary-minus}{ex}
\end{functioni}

\begin{functioni}{make!-less}{make"!-less}{ex1 ex2}
\end{functioni}

\begin{functioni}{make!-lesseq}{make"!-lesseq}{ex1 ex2}
\end{functioni}


\subsection{Comparison Functions}

\begin{lispfunction}{tc-eq}{x y}
\end{lispfunction}

\begin{lispfunction}{tc-eq-with-bindings}{x y bindings}
\end{lispfunction}

\begin{lispfunction}{strong-tc-eq}{x y}
\end{lispfunction}

\begin{lispfunction}{compatible?}{atype etype}
\end{lispfunction}

\begin{lispfunction}{strict-compatible?}{(atype etype}
\end{lispfunction}

\begin{lispfunction}{compatible-type}{t1 t2}
\end{lispfunction}

\begin{lispfunction}{compatible-types}{list-of-types}
\end{lispfunction}

\begin{lispfunction}{compatible-preds}{atype etype aexpr}
\end{lispfunction}

\begin{lispfunction}{subtype-of?}{(t1 t2}
\end{lispfunction}

\begin{lispfunction}{tc-match}{t1 t2 bindings \ampoptional strict-matches}
\end{lispfunction}

\begin{lispfunction}{simple-match}{ex inst}
\end{lispfunction}

\begin{lispfunction}{match}{expr instance bind-alist subst}
\end{lispfunction}


\subsection{Substitution Functions}

\begin{lispfunction}{copy}{}
\end{lispfunction}

\begin{lispfunction}{lcopy}{obj \amprest initargs}
\end{lispfunction}

\begin{lispfunction}{substit}{}
\end{lispfunction}

\begin{lispfunction}{gensubst}{obj substfn testfn}
\functionnm{gensubst} walks down the term \functionarg{obj}, applying the
\functionarg{testfn} function to each subterm recursively.  If it returns
a non-nil value, then the \functionarg{substfn} function is applied.  If
it results in a term that is not \texttt{eq} to the original term, it
causes a creation of copies of the branch leading to the substitution
term.  Note that there is no check for type correctness; the substitution
is made blindly.  If you are simply substituting terms for variables, use
substit instead, as this is faster and guaranteed to be type correct if
the bindings are.  An example using \texttt{gensubst} is
\texttt{expose-binding-types}, which is applied to TCCs so that the types
are made visible.
\begin{alltt}
(defun expose-binding-types (expr)
  (let ((*visible-only* t))
    (gensubst expr #'expose-binding-types! #'expose-binding-types?)))

(defmethod expose-binding-types? (ex)
  (declare (ignore ex))
  nil)

(defmethod expose-binding-types? ((ex type-application))
  t)

(defmethod expose-binding-types? ((ex untyped-bind-decl))
  t)

(defmethod expose-binding-types! ((ex type-application))
  ex)

(defmethod expose-binding-types! ((ex untyped-bind-decl))
  (let ((dtype (or (and (type ex) (print-type (type ex)))
		   (declared-type ex)
		   (type ex))))
    (if dtype
	(change-class (copy ex 'declared-type dtype) 'bind-decl)
	ex)))
\end{alltt}

There are two global variables that affect \functionnm{gensubst}.  
\texttt{*parsing-or-unparsing*} says whether the term has been
typechecked, and \texttt{*visible-only*} will only go down the visible
subterms; in particular, it will only affect declared types (reflected in
the \texttt{print-type} slot), not the expanded canonical form of the
type.

\end{lispfunction}

\begin{lispfunction}{subst-theory-params}{term alist}
\end{lispfunction}

\begin{lispfunction}{subst-mod-params}{obj modinst \ampoptional theory}
\end{lispfunction}


\subsection{Prover Functions}

\subsubsection{Defining Rules and Strategies}

The following macros allow rules and strategies to be defined.  Every rule
and strategy has associated with it a list of arguments, a body, a
documentation string, and a format string.  The \functionnm{addrule} macro
has separate lists for the required and optional arguments, for the other
macros they are separated by \ampoptional, as in Lisp.  The docstring
simply describes the rule or strategy, and is used by the
\functionnm{help} rule.  The format string is used to provide commentary,
and has the form of a Lisp \functionnm{format} string, with arguments
corresponding to the arguments of the rule or strategy.  A simple example
is the format string for \functionnm{simple-induct}:
\begin{alltt}
(defstep simple-induct (var fmla &optional name)
  \ldots
  "Inducting on \tilde a with formula \tilde a")
\end{alltt}
Here the first \texttt{\tilde a} is matched to \texttt{var}, and the second to
\texttt{fmla}.  A more complicated example is
\functionnm{install-rewrites}:
\begin{alltt}
(defstep install-rewrites (&optional defs theories rewrites
                                     exclude-theories exclude)
  \ldots
  "Installing rewrite rules from\tilde
\tilde@[\tilde\% definitions (\tilde a) in the sequent\tilde]\tilde
\tilde@[,\tilde\% theories: \tilde a\tilde]\tilde
\tilde@[,\tilde\% rewrites: \tilde a\tilde]\tilde
\tilde@[,\tilde\%and excluding theories: \tilde a\tilde]\tilde
\tilde@[,\tilde\%and excluding rewrites: \tilde a\tilde]")
\end{alltt}
In this case, the \texttt{\tilde@[ ... \tilde]} control forms are
displayed only if the corresponding argument is not \texttt{nil}, which is
appropriate for optional arguments.  See the Common Lisp Reference for
full details on \texttt{format} control strings.

\paragraph{Strategies and Defined Rules}

\paragraph{Primitive Rules}

\begin{macro}{addrule}
  {name required-args optional-args body docstring \ampoptional format-string}
This macro is used to add primitive rules to PVS. \functionarg{name} is an
identifier, \functionarg{required-args} is a list of identifiers, and
\functionarg{optional-args} is a list of identifiers, optionally with one
\texttt{\&rest} keyword anywhere before the last identifier.
\functionarg{body} is a Lisp expression, that should refer to the identifiers
in \functionarg{required-args} and \functionarg{optional-args}.
\functionarg{docstring} is a string that describes the rule (this is
displayed by the \functionnm{help} command), and
\functionarg{format-string} is used to generate the running commentary.
\functionarg{format-string} is a format control string, and is applied to
the argument list obtained by concatenating \functionarg{required-args}
and \functionarg{optional-args}.

Here is an example.
\begin{alltt}
(addrule 'foo (req) ((opt 3) \amprest rest)
  (foo-fun req opt rest)
  "Fooify the sequent"
  "Fooifying ~a as ~d using ~\{~a, ~\}")
\end{alltt}
The \texttt{foo} rule has the required argument \texttt{req}, an optional
argument \texttt{opt}, which, if not provided, defaults to the value
\texttt{3}, and a argument \texttt{rest} that is a list of the remaining
arguments.  The body simply invokes a Lisp function named
\texttt{foo-fun}, passing along the arguments.  This is typical, and makes
debugging easier.  This rule might be invoked as
\begin{alltt}
 (foo \"x + 1\" 6 a b c)
\end{alltt}
in which case \texttt{foo-fun} will be called with
\begin{alltt}
 (foo \"x + 1\" 6 (a b c))
\end{alltt}



\functionarg{addrule} creates a \classhln{rule-entry}, adds it to the
\globalhln{*rulebase*}, and adds the \functionarg{name} to
\globalhln{*rulenames*}.  It then creates an entry and adds it to
\globalhln{*prover-keywords*}; this entry is a list consisting of the
\functionarg{name}, a flag (\texttt{t} if there is an \texttt{\&rest}
argument), and a list of keywords created from the arguments.  In the case
above, the entry is
\begin{alltt}
  (foo t :req :opt :rest)
\end{alltt}

\end{macro}

\paragraph{Prover Errors and Messages}

Various errors and messages are possible in executing commands.  It is
important to get these right, otherwise the user of the command will not
understand what happened.  Note that it is not enough to get it right at
the top level, one must always take into account that the command may be
invoked from deep within another strategy, so the printout should either
be suppressed or continue to make sense in this context.

The main printout is from the \functionarg{format-string} which is a
format string that is applied to the actual arguments of the command.
There are several other ways to write out information, and these are often
necessary when it is desired to display intermediate results, for example,
the instantiations actually found in an \texttt{inst?} invocation.

One way of producing printout is with the \texttt{skip-msg} rule.  This
takes a string as an argument, prints out the string, and acts as a
\texttt{skip} otherwise.  By default, if the command is not at the top
level, the message is not printed, but the optional argument
\functionarg{force-printing?} causes it to be printed no matter where it
occurs.  Note that the message must be a string, not a form that evaluates
to a string.  A common pattern of use is
\begin{alltt}
  (defstep foo ()
    \ldots
    (let ((msg (format nil "The argument is: ~a" argument)))
      (skip-msg msg))
    \ldots
  )
\end{alltt}
It's important to remember that 

\begin{macro}{defrule}{name args body doc format}
\end{macro}

\begin{macro}{defstrat}{name args body doc \ampoptional format}
\end{macro}

\begin{macro}{defstep}{name args body doc format}
\end{macro}

\begin{macro}{defhelper}{name args body doc format}
\end{macro}

\begin{macro}{format-if}{string \amprest args}
\end{macro}

\begin{macro}{error-format-if}{string \amprest args}
\end{macro}

\begin{macro}{restore}{}
\end{macro}

\begin{lispfunction}{prove}{name \ampkey strategy}
\end{lispfunction}

\begin{lispfunction}{simplify-expression}
  {expr module-name strategy \ampoptional display? \textup{(}id \textup{'simplify-expr}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{simplify-expr}
  {expr module-name strategy \ampoptional display? \textup{(}id \textup{'simplify-expr}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{prove-decl}{decl \ampkey strategy context}
\end{lispfunction}

\begin{lispfunction}{check-command-arguments}
  {cmd keywords arguments has-rest? \ampoptional expect-key?}
\end{lispfunction}

\begin{lispfunction}{select-seq}{seq nums}
\end{lispfunction}

\begin{lispfunction}{delete-seq}{seq nums}
\end{lispfunction}

\begin{lispfunction}{gather-seq}
  {seq yesnums nonums \ampoptional \textup{(}pred \textup{\#'always-true}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{gather-fnums}
  {sforms yesnums nonums \ampoptional \textup{(}pred \textup{\#'always-true}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{find-all-sformnums}{sforms sformnums pred}
\end{lispfunction}

\begin{lispfunction}{find-sform}
  {sforms sformnum \ampoptional \textup{(}pred \textup{\#'always-true}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{pos-s-forms}{s-forms}
\end{lispfunction}

\begin{lispfunction}{neg-s-forms}{s-forms}
\end{lispfunction}

\begin{lispfunction}{seq-formula}{sform}
\end{lispfunction}

\begin{lispfunction}{count-proofstates}{ps \ampoptional \textup{(}num \textup{0}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{select-seq}{}
\end{lispfunction}

\begin{lispfunction}{s-forms}{}
\end{lispfunction}

\begin{lispfunction}{current-goal}{}
\end{lispfunction}

\begin{lispfunction}{formula}{}
\end{lispfunction}

\begin{lispfunction}{new-sko-symbol}{}
\end{lispfunction}

\begin{lispfunction}{find-all-sformnums}{}
\end{lispfunction}

\begin{lispfunction}{delete-seq}{}
\end{lispfunction}

\begin{lispfunction}{find-quant-terms}{}
\end{lispfunction}

\begin{lispfunction}{substitutable-vars}{}
\end{lispfunction}

\begin{lispfunction}{match}{}
\end{lispfunction}

\begin{lispfunction}{create-formulas}{}
\end{lispfunction}

\begin{lispfunction}{collect-subterms}{}
\end{lispfunction}


\subsection{Predicates}

\begin{lispfunction}{recognizer?}{}
\end{lispfunction}

\begin{lispfunction}{datatype-subtype?}{}
\end{lispfunction}

\begin{lispfunction}{not-expr?}{}
\end{lispfunction}

\begin{lispfunction}{typed?}{(expr}
\end{lispfunction}

\begin{lispfunction}{fully-typed?}{obj}
\end{lispfunction}

\begin{lispfunction}{fully-instantiated?}{(obj}
\end{lispfunction}

\begin{lispfunction}{ground-arithmetic-term?}{(expr}
\end{lispfunction}

\begin{lispfunction}{constant?}{expr}
\end{lispfunction}

\begin{lispfunction}{variable?}{expr}
\end{lispfunction}

\begin{lispfunction}{from-prelude?}{obj}
\end{lispfunction}

\begin{lispfunction}{quant-occurs?}{expr}
\end{lispfunction}

\begin{lispfunction}{connective-occurs?}{expr}
\end{lispfunction}

\begin{lispfunction}{update-or-connective-occurs?}{expr}
\end{lispfunction}

\begin{lispfunction}{record-redex?}{expr}
\end{lispfunction}

\begin{lispfunction}{function-update-redex?}{expr}
\end{lispfunction}

\begin{lispfunction}{accessor-update-redex?}{expr}
\end{lispfunction}

\begin{lispfunction}{integer-expr?}{(ex application)}
\end{lispfunction}

\begin{lispfunction}{record-update-redex?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-predicate?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-plus?}{op}
\end{lispfunction}

\begin{lispfunction}{is-minus?}{op}
\end{lispfunction}

\begin{lispfunction}{is-sub-minus?}{op}
\end{lispfunction}

\begin{lispfunction}{is-mult?}{op}
\end{lispfunction}

\begin{lispfunction}{is-div?}{op}
\end{lispfunction}

\begin{lispfunction}{is-division?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-addition?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-subtraction?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-unary-minus?}{expr}
\end{lispfunction}

\begin{lispfunction}{is-multiplication?}{expr}
\end{lispfunction}

\begin{lispfunction}{negative-number?}{expr}
\end{lispfunction}

\begin{lispfunction}{arithop-decl?}{x}
\end{lispfunction}

\begin{lispfunction}{occurs-in}{x y}
\end{lispfunction}

\begin{lispfunction}{id-occurs-in}{id y}
\end{lispfunction}

\begin{lispfunction}{proved?}{(fdecl}
\end{lispfunction}

\begin{lispfunction}{unproved?}{(formula-decl}
\end{lispfunction}

\begin{lispfunction}{parsed-file?}{(filename}
\end{lispfunction}

\begin{lispfunction}{parsed?}{mod}
\end{lispfunction}

\begin{lispfunction}{possibly-empty-type?}{(te}
\end{lispfunction}

\begin{lispfunction}{special-variable-p}{obj}
\end{lispfunction}


\subsection{Utility Functions}

\begin{lispfunction}{get-theory}{}
\end{lispfunction}

\begin{lispfunction}{freevars}{}
\end{lispfunction}

\begin{lispfunction}{find-supertype}{}
\end{lispfunction}

\begin{lispfunction}{mapobject}{}
\end{lispfunction}

\begin{lispfunction}{file-older}{file1 file2}
\end{lispfunction}

\begin{lispfunction}{add-decl}
  {decl \ampoptional \textup{(}insert? \textup{t}\textup{)} \textup{(}generated? \textup{t}\textup{)} assuming?}
\end{lispfunction}

\begin{lispfunction}{compare}{old new}
\end{lispfunction}

\begin{lispfunction}{get-pvs-file-dependencies}{filename}
\end{lispfunction}

\begin{lispfunction}{get-theory-dependencies}{theoryid}
\end{lispfunction}

\begin{lispfunction}{collect-theories}{}
\end{lispfunction}

\begin{lispfunction}{find-all-usedbys}{theoryref}
\end{lispfunction}

\begin{lispfunction}{adt-generated-theories}{adt}
\end{lispfunction}

\begin{lispfunction}{collect-conjuncts}{(ex conjunction)}
\end{lispfunction}

\begin{lispfunction}{collect-disjuncts}{(ex disjunction)}
\end{lispfunction}

\begin{lispfunction}{type-canon}{te}
\end{lispfunction}

\begin{lispfunction}{free-params}{obj}
\end{lispfunction}

\begin{lispfunction}{mapobject}{fn obj}
\end{lispfunction}

\begin{lispfunction}{judgement-types+}{expr}
\end{lispfunction}

\begin{lispfunction}{judgement-types}{ex}
\end{lispfunction}

\begin{lispfunction}{type-constraints}{ex \ampoptional all?}
\end{lispfunction}

\begin{lispfunction}{show-expanded-form}
  {oname origin pos1 \ampoptional \textup{(}pos2 pos1\textup{)} all?}
\end{lispfunction}

\begin{macro}{makesym}{ctl \amprest args}
\end{macro}

\begin{macro}{with-no-type-errors}{\amprest forms}
\end{macro}

\begin{macro}{with-no-parse-errors}{\amprest forms}
\end{macro}

\begin{lispfunction}{valid-pvs-id}{symbol}
\end{lispfunction}

\begin{lispfunction}{unparse}
  {obj \ampkey string stream file char-width length level lines \textup{(}pretty \textup{t}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{unpindent}
  {inst indent \ampkey \textup{(}width \globalhln{*default-char-width*}\textup{)} length level lines string comment?}
\end{lispfunction}

\begin{lispfunction}{clear-theories}{\ampoptional all?}
\end{lispfunction}

\begin{lispfunction}{get-pvs-version-information}{}
\end{lispfunction}

\begin{lispfunction}{all-importings}{theory \ampoptional lib}
\end{lispfunction}

\begin{lispfunction}{prove-unproved-tccs}{theories \ampoptional importchain?}
\end{lispfunction}

\begin{lispfunction}{quit}{\ampoptional status}
\end{lispfunction}

\begin{lispfunction}{get-parsed-theory}{theoryref}
\end{lispfunction}

\begin{lispfunction}{get-typechecked-theory}{theoryref \ampoptional theories}
\end{lispfunction}

\begin{lispfunction}{get-decl-at}{line class theories}
\end{lispfunction}

\begin{lispfunction}{get-decls}{ref}
\end{lispfunction}

\begin{lispfunction}{locality}{ex}
\end{lispfunction}

\begin{lispfunction}{set-type}{ex expected}
\end{lispfunction}

\begin{lispfunction}{expand1}{ex}
\end{lispfunction}

\begin{lispfunction}{lambda-binding-number}{ex}
\end{lispfunction}

\begin{lispfunction}{get-arithmetic-value}{expr}
\end{lispfunction}

\begin{lispfunction}{cartesian-product}
  {list-of-lists \ampoptional \textup{(}result \textup{(list nil)}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{load-prelude}{}
\end{lispfunction}

\begin{lispfunction}{merge-proofs-into-updated-prelude}{file}
\end{lispfunction}

\begin{lispfunction}{save-prelude-proofs}{}
\end{lispfunction}

\begin{lispfunction}{prove-prelude}{\ampoptional retry? use-default-dp?}
\end{lispfunction}

\begin{lispfunction}{trace-methods}{funsym}
\end{lispfunction}

;; Discuss metering

\begin{lispfunction}{types}{ex}
\end{lispfunction}

\begin{lispfunction}{typecheck-uniquely}{expr \ampkey \textup{(}tccs \textup{'all given}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{get-immediate-usings}{theory}
\end{lispfunction}

\begin{lispfunction}{lf}{file \ampoptional force}
\end{lispfunction}

\begin{lispfunction}{show}{obj}
\end{lispfunction}

\begin{lispfunction}{run-program}{command \ampkey arguments}
\end{lispfunction}

\begin{lispfunction}{environment-variable}{string}
\end{lispfunction}

\begin{lispfunction}{chmod}{prot file}
\end{lispfunction}

\begin{lispfunction}{get-theory}{name}
\end{lispfunction}

\begin{lispfunction}{context}{obj}
\end{lispfunction}

\begin{lispfunction}{make-new-context}{theory}
\end{lispfunction}

\begin{functioni}{translate-update-to-if!}{translate-update-to-if"!}{((expr update-expr)}
\end{functioni}

\begin{lispfunction}{find-supertype}{(te subtype)}
\end{lispfunction}

\begin{lispfunction}{pseudo-normalize}{expr \ampoptional include-typepreds?}
\end{lispfunction}

\begin{lispfunction}{operator*}{expr}
\end{lispfunction}

\begin{lispfunction}{argument*}{expr \ampoptional args}
\end{lispfunction}

\begin{lispfunction}{current-theory}{}
\end{lispfunction}

\begin{lispfunction}{current-theory-name}{}
\end{lispfunction}

\begin{lispfunction}{current-declaration}{}
\end{lispfunction}

\begin{lispfunction}{lift-predicates-in-quantifier}{ex \ampoptional exclude}
\end{lispfunction}

\begin{lispfunction}{collect-references}{ex}
\end{lispfunction}

\begin{lispfunction}{collect-type-constraints}{expr}
\end{lispfunction}

\begin{lispfunction}{arity}{expr}
\end{lispfunction}

\begin{lispfunction}{beta-reduce}{obj \ampoptional \textup{(}let-reduce? \textup{t}\textup{)}}
\end{lispfunction}

\begin{lispfunction}{or+}{forms}
\end{lispfunction}

\begin{lispfunction}{and+}{form \ampoptional depth}
\end{lispfunction}

\begin{lispfunction}{freevars}{obj}
\end{lispfunction}

\begin{lispfunction}{conjuncts}{fmla}
\end{lispfunction}

\begin{lispfunction}{disjuncts}{fmla}
\end{lispfunction}


\section{Prettyprinting}

\section{Error Handling}
\label{error-handling}

\section{PVS Development Hints}

\subsection{Lisp Name Conflicts}

PVS defines a lot of functions, macros, and variables, and if you define a
new function without first checking, you may find that you have redefined
an existing function.  This can often be difficult to debug, so it is
better to check beforehand, using \texttt{describe}\index{describe} on the
name first.  If it indicates that it already has a definition, change the
name.  Thus you might create a function that builds a quantified formula,
and a subfunction that creates new bindings for it.  It would seem that
\texttt{make-new-bindings} is an ideal name for it, until you check.
\begin{alltt}
  pvs(22): (describe 'make-new-bindings)
  make-new-bindings is a symbol.
    It is unbound.
    It is internal in the pvs package.
    Its function binding is #<Function make-new-bindings>
      The function takes arguments (old-bindings alist expr)
    Its property list has these indicator/value pairs:
  excl::dynamic-extent-arg-template  nil
  pvs(23):
\end{alltt}
So you try a different name.  Since the formula being constructed is
really specific to foos, you try again:
\begin{alltt}
pvs(23): (describe 'make-new-bindings-for-foos)
  make-new-bindings-for-foos is a symbol.
    It is unbound.
    It is internal in the pvs package.
  pvs(24):
\end{alltt}

Another technique is to define a file with functions, not worrying about
the names used.  Then load the file manually, and watch carefully for any
warnings that indicate you are overwriting an existing entity.  This
technique is also useful when two or more people have developed their own
lisp files, and don't know whether they have any naming problems.

There are approaches to avoiding this problem.  You can use packages, as
long as your package name is unique, and you don't import names into the
PVS package without checking, there is no possible way for a conflict to
be introduced.  This is a good technique, though the Common Lisp package
mechanism can be confusing, and at times inconvenient.

A simpler approach is to use long, specific names for your functions.
Lisp has no restriction on the length of it's names, though if you use
other outside tools, like grep, you may find that it is best to use fewer
than 255 character names, as some shells have this restriction.


For one thing, I often restart just the lisp image, rather than all of
PVS.  I do this by going to the *pvs* buffer, and typing "(quit)y" or
by clicking on "KILL" in the "Signals" button on the menu bar (which
only shows when the *pvs* buffer is current).  Then I restart pvs
using M-x pvs.  This way all my Emacs buffers, as well as proof
command history (e.g., for M-p, M-s), etc. are still available.

Another undocumented command is (clear-theories).  If you type this in
at the prompt in the *pvs* buffer, the current context is cleared.  If
you invoke (clear-theories t), then all libraries are cleared out as
well.  This does not affect bin files.  In debugging I was often just
running 'rm */*.bin' and (clear-theories t) to get a fresh typecheck.
So in your instructions
  "in the attached sources typecheck sc\_prelude/label.pvs and quit pvs
   to create the bin files. Typechecking label.pvs again yields an
   error"
I instead would typecheck label, run M-x sc (which creates the bin
files), then (clear-theories t) and typecheck again.

\subsection{Debugging Hints}

initialize-instance :around

(setf foo) :around

trace-methods

\chapter{The Back End: Proof Engine Interface}

In this chapter we describe how to interface new rules and decision
procedures.  Much of the difficulty here is that these are often
implemented in a language other than lisp, so efficiency considerations
often require a foreign function interface, with special care needed so
that the garbage collector does not have any memory leaks, or worse, leave
dangling pointers.  This is exacerbated if the other language has its own
garbage collector, e.g., ocaml or JAVA.

The general model here is that one has an existing engine, and wants to
invoke it from the PVS theorem prover.  To do this, there are several
steps involved:
\begin{enumerate}
\item Define a new proof rule that invokes the engine.
\item Translate the current sequent to the term language of the engine
\item Translate the result(s) to PVS
\item Update the proofstate
\end{enumerate}

\section{Adding New Rules}

\subsection{Defining New Rules: \texttt{addrule}}

\section{Adding New Decision Procedures}

\section{Interfacing with Lisp}

\subsection{The Subprocess Interface}

The simplest approach is to use subprocesses.  In this case, the
engine acts as a black box, input is provided for it, and the output read
in.  Even here, there are many possibilities to consider:
\begin{itemize}
\item Is this a terminating or nonterminating subprocess?
\item How will it obtain its input and report its results?
\item How are error conditions handled?
\end{itemize}

\subsection{The Foreign Function Interface}

\section{Translation of PVS Expressions}

\subsection{Translating Input from PVS Expressions}

\subsection{Translating Output to PVS Expressions}

\section{Updating the Proofstate}

\appendix

\chapter{Secondary Classes}

This Appendix contains secondary classes for completeness.  These classes
should rarely appear as method specializers, unless there is a good
reason, such as writing new prettyprint methods.

\section{Secondary Specification Classes}

\begin{class}{modules}{}{}
{\slotidx{modules} & list of theories and top-level recursive types}
This class exists so in order to print out PVS files containing multiple
theories and top level datatypes.
\end{class}

\begin{class}{adtdecl}{}{\classhln{typed-declaration}}
{\slotidx{bind-decl} & }
\end{class}

\begin{class}{adt-constructor-decl}{}{\classhln{const-decl}}
{\slotidx{ordnum} & }
\end{class}

\begin{class}{adt-recognizer-decl}{}{\classhln{const-decl}}
{\slotidx{ordnum} & }
\end{class}

\begin{class}{adt-accessor-decl}{}{\classhln{const-decl}}{}
\end{class}

\begin{class}{adt-def-decl}{}{\classhln{def-decl}}{}
\end{class}

\section{Secondary Declaration Classes} 

\begin{class}{lib-eq-decl}{}{\classhln{lib-decl}}{}
\end{class}

\begin{class}{uninterpreted-type-name}{}{\classhln{type-name}}{}
\end{class}

\begin{class}{type-application}{}{\classhln{type-expr}}
{\slotidx{type} & \\
 \slotidx{parameters} & }
\end{class}

\begin{class}{datatype-subtype}{}{\classhln{subtype}}
{\slotidx{declared-type} & }
\end{class}

\section{Secondary Type Expression Classes}

\begin{class}{setsubtype}{}{\classhln{subtype}}
{\slotidx{formals} & \\
 \slotidx{formula} & }
\end{class}

\begin{class}{nsetsubtype}{}{\classhln{setsubtype}}{}
\end{class}

\begin{class}{simple-expr-as-type}{}{\classhln{type-expr}}
{\slotidx{expr} & }
\end{class}

\begin{class}{expr-as-type}{}{\classhln{subtype} \classhln{simple-expr-as-type}}{}
\end{class}

\begin{class}{functiontype}{}{\classhln{funtype}}{}
\end{class}

\begin{class}{arraytype}{}{\classhln{funtype}}{}
\end{class}

\begin{class}{domain-tupletype}{}{\classhln{tupletype}}{}
\end{class}

\begin{class}{dep-domain-tupletype}{}{\classhln{domain-tupletype}}
{\slotidx{var-bindings} & }
\end{class}

\paragraph{Type Variables (sort of)}{\ }

\begin{class}{type-var}{}{\classhln{type-name}}{}
\end{class}

\begin{class}{type-variable}{}{\classhln{type-var}}{}
\end{class}

\begin{class}{tup-type-variable}{}{\classhln{type-var}}{}
\end{class}

\begin{class}{cotup-type-variable}{}{\classhln{type-var}}{}
\end{class}

\section{Secondary Expression Classes}

\begin{class}{unary-negation}{}{\classhln{negation} \classhln{unary-application}}{}
\end{class}

\begin{class}{unary-application}{}{\classhln{application}}{}
\end{class}

\begin{class}{mixfix-branch}{}{\classhln{if-expr} \classhln{branch}}{}
\end{class}

\begin{class}{field-name-expr}{}{\classhln{name-expr}}{}
\end{class}

\begin{class}{let-lambda-expr}{}{\classhln{lambda-expr}}{}
LET expressions have been extended to make it more convenient to give
local function definitions, for example, \texttt{LET f(x:\ int) = 7*x IN
f(f(f(x)))}.  These are transformed by the parser into simple lets, e.g.,
\texttt{LET f = LAMBDA (x:\ int):\ 7*x IN f(f(f(x)))}.  The lambda expression
created in this case is an instance of the \texttt{let-lambda-expr} class.
This is just for prettyprinting purposes.
\end{class}

\begin{class}{when-expr}{}{\classhln{implication}}{}
The \texttt{when-expr} class is a little different, when an application
has the booleans \texttt{WHEN} operator, the typechecker changes its class
to \texttt{when-expr}, makes sure there are two arguments as discussed in
the conjunction class, and reverses its arguments.  Thus, again, only the
prettyprinter and related functions need to have methods for this class.
The \texttt{infix-when-expr} subclass is for the infix version of a
\texttt{WHEN} application.
\end{class}

\begin{class}{if-expr}{}{\classhln{application}}{}
This class is really just for prettyprinting; an expression of the
form \texttt{IF a THEN b ELSE c ENDIF} is parsed into an instance of this
class.

This has a subclass \texttt{chained-if-expr}.  When an expression of the
form \texttt{IF a THEN b ELSIF c THEN d ELSE e ENDIF} is parsed, it is
treated the same as \texttt{IF a THEN b ELSE IF c THEN d ELSE e ENDIF
ENDIF}, but the inner \texttt{if-expr} is converted to a
\texttt{chained-if-expr}, so that the prettyprinter and related methods
can handle it properly.

IMPORTANT: you probably don't want to define methods over this class, use
\classhln{branch} or \classhln{application} instead.
\end{class}

\begin{class}{first-cond-expr}{}{\classhln{mixfix-branch}}{}
\end{class}

\begin{class}{single-cond-expr}{}{\classhln{mixfix-branch}}{}
\end{class}

\begin{class}{cond-expr}{}{\classhln{mixfix-branch}}{}
\end{class}

\begin{class}{last-cond-expr}{}{\classhln{mixfix-branch}}{}
\end{class}

\begin{class}{else-condition}{}{\classhln{unary-negation}}{}
\end{class}

\begin{class}{where-expr}{}{\classhln{let-expr}}{}
A \texttt{where-expr} is just syntactic sugar for a \texttt{let-expr}.
This class exists primarily for prettyprinting and related purposes.  As
with the \texttt{let-expr}, there is a \texttt{chained-where-expr}
subclass.
\end{class}

\begin{class}{coercion}{}{\classhln{application}}{}
A coercion of the form \texttt{e ::\ T} is converted into an application
\texttt{(LAMBDA (x:\ T):\ x)(e)}.  Thus this class is for prettyprinting
and related functions.  Note: in the future this may be different for
function types, e.g., \texttt{f ::\ [nat -> nat]} will be translated to
\texttt{(LAMBDA (g:\ [nat -> nat]):\ g)(LAMBDA (x:\ nat):\ x)(f(x))}.  In
other words, coercions on functions will be given the more natural
closure interpretation that when applied to an element of the domain, it
returns an element of the range.
\end{class}

\begin{class}{table-expr}{}{\classhln{expr}}%
{\slotidx{row-expr} & the optional expression associated with rows \\
 \slotidx{col-expr} & the optional expression associated with columns \\
 \slotidx{row-headings} & a list of exprs associated with the rows \\
 \slotidx{col-headings} & a list of exprs associated with the columns \\
 \slotidx{table-entries} & a list of lists of exprs}

Table expressions are translated into \texttt{cond-expr}s or
\texttt{cases-expr}s.  The slots are used to do this.  If
\texttt{row-expr} and \texttt{col-expr} are empty, then the
\texttt{row-heading}s and \texttt{col-heading}s become conditions in the
generated \texttt{cond-expr}(s), which are nested if there are both
\texttt{row-heading}s and \texttt{col-heading}s.  Details may be found in
the language manual.  Note that the slots are used to create the cond
expressions, after which they are only used for prettyprinting.  Thus
functions that modify a table-expr (for example, substitution functions)
must also modify the \texttt{table-expr} slots for the \texttt{table-expr}
to be displayed consistently.

Generally it is unnecessary to create methods for \texttt{table-expr}s.
When they were introduced, the parser and typechecker needed to be
updated, but except for some substitution functions the prover was
untouched.
\end{class}

\begin{class}{cases-table-expr}{}{\classhln{cases-expr} \classhln{table-expr}}{}
This is a subclass of \texttt{table-expr} created when the corresponding
row or column is determined to be a \texttt{cases-expr}.
\end{class}

\begin{class}{cond-table-expr}{}{\classhln{first-cond-expr} \classhln{table-expr}}{}
This is a subclass of \texttt{table-expr} created when the corresponding
row or column is determined to be a \texttt{cond-expr}.
\end{class}

\begin{class}{single-cond-table-expr}{}{\classhln{single-cond-expr} \classhln{table-expr}}{}
This is similar to the \texttt{single-cond-expr} class, created when there
is a single row or column in a table.
\end{class}

\begin{class}{set-expr}{}{\classhln{lambda-expr}}{}
Recall that \texttt{\{x:\ T | p(x)\}} is just alternative syntax for
\texttt{LAMBDA (x:\ T):\ p(x)}.  This is a subclass of
\texttt{lambda-expr}, so that set-exprs are prettyprinted correctly.
\end{class}

\begin{class}{implicit-conversion}{}{\classhln{application}}{}
This is for the application of conversions other than lambda-conversions.
It is much simpler, in that it only involves the application of the found
conversion to the argument.  This class exists so that untypechecking can
remove the application, and so that prettyprinting can print properly when
\texttt{*show-conversions*} is \texttt{nil}.
\end{class}

The \texttt{lambda-conversion} and \texttt{argument-conversion} classes are
associated with lambda-conversions.  For example, suppose we have the
following declarations:
\begin{alltt}
   state: TYPE
   k: [int -> [state -> int]] = (LAMBDA i: (LAMBDA s: i))
   CONVERSION k
   f: [[state -> int] -> bool]
   ss: [state -> int]
\end{alltt}
Then \texttt{f(ss + 1)} is converted by the typechecker to \texttt{(LAMBDA
s: f(ss(s) + 1))}, where the outer \texttt{lambda-expr} is a
\texttt{lambda-conversion} instance and \texttt{ss(s)} is an
\texttt{argument-conversion}.  These class exist so that untypechecking
can remove the conversions, and so that prettyprinting can print properly
when \texttt{*show-conversions*} is \texttt{nil}.

\begin{class}{lambda-conversion}{}{\classhln{lambda-expr}}{}
\end{class}

\begin{class}{argument-conversion}{}{\classhln{application}}{}
\end{class}

\begin{class}{funtype-conversion}{}{\classhln{lambda-expr}}%
{\slotidx{domain-conversion} & the conversion applied to the domain \\
 \slotidx{range-conversion} & the conversion applied to the range \\}
As described in the language manual, when looking for conversions where
the given and expected types are function types, conversions are searched
for the ranges and the domains (contravariantly).  If successful, a
\texttt{funtype-conversion} is created, and the slots set accordingly.
\end{class}

\begin{class}{rectype-conversion}{}{\classhln{lambda-expr}}
{\slotidx{conversions} & the list of conversions found}
As described in the language manual, when looking for conversions where
the given and expected types are record types, conversions are searched
for on the corresponding component types.  If successful, a
\texttt{rectype-conversion} is created, and the \texttt{conversions} slot
set accordingly.
\end{class}

\begin{class}{tuptype-conversion}{}{\classhln{lambda-expr}}
{\slotidx{conversions} & the list of conversions found}
As described in the language manual, when looking for conversions where
the given and expected types are tuple types, conversions are searched
for on the corresponding component types.  If successful, a
\texttt{tuptype-conversion} is created, and the \texttt{conversions} slot
set accordingly.
\end{class}

\begin{class}{uni-assignment}{}{\classhln{assignment}}{}
PVS supports two forms of assignment arguments, e.g., \texttt{x := 3} and
\texttt{(x) := 3}.  The former generates a \texttt{uni-assignment}, but in
all other respects these are the same.  Only the prettyprinter should care.
\end{class}

\begin{class}{uni-maplet}{}{\classhln{maplet} \classhln{uni-assignment}}{}
Same as \texttt{uni-assignment}, but for maplets.
\end{class}

\begin{class}{quoted-assign}{}{\classhln{syntax}}{}
This is a mixin for assignment arguments that are quoted.  For example,
the \texttt{a} in \texttt{`a := 0} or the \texttt{1} in \texttt{`1 := 0}.
\end{class}

\begin{class}{id-assign}{}{\classhln{name-expr} \classhln{quoted-assign}}{}
This is for assignemnt argument identifiers that are quoted, i.e., the
\texttt{a} in \texttt{`a := 0}.  It exists primarily for prettyprinting
purposes.
\end{class}

\begin{class}{field-assign}{}{\classhln{field-assignment-arg} \classhln{id-assign}}{}
\end{class}

\begin{class}{proj-assign}{}{\classhln{number-expr} \classhln{quoted-assign}}{}
\end{class}

\begin{class}{accessor-assignment-arg}{}{\classhln{accessor-name-expr}}{}
\end{class}

\begin{class}{accessor-assign}{}{\classhln{accessor-assignment-arg} \classhln{id-assign}}{}
\end{class}

\section{Secondary Binding Declaration Classes}

\begin{class}{arg-bind-decl}{}{\classhln{bind-decl}}{}
\end{class}

\begin{class}{pred-bind-decl}{}{\classhln{bind-decl}}{}
\end{class}

\begin{class}{untyped-bind-decl}{}{\classhln{bind-decl}}{}
\end{class}

\begin{class}{full-modname}{}{\classhln{modname}}{}
\end{class}

\begin{class}{datatype-modname}{}{\classhln{modname}}{}
\end{class}

\begin{class}{modname-no-tccs}{}{\classhln{modname}}{}
\end{class}

\begin{class}{conversion-resolution}{}{\classhln{resolution}}
{\slotidx{conversion} & an expression}
\end{class}

\begin{class}{lambda-conversion-resolution}{}{\classhln{resolution}}
{\slotidx{k-conv-type} & a type expression}
\end{class}

\begin{class}{recursive-function-resolution}{}{\classhln{resolution}}
{\slotidx{conversion} & an expression}
\end{class}

\begin{class}{store-print-type}{}{}
{\slotidx{print-type} & \\
 \slotidx{type} & }
\end{class}

\chapter{A Prooftree Display Example}
\label{prooftree-example}

Here we give an example of how a different prooftree display could be
created using PVS without the Emacs and Tcl/Tk interfaces.  The
\texttt{prooftree.lisp} file for this example contains the
following.\footnote{Note that this example is actually for PVS version
3.1, it will be simpler in 3.2.}

\begin{alltt}
(in-package :pvs)

(pvs-init)
(setq *pvs-context-path* (shortpath (working-directory)))

(defun pvs-wish-source (file)
  (format t "~%PT:~a" file))

(prove-file-at "prelude" nil 4820 t "prelude" "prelude.pvs" 0 nil t)
\end{alltt}

Running \texttt{pvs -raw -L prooftree.lisp} results in the following output.

\begin{alltt}{\smaller
\% pvs -raw -L prooftree.lisp 

Loading compiled patch file ~/.pvs.lfasl
;   Fast loading /homes/owre/.pvs.lfasl
### Caml startup
### successful
;   Fast loading from bundle code/ffcompat.fasl.
Warning: pvs-wish-source, :operator was defined in
         /project/pvs/pvs3.0/src/prover/wish.lisp and is now being
         defined in /export/u1/homes/owre/pvs3.0/doc/api/prooftree.lisp

PT:/tmp/pvs-47030.p1
PT:/tmp/pvs-47030.p2
PT:/tmp/pvs-47030.p3
nat2bv_rew :  

  |-------
\{1\}   FORALL (bv: bvec[N], val: below(exp2(N))):
        nat2bv(val) = bv IFF bv2nat(bv) = val

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
nat2bv_rew :  

  |-------
\{1\}   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1

PT:/tmp/pvs-47030.p4
PT:/tmp/pvs-47030.p5
Rerunning step: (typepred "nat2bv(val!1)")
Adding type constraints for  nat2bv(val!1),
this simplifies to: 
nat2bv_rew :  

\{-1\}  bv2nat(nat2bv(val!1)) = val!1
  |-------
[1]   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1

PT:/tmp/pvs-47030.p6
PT:/tmp/pvs-47030.p7
Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
nat2bv_rew.1 :  

\{-1\}  nat2bv(val!1) = bv!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   bv2nat(bv!1) = val!1

PT:/tmp/pvs-47030.p8
PT:/tmp/pvs-47030.p9
Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
PT:/tmp/pvs-47030.p10

This completes the proof of nat2bv_rew.1.

nat2bv_rew.2 :  

\{-1\}  bv2nat(bv!1) = val!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   nat2bv(val!1) = bv!1

PT:/tmp/pvs-47030.p11
PT:/tmp/pvs-47030.p12
Rerunning step: (rewrite "bv2nat_inj")
Found matching substitution:
y: bvec[N] gets bv!1,
x gets nat2bv(val!1),
Rewriting using bv2nat_inj, matching in *,
PT:/tmp/pvs-47030.p13

This completes the proof of nat2bv_rew.2.

PT:/tmp/pvs-47030.p14
PT:/tmp/pvs-47030.p15
PT:/tmp/pvs-47030.p16
PT:/tmp/pvs-47030.p17
Q.E.D.

PT:/tmp/pvs-47030.p18
PT:/tmp/pvs-47030.p19

Run time  = 0.20 secs.
Real time = 0.37 secs.
:pvs-loc nil&prelude.pvs&(4820 2 4820 64) :end-pvs-loc
Allegro CL Enterprise Edition
6.2 [Linux (x86)] (Feb 14, 2003 18:42)
Copyright (C) 1985-2002, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.

This development copy of Allegro CL is licensed to:
   [5377] SRI International

;; Optimization settings: safety 1, space 1, speed 3, debug 1.
;; For a complete description of all compiler switches given the
;; current optimization settings evaluate (explain-compiler-settings).
;;---
;; Current reader case mode: :case-sensitive-lower
cl-user(1): 
}\end{alltt}

The contents of the tmp files are as follows:
\begin{alltt}{\smaller
\textbf{/tmp/pvs-47030.p1:}
setup-proof nat2bv_rew bv_nat /export/u1/homes/owre/pvs3.0/doc/api/ 1 1

\textbf{/tmp/pvs-47030.p2:}
delete-proof-subtree nat2bv_rew bv_nat top
proof-num-children nat2bv_rew bv_nat top 0
proof-sequent nat2bv_rew bv_nat top \{nat2bv_rew\} \{
nat2bv_rew :  

  |-------
\{1\}   FORALL (bv: bvec[N], val: below(exp2(N))):
        nat2bv(val) = bv IFF bv2nat(bv) = val
\}
proof-show nat2bv_rew bv_nat top 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p3:}
proof-current nat2bv_rew bv_nat top
\textbf{/tmp/pvs-47030.p4:}
delete-proof-subtree nat2bv_rew bv_nat top
proof-num-children nat2bv_rew bv_nat top 1
proof-rule nat2bv_rew bv_nat top \{(skosimp*)\}
proof-sequent nat2bv_rew bv_nat top \{nat2bv_rew\} \{
nat2bv_rew :  

  |-------
[1]   FORALL (bv: bvec[N], val: below(exp2(N))):
        nat2bv(val) = bv IFF bv2nat(bv) = val
\}
proof-show nat2bv_rew bv_nat top 1
proof-num-children nat2bv_rew bv_nat top.0 0
proof-sequent nat2bv_rew bv_nat top.0 \{nat2bv_rew\} \{
nat2bv_rew :  

  |-------
\{1\}   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1
\}
proof-show nat2bv_rew bv_nat top.0 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p5:}
proof-current nat2bv_rew bv_nat top.0
\textbf{/tmp/pvs-47030.p6:}
delete-proof-subtree nat2bv_rew bv_nat top.0
proof-num-children nat2bv_rew bv_nat top.0 1
proof-rule nat2bv_rew bv_nat top.0 \{(typepred "nat2bv(val!1)")\}
proof-sequent nat2bv_rew bv_nat top.0 \{nat2bv_rew\} \{
nat2bv_rew :  

  |-------
\{1\}   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1
\}
proof-show nat2bv_rew bv_nat top.0 1
proof-num-children nat2bv_rew bv_nat top.0.0 0
proof-sequent nat2bv_rew bv_nat top.0.0 \{nat2bv_rew\} \{
nat2bv_rew :  

\{-1\}  bv2nat(nat2bv(val!1)) = val!1
  |-------
[1]   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1
\}
proof-show nat2bv_rew bv_nat top.0.0 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p7:}
proof-current nat2bv_rew bv_nat top.0.0
\textbf{/tmp/pvs-47030.p8:}
delete-proof-subtree nat2bv_rew bv_nat top.0.0
proof-num-children nat2bv_rew bv_nat top.0.0 2
proof-rule nat2bv_rew bv_nat top.0.0 \{(prop)\}
proof-sequent nat2bv_rew bv_nat top.0.0 \{nat2bv_rew\} \{
nat2bv_rew :  

\{-1\}  bv2nat(nat2bv(val!1)) = val!1
  |-------
[1]   nat2bv(val!1) = bv!1 IFF bv2nat(bv!1) = val!1
\}
proof-show nat2bv_rew bv_nat top.0.0 1
proof-num-children nat2bv_rew bv_nat top.0.0.0 0
proof-sequent nat2bv_rew bv_nat top.0.0.0 \{nat2bv_rew.1\} \{
nat2bv_rew.1 :  

\{-1\}  nat2bv(val!1) = bv!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   bv2nat(bv!1) = val!1
\}
proof-show nat2bv_rew bv_nat top.0.0.0 1
proof-num-children nat2bv_rew bv_nat top.0.0.1 0
proof-sequent nat2bv_rew bv_nat top.0.0.1 \{nat2bv_rew.2\} \{
nat2bv_rew.2 :  

\{-1\}  bv2nat(bv!1) = val!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   nat2bv(val!1) = bv!1
\}
proof-show nat2bv_rew bv_nat top.0.0.1 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p9:}
proof-current nat2bv_rew bv_nat top.0.0.0
\textbf{/tmp/pvs-47030.p10:}
proof-done nat2bv_rew bv_nat top.0.0.0 1
\textbf{/tmp/pvs-47030.p11:}
delete-proof-subtree nat2bv_rew bv_nat top.0.0.0
proof-num-children nat2bv_rew bv_nat top.0.0.0 0
proof-rule nat2bv_rew bv_nat top.0.0.0 \{(assert)\}
proof-sequent nat2bv_rew bv_nat top.0.0.0 \{nat2bv_rew.1\} \{
nat2bv_rew.1 :  

\{-1\}  nat2bv(val!1) = bv!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   bv2nat(bv!1) = val!1
\}
proof-done nat2bv_rew bv_nat top.0.0.0 1
proof-show nat2bv_rew bv_nat top.0.0.0 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p12:}
proof-current nat2bv_rew bv_nat top.0.0.1
\textbf{/tmp/pvs-47030.p13:}
proof-done nat2bv_rew bv_nat top.0.0.1 1
\textbf{/tmp/pvs-47030.p14:}
proof-done nat2bv_rew bv_nat top.0.0 1
\textbf{/tmp/pvs-47030.p15:}
proof-done nat2bv_rew bv_nat top.0 1
\textbf{/tmp/pvs-47030.p16:}
proof-done nat2bv_rew bv_nat top 1
\textbf{/tmp/pvs-47030.p17:}
proof-done nat2bv_rew bv_nat top 1
\textbf{/tmp/pvs-47030.p18:}
delete-proof-subtree nat2bv_rew bv_nat top.0.0.1
proof-num-children nat2bv_rew bv_nat top.0.0.1 0
proof-rule nat2bv_rew bv_nat top.0.0.1 \{(rewrite "bv2nat_inj")\}
proof-sequent nat2bv_rew bv_nat top.0.0.1 \{nat2bv_rew.2\} \{
nat2bv_rew.2 :  

\{-1\}  bv2nat(bv!1) = val!1
[-2]  bv2nat(nat2bv(val!1)) = val!1
  |-------
\{1\}   nat2bv(val!1) = bv!1
\}
proof-done nat2bv_rew bv_nat top.0.0.1 1
proof-show nat2bv_rew bv_nat top.0.0.1 1
layout-proof nat2bv_rew bv_nat 1

\textbf{/tmp/pvs-47030.p19:}
proof-current nat2bv_rew bv_nat \{\}
}\end{alltt}

The contents of the files are calls to Tcl/Tk functions defined in the
\texttt{wish/pvs-support.tcl} file included in the PVS distribution.  The
following briefly describes the intent of the functions.  It is important
to keep in mind that these are intended to support the interactive prover,
so the prooftree display is dynamic, and commands are send as the proof
develops.

\begin{tabularx}{\linewidth}%
{>{\ttfamily}l%
 >{\hsize=.35\hsize\ttfamily\itshape\raggedright\arraybackslash}X%
 >{\hsize=1.65\hsize\raggedright\arraybackslash}X}
setup-proof & fid thid dir ctr & used to initialize a proof display \\
delete-proof-subtree
  & fid thid path
  & deletes the subtree at the node specified by the path; usually done in
    order to replace it with a new node \\
proof-show
  & fid thid path 1
  & recomputes the internal Tcl/Tk structures associated with the proof \\
layout-proof
  & fid thid 1
  & recomputes the layout of the proof window \\
proof-current
  & fid thid path
  & indicates that the specified path is the current one.  If
    the path is empty (\{\}), there is no current path (i.e., the proof of
    the formula is finished) \\
proof-done
  & fid thid path 1
  & indicates the proof on this branch is complete \\
proof-num-children
  & fid thid path num\_children
  & gives the number of children of the specified path \\
proof-rule
  & fid thid path \{rule\}
  & the rule associated with the specified path \\
proof-sequent
  & fid thid path \{label\} \{sequent\}  
  & the sequent associated with the specified path \\
proof-tcc
  & path
  & indicates that the given path is a TCC branch \\
\end{tabularx}

Here \functionarg{fid} is the formula identifier, the \functionarg{thid}
is the theory containing the formula, the \functionarg{path} is the path
from the root to the given sequent, of the form \texttt{top.0.1.3}.

\bibliographystyle{plain}
\bibliography{../pvs}

{\smaller
\printindex
}

\end{document}
