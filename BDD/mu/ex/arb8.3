/* 8-bit Synchronous Arbiter */

/* Init: */
Let S0 = L
tokenout[0],
tokenout[1],
tokenout[2],
tokenout[3],
tokenout[4],
tokenout[5],
tokenout[6],
tokenout[7],
W[0],
W[1],
W[2],
W[3],
W[4],
W[5],
W[6],
W[7]
.
one_of (
  tokenout[0], tokenout[1], tokenout[2], tokenout[3],
  tokenout[4], tokenout[5], tokenout[6], tokenout[7])
& W[0]' & W[1]' & W[2]' & W[3]' & W[4]' & W[5]' & W[6]' & W[7]'
;

let N = L
tokenout[0],
tokenout[1],
tokenout[2],
tokenout[3],
tokenout[4],
tokenout[5],
tokenout[6],
tokenout[7],
W[0],
W[1],
W[2],
W[3],
W[4],
W[5],
W[6],
W[7],

@tokenout[0],
@tokenout[1],
@tokenout[2],
@tokenout[3],
@tokenout[4],
@tokenout[5],
@tokenout[6],
@tokenout[7],
@W[0],
@W[1],
@W[2],
@W[3],
@W[4],
@W[5],
@W[6],
@W[7]

.

E
req[0],
req[1],
req[2],
req[3],
req[4],
req[5],
req[6],
req[7]
.
  (@tokenout[1] == tokenout[0])
& (@tokenout[2] == tokenout[1])
& (@tokenout[3] == tokenout[2])
& (@tokenout[4] == tokenout[3])
& (@tokenout[5] == tokenout[4])
& (@tokenout[6] == tokenout[5])
& (@tokenout[7] == tokenout[6])
& (@tokenout[0] == tokenout[7])
& (@W[0] == (W[0] + tokenout[0]) & req[0])
& (@W[1] == (W[1] + tokenout[1]) & req[1])
& (@W[2] == (W[2] + tokenout[2]) & req[2])
& (@W[3] == (W[3] + tokenout[3]) & req[3])
& (@W[4] == (W[4] + tokenout[4]) & req[4])
& (@W[5] == (W[5] + tokenout[5]) & req[5])
& (@W[6] == (W[6] + tokenout[6]) & req[6])
& (@W[7] == (W[7] + tokenout[7]) & req[7]);

write ("States reachable from initial state are:\n");

[ Reachable (N,S0) ] (
tokenout[0],
tokenout[1],
tokenout[2],
tokenout[3],
tokenout[4],
tokenout[5],
tokenout[6],
tokenout[7],
W[0],
W[1],
W[2],
W[3],
W[4],
W[5],
W[6],
W[7]
);
